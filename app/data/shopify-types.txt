scalar ARN
type AbandonedCheckout {
  abandonedCheckoutUrl: URL!
  billingAddress: MailingAddress
  completedAt: DateTime
  createdAt: DateTime!
  customAttributes: [Attribute!]!
  customer: Customer
  defaultCursor: String!
  discountCodes: [String!]!
  id: ID!
  lineItems: AbandonedCheckoutLineItemConnection!
  lineItemsQuantity: Int!
  name: String!
  note: String!
  shippingAddress: MailingAddress
  subtotalPriceSet: MoneyBag!
  taxLines: [TaxLine!]!
  taxesIncluded: Boolean!
  totalDiscountSet: MoneyBag!
  totalDutiesSet: MoneyBag
  totalLineItemsPriceSet: MoneyBag!
  totalPriceSet: MoneyBag!
  totalTaxSet: MoneyBag
  updatedAt: DateTime!
}
type AbandonedCheckoutConnection {
  edges: [AbandonedCheckoutEdge!]!
  nodes: [AbandonedCheckout!]!
  pageInfo: PageInfo!
}
type AbandonedCheckoutEdge {
  cursor: String!
  node: AbandonedCheckout!
}
type AbandonedCheckoutLineItem {
  components: [AbandonedCheckoutLineItemComponent!]
  customAttributes: [Attribute!]!
  discountAllocations: DiscountAllocationConnection!
  discountedTotalPriceSet: MoneyBag!
  discountedTotalPriceWithCodeDiscount: MoneyBag!
  discountedUnitPriceSet: MoneyBag!
  discountedUnitPriceWithCodeDiscount: MoneyBag!
  id: ID!
  image: Image
  originalTotalPriceSet: MoneyBag!
  originalUnitPriceSet: MoneyBag!
  product: Product
  quantity: Int!
  sku: String
  title: String
  variant: ProductVariant
  variantTitle: String
}
type AbandonedCheckoutLineItemComponent {
  id: ID!
  image: Image
  quantity: Int!
  title: String!
  variantTitle: String
}
type AbandonedCheckoutLineItemConnection {
  edges: [AbandonedCheckoutLineItemEdge!]!
  nodes: [AbandonedCheckoutLineItem!]!
  pageInfo: PageInfo!
}
type AbandonedCheckoutLineItemEdge {
  cursor: String!
  node: AbandonedCheckoutLineItem!
}
enum AbandonedCheckoutSortKeys {
  CHECKOUT_ID
  CREATED_AT
  CUSTOMER_NAME
  ID
  RELEVANCE
  TOTAL_PRICE
}
type Abandonment {
  abandonedCheckoutPayload: AbandonedCheckout
  abandonmentType: AbandonmentAbandonmentType!
  app: App!
  cartUrl: URL
  createdAt: DateTime!
  customer: Customer!
  customerHasNoDraftOrderSinceAbandonment: Boolean!
  customerHasNoOrderSinceAbandonment: Boolean!
  daysSinceLastAbandonmentEmail: Int!
  emailSentAt: DateTime
  emailState: AbandonmentEmailState
  hoursSinceLastAbandonedCheckout: Float
  id: ID!
  inventoryAvailable: Boolean!
  isFromCustomStorefront: Boolean!
  isFromOnlineStore: Boolean!
  isFromShopApp: Boolean!
  isFromShopPay: Boolean!
  isMostSignificantAbandonment: Boolean!
  lastBrowseAbandonmentDate: DateTime!
  lastCartAbandonmentDate: DateTime!
  lastCheckoutAbandonmentDate: DateTime!
  mostRecentStep: AbandonmentAbandonmentType!
  productsAddedToCart: CustomerVisitProductInfoConnection!
  productsViewed: CustomerVisitProductInfoConnection!
  visitStartedAt: DateTime
}
enum AbandonmentAbandonmentType {
  BROWSE
  CART
  CHECKOUT
}
enum AbandonmentDeliveryState {
  NOT_SENT
  SENT
  SCHEDULED
}
enum AbandonmentEmailState {
  NOT_SENT
  SENT
  SCHEDULED
}
type AbandonmentEmailStateUpdatePayload {
  abandonment: Abandonment
  userErrors: [AbandonmentEmailStateUpdateUserError!]!
}
type AbandonmentEmailStateUpdateUserError {
  code: AbandonmentEmailStateUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum AbandonmentEmailStateUpdateUserErrorCode {
  ABANDONMENT_NOT_FOUND
}
type AbandonmentUpdateActivitiesDeliveryStatusesPayload {
  abandonment: Abandonment
  userErrors: [AbandonmentUpdateActivitiesDeliveryStatusesUserError!]!
}
type AbandonmentUpdateActivitiesDeliveryStatusesUserError {
  code: AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode
  field: [String!]
  message: String!
}
enum AbandonmentUpdateActivitiesDeliveryStatusesUserErrorCode {
  ABANDONMENT_NOT_FOUND
  MARKETING_ACTIVITY_NOT_FOUND
  DELIVERY_STATUS_INFO_NOT_FOUND
}
type AccessScope {
  description: String!
  handle: String!
}
enum AccountType {
  REGULAR
  RESTRICTED
  INVITED
  REQUESTED
  COLLABORATOR
  COLLABORATOR_TEAM_MEMBER
  SAML
  INVITED_STORE_OWNER
}
type AddAllProductsOperation {
  id: ID!
  processedRowCount: Int
  rowCount: RowCount
  status: ResourceOperationStatus!
}
type AdditionalFee {
  id: ID!
  name: String!
  price: MoneyBag!
  taxLines: [TaxLine!]!
}
type AdditionalFeeSale {
  actionType: SaleActionType!
  additionalFee: SaleAdditionalFee!
  id: ID!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
type AdjustmentSale {
  actionType: SaleActionType!
  id: ID!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
enum AdjustmentsSortKeys {
  ID
  RELEVANCE
  TIME
}
type AllDiscountItems {
  allItems: Boolean!
}
type AndroidApplication {
  appLinksEnabled: Boolean!
  applicationId: String
  id: ID!
  sha256CertFingerprints: [String!]!
}
type ApiVersion {
  displayName: String!
  handle: String!
  supported: Boolean!
}
type App {
  apiKey: String!
  appStoreAppUrl: URL
  appStoreDeveloperUrl: URL
  availableAccessScopes: [AccessScope!]!
  banner: Image!
  description: String
  developerName: String
  developerType: AppDeveloperType!
  developerUrl: URL!
  embedded: Boolean!
  failedRequirements: [FailedRequirement!]!
  features: [String!]!
  feedback: AppFeedback
  handle: String
  icon: Image!
  id: ID!
  installUrl: URL
  installation: AppInstallation
  isPostPurchaseAppInUse: Boolean!
  launchUrl: URL!
  navigationItems: [NavigationItem!]!
  optionalAccessScopes: [AccessScope!]!
  previouslyInstalled: Boolean!
  pricingDetails: String
  pricingDetailsSummary: String!
  privacyPolicyUrl: URL
  publicCategory: AppPublicCategory!
  published: Boolean!
  requestedAccessScopes: [AccessScope!]!
  screenshots: [Image!]!
  shopifyDeveloped: Boolean!
  title: String!
  uninstallMessage: String!
  uninstallUrl: URL
  webhookApiVersion: String!
}
type AppCatalog {
  apps: AppConnection!
  id: ID!
  operations: [ResourceOperation!]!
  priceList: PriceList
  publication: Publication
  status: CatalogStatus!
  title: String!
}
type AppConnection {
  edges: [AppEdge!]!
  nodes: [App!]!
  pageInfo: PageInfo!
}
type AppCredit {
  amount: MoneyV2!
  createdAt: DateTime!
  description: String!
  id: ID!
  test: Boolean!
}
type AppCreditConnection {
  edges: [AppCreditEdge!]!
  nodes: [AppCredit!]!
  pageInfo: PageInfo!
}
type AppCreditEdge {
  cursor: String!
  node: AppCredit!
}
enum AppDeveloperType {
  SHOPIFY
  PARTNER
  MERCHANT
  UNKNOWN
}
type AppDiscountType {
  app: App!
  appBridge: FunctionsAppBridge!
  appKey: String!
  description: String
  discountClass: DiscountClass!
  functionId: String!
  targetType: DiscountApplicationTargetType!
  title: String!
}
type AppEdge {
  cursor: String!
  node: App!
}
type AppFeedback {
  app: App!
  feedbackGeneratedAt: DateTime!
  link: Link
  messages: [UserError!]!
  state: ResourceFeedbackState!
}
type AppInstallation {
  accessScopes: [AccessScope!]!
  activeSubscriptions: [AppSubscription!]!
  allSubscriptions: AppSubscriptionConnection!
  app: App!
  channel: Channel
  credits: AppCreditConnection!
  id: ID!
  launchUrl: URL!
  metafield: Metafield
  metafields: MetafieldConnection!
  oneTimePurchases: AppPurchaseOneTimeConnection!
  publication: Publication
  revenueAttributionRecords: AppRevenueAttributionRecordConnection!
  subscriptions: [AppSubscription!]!
  uninstallUrl: URL
}
enum AppInstallationCategory {
  CHANNEL
  POS_EMBEDDED
}
type AppInstallationConnection {
  edges: [AppInstallationEdge!]!
  nodes: [AppInstallation!]!
  pageInfo: PageInfo!
}
type AppInstallationEdge {
  cursor: String!
  node: AppInstallation!
}
enum AppInstallationPrivacy {
  PUBLIC
  PRIVATE
}
enum AppInstallationSortKeys {
  APP_TITLE
  ID
  INSTALLED_AT
  RELEVANCE
}
input AppPlanInput {
  appUsagePricingDetails: AppUsagePricingInput
  appRecurringPricingDetails: AppRecurringPricingInput
}
type AppPlanV2 {
  pricingDetails: AppPricingDetails!
}
union AppPricingDetails = AppRecurringPricing | AppUsagePricing
enum AppPricingInterval {
  ANNUAL
  EVERY_30_DAYS
}
enum AppPublicCategory {
  PRIVATE
  PUBLIC
  CUSTOM
  OTHER
}
interface AppPurchase {
  createdAt: DateTime!
  name: String!
  price: MoneyV2!
  status: AppPurchaseStatus!
  test: Boolean!
}
type AppPurchaseOneTime {
  createdAt: DateTime!
  id: ID!
  name: String!
  price: MoneyV2!
  status: AppPurchaseStatus!
  test: Boolean!
}
type AppPurchaseOneTimeConnection {
  edges: [AppPurchaseOneTimeEdge!]!
  nodes: [AppPurchaseOneTime!]!
  pageInfo: PageInfo!
}
type AppPurchaseOneTimeCreatePayload {
  appPurchaseOneTime: AppPurchaseOneTime
  confirmationUrl: URL
  userErrors: [UserError!]!
}
type AppPurchaseOneTimeEdge {
  cursor: String!
  node: AppPurchaseOneTime!
}
enum AppPurchaseStatus {
  ACCEPTED
  ACTIVE
  DECLINED
  EXPIRED
  PENDING
}
type AppRecurringPricing {
  discount: AppSubscriptionDiscount
  interval: AppPricingInterval!
  price: MoneyV2!
}
input AppRecurringPricingInput {
  interval: AppPricingInterval
  price: MoneyInput!
  discount: AppSubscriptionDiscountInput
}
type AppRevenueAttributionRecord {
  amount: MoneyV2!
  capturedAt: DateTime!
  createdAt: DateTime!
  id: ID!
  idempotencyKey: String!
  test: Boolean!
  type: AppRevenueAttributionType!
}
type AppRevenueAttributionRecordConnection {
  edges: [AppRevenueAttributionRecordEdge!]!
  nodes: [AppRevenueAttributionRecord!]!
  pageInfo: PageInfo!
}
type AppRevenueAttributionRecordEdge {
  cursor: String!
  node: AppRevenueAttributionRecord!
}
enum AppRevenueAttributionRecordSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
enum AppRevenueAttributionType {
  APPLICATION_PURCHASE
  APPLICATION_SUBSCRIPTION
  APPLICATION_USAGE
  OTHER
}
type AppRevokeAccessScopesAppRevokeScopeError {
  code: AppRevokeAccessScopesAppRevokeScopeErrorCode
  field: [String!]
  message: String!
}
enum AppRevokeAccessScopesAppRevokeScopeErrorCode {
  MISSING_SOURCE_APP
  APPLICATION_CANNOT_BE_FOUND
  UNKNOWN_SCOPES
  CANNOT_REVOKE_REQUIRED_SCOPES
  CANNOT_REVOKE_IMPLIED_SCOPES
  CANNOT_REVOKE_UNDECLARED_SCOPES
  APP_NOT_INSTALLED
}
type AppRevokeAccessScopesPayload {
  revoked: [AccessScope!]
  userErrors: [AppRevokeAccessScopesAppRevokeScopeError!]!
}
type AppSubscription {
  createdAt: DateTime!
  currentPeriodEnd: DateTime
  id: ID!
  lineItems: [AppSubscriptionLineItem!]!
  name: String!
  returnUrl: URL!
  status: AppSubscriptionStatus!
  test: Boolean!
  trialDays: Int!
}
type AppSubscriptionCancelPayload {
  appSubscription: AppSubscription
  userErrors: [UserError!]!
}
type AppSubscriptionConnection {
  edges: [AppSubscriptionEdge!]!
  nodes: [AppSubscription!]!
  pageInfo: PageInfo!
}
type AppSubscriptionCreatePayload {
  appSubscription: AppSubscription
  confirmationUrl: URL
  userErrors: [UserError!]!
}
type AppSubscriptionDiscount {
  durationLimitInIntervals: Int
  priceAfterDiscount: MoneyV2!
  remainingDurationInIntervals: Int
  value: AppSubscriptionDiscountValue!
}
type AppSubscriptionDiscountAmount {
  amount: MoneyV2!
}
input AppSubscriptionDiscountInput {
  value: AppSubscriptionDiscountValueInput
  durationLimitInIntervals: Int
}
type AppSubscriptionDiscountPercentage {
  percentage: Float!
}
union AppSubscriptionDiscountValue = AppSubscriptionDiscountAmount | AppSubscriptionDiscountPercentage
input AppSubscriptionDiscountValueInput {
  percentage: Float
  amount: Decimal
}
type AppSubscriptionEdge {
  cursor: String!
  node: AppSubscription!
}
type AppSubscriptionLineItem {
  id: ID!
  plan: AppPlanV2!
  usageRecords: AppUsageRecordConnection!
}
input AppSubscriptionLineItemInput {
  plan: AppPlanInput!
}
type AppSubscriptionLineItemUpdatePayload {
  appSubscription: AppSubscription
  confirmationUrl: URL
  userErrors: [UserError!]!
}
enum AppSubscriptionReplacementBehavior {
  APPLY_IMMEDIATELY
  APPLY_ON_NEXT_BILLING_CYCLE
  STANDARD
}
enum AppSubscriptionSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
enum AppSubscriptionStatus {
  PENDING
  ACCEPTED
  ACTIVE
  DECLINED
  EXPIRED
  FROZEN
  CANCELLED
}
type AppSubscriptionTrialExtendPayload {
  appSubscription: AppSubscription
  userErrors: [AppSubscriptionTrialExtendUserError!]!
}
type AppSubscriptionTrialExtendUserError {
  code: AppSubscriptionTrialExtendUserErrorCode
  field: [String!]
  message: String!
}
enum AppSubscriptionTrialExtendUserErrorCode {
  SUBSCRIPTION_NOT_FOUND
  TRIAL_NOT_ACTIVE
  SUBSCRIPTION_NOT_ACTIVE
}
enum AppTransactionSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
type AppUsagePricing {
  balanceUsed: MoneyV2!
  cappedAmount: MoneyV2!
  interval: AppPricingInterval!
  terms: String!
}
input AppUsagePricingInput {
  cappedAmount: MoneyInput!
  terms: String!
}
type AppUsageRecord {
  createdAt: DateTime!
  description: String!
  id: ID!
  idempotencyKey: String
  price: MoneyV2!
  subscriptionLineItem: AppSubscriptionLineItem!
}
type AppUsageRecordConnection {
  edges: [AppUsageRecordEdge!]!
  nodes: [AppUsageRecord!]!
  pageInfo: PageInfo!
}
type AppUsageRecordCreatePayload {
  appUsageRecord: AppUsageRecord
  userErrors: [UserError!]!
}
type AppUsageRecordEdge {
  cursor: String!
  node: AppUsageRecord!
}
enum AppUsageRecordSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
type AppleApplication {
  appClipApplicationId: String
  appClipsEnabled: Boolean!
  appId: String
  id: ID!
  sharedWebCredentialsEnabled: Boolean!
  universalLinksEnabled: Boolean!
}
type Article {
  author: ArticleAuthor
  blog: Blog!
  body: HTML!
  comments: CommentConnection!
  commentsCount: Count
  createdAt: DateTime!
  defaultCursor: String!
  events: EventConnection!
  handle: String!
  id: ID!
  image: Image
  isPublished: Boolean!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  publishedAt: DateTime
  summary: HTML
  tags: [String!]!
  templateSuffix: String
  title: String!
  translations: [Translation!]!
  updatedAt: DateTime
}
type ArticleAuthor {
  name: String!
}
input ArticleBlogInput {
  title: String!
}
type ArticleConnection {
  edges: [ArticleEdge!]!
  nodes: [Article!]!
  pageInfo: PageInfo!
}
input ArticleCreateInput {
  blogId: ID
  handle: String
  body: HTML
  summary: HTML
  isPublished: Boolean
  publishDate: DateTime
  templateSuffix: String
  metafields: [MetafieldInput!]
  tags: [String!]
  image: ArticleImageInput
  title: String!
  author: AuthorInput!
}
type ArticleCreatePayload {
  article: Article
  userErrors: [ArticleCreateUserError!]!
}
type ArticleCreateUserError {
  code: ArticleCreateUserErrorCode
  field: [String!]
  message: String!
}
enum ArticleCreateUserErrorCode {
  AMBIGUOUS_AUTHOR
  AMBIGUOUS_BLOG
  AUTHOR_FIELD_REQUIRED
  AUTHOR_MUST_EXIST
  INVALID_PUBLISH_DATE
  BLOG_REFERENCE_REQUIRED
  UPLOAD_FAILED
  BLANK
  NOT_FOUND
  TOO_LONG
  TAKEN
  INVALID
  INVALID_VALUE
  INVALID_TYPE
}
type ArticleDeletePayload {
  deletedArticleId: ID
  userErrors: [ArticleDeleteUserError!]!
}
type ArticleDeleteUserError {
  code: ArticleDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum ArticleDeleteUserErrorCode {
  NOT_FOUND
}
type ArticleEdge {
  cursor: String!
  node: Article!
}
input ArticleImageInput {
  altText: String
  url: String
}
enum ArticleSortKeys {
  AUTHOR
  BLOG_TITLE
  ID
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
}
enum ArticleTagSort {
  ALPHABETICAL
  POPULAR
}
input ArticleUpdateInput {
  blogId: ID
  handle: String
  body: HTML
  summary: HTML
  isPublished: Boolean
  publishDate: DateTime
  templateSuffix: String
  metafields: [MetafieldInput!]
  tags: [String!]
  image: ArticleImageInput
  title: String
  author: AuthorInput
  redirectNewHandle: Boolean
}
type ArticleUpdatePayload {
  article: Article
  userErrors: [ArticleUpdateUserError!]!
}
type ArticleUpdateUserError {
  code: ArticleUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum ArticleUpdateUserErrorCode {
  AMBIGUOUS_AUTHOR
  AMBIGUOUS_BLOG
  AUTHOR_MUST_EXIST
  INVALID_PUBLISH_DATE
  UPLOAD_FAILED
  BLANK
  NOT_FOUND
  TOO_LONG
  TAKEN
  INVALID
}
type Attribute {
  key: String!
  value: String
}
input AttributeInput {
  key: String!
  value: String!
}
input AuthorInput {
  name: String
  userId: ID
}
type AutomaticDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  index: Int!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  title: String!
  value: PricingValue!
}
enum AutomaticDiscountSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
type AvailableChannelDefinitionsByChannel {
  channelDefinitions: [ChannelDefinition!]!
  channelName: String!
}
enum BadgeType {
  DEFAULT
  SUCCESS
  ATTENTION
  WARNING
  INFO
  CRITICAL
}
enum BalanceTransactionSortKeys {
  AMOUNT
  FEE
  ID
  NET
  ORDER_NAME
  PAYMENT_METHOD_NAME
  PAYOUT_DATE
  PAYOUT_STATUS
  PROCESSED_AT
  RELEVANCE
  TRANSACTION_TYPE
}
interface BasePaymentDetails {
  paymentMethodName: String
}
type BasicEvent {
  action: String!
  additionalContent: JSON
  additionalData: JSON
  appTitle: String
  arguments: JSON
  attributeToApp: Boolean!
  attributeToUser: Boolean!
  createdAt: DateTime!
  criticalAlert: Boolean!
  hasAdditionalContent: Boolean!
  id: ID!
  message: FormattedString!
  secondaryMessage: FormattedString
  subject: HasEvents
  subjectId: ID!
  subjectType: EventSubjectType!
}
scalar BigInt
type BillingAttemptUserError {
  code: BillingAttemptUserErrorCode
  field: [String!]
  message: String!
}
enum BillingAttemptUserErrorCode {
  INVALID
  BLANK
  CONTRACT_NOT_FOUND
  ORIGIN_TIME_BEFORE_CONTRACT_CREATION
  UPCOMING_CYCLE_LIMIT_EXCEEDED
  CYCLE_INDEX_OUT_OF_RANGE
  CYCLE_START_DATE_OUT_OF_RANGE
  ORIGIN_TIME_OUT_OF_RANGE
  BILLING_CYCLE_CHARGE_BEFORE_EXPECTED_DATE
  BILLING_CYCLE_SKIPPED
  CONTRACT_UNDER_REVIEW
  CONTRACT_TERMINATED
  CONTRACT_PAUSED
}
type Blog {
  articles: ArticleConnection!
  articlesCount: Count
  commentPolicy: CommentPolicy!
  createdAt: DateTime!
  events: EventConnection!
  feed: BlogFeed
  handle: String!
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  tags: [String!]!
  templateSuffix: String
  title: String!
  translations: [Translation!]!
  updatedAt: DateTime
}
type BlogConnection {
  edges: [BlogEdge!]!
  nodes: [Blog!]!
  pageInfo: PageInfo!
}
input BlogCreateInput {
  handle: String
  templateSuffix: String
  metafields: [MetafieldInput!]
  commentPolicy: CommentPolicy
  title: String!
}
type BlogCreatePayload {
  blog: Blog
  userErrors: [BlogCreateUserError!]!
}
type BlogCreateUserError {
  code: BlogCreateUserErrorCode
  field: [String!]
  message: String!
}
enum BlogCreateUserErrorCode {
  INVALID
  TOO_LONG
  INCLUSION
  INVALID_VALUE
  INVALID_TYPE
}
type BlogDeletePayload {
  deletedBlogId: ID
  userErrors: [BlogDeleteUserError!]!
}
type BlogDeleteUserError {
  code: BlogDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum BlogDeleteUserErrorCode {
  NOT_FOUND
}
type BlogEdge {
  cursor: String!
  node: Blog!
}
type BlogFeed {
  location: URL!
  path: String!
}
enum BlogSortKeys {
  HANDLE
  ID
  RELEVANCE
  TITLE
}
input BlogUpdateInput {
  handle: String
  templateSuffix: String
  metafields: [MetafieldInput!]
  commentPolicy: CommentPolicy
  title: String
  redirectNewHandle: Boolean
  redirectArticles: Boolean
}
type BlogUpdatePayload {
  blog: Blog
  userErrors: [BlogUpdateUserError!]!
}
type BlogUpdateUserError {
  code: BlogUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum BlogUpdateUserErrorCode {
  NOT_FOUND
  INVALID
  BLANK
  TOO_LONG
  INCLUSION
}
scalar Boolean
enum BulkMutationErrorCode {
  OPERATION_IN_PROGRESS
  INVALID_MUTATION
  INVALID_STAGED_UPLOAD_FILE
  NO_SUCH_FILE
  INTERNAL_FILE_SERVER_ERROR
}
type BulkMutationUserError {
  code: BulkMutationErrorCode
  field: [String!]
  message: String!
}
type BulkOperation {
  completedAt: DateTime
  createdAt: DateTime!
  errorCode: BulkOperationErrorCode
  fileSize: UnsignedInt64
  id: ID!
  objectCount: UnsignedInt64!
  partialDataUrl: URL
  query: String!
  rootObjectCount: UnsignedInt64!
  status: BulkOperationStatus!
  type: BulkOperationType!
  url: URL
}
type BulkOperationCancelPayload {
  bulkOperation: BulkOperation
  userErrors: [UserError!]!
}
enum BulkOperationErrorCode {
  ACCESS_DENIED
  INTERNAL_SERVER_ERROR
  TIMEOUT
}
type BulkOperationRunMutationPayload {
  bulkOperation: BulkOperation
  userErrors: [BulkMutationUserError!]!
}
type BulkOperationRunQueryPayload {
  bulkOperation: BulkOperation
  userErrors: [BulkOperationUserError!]!
}
enum BulkOperationStatus {
  CANCELED
  CANCELING
  COMPLETED
  CREATED
  EXPIRED
  FAILED
  RUNNING
}
enum BulkOperationType {
  QUERY
  MUTATION
}
type BulkOperationUserError {
  code: BulkOperationUserErrorCode
  field: [String!]
  message: String!
}
enum BulkOperationUserErrorCode {
  OPERATION_IN_PROGRESS
  INVALID
}
type BulkProductResourceFeedbackCreatePayload {
  feedback: [ProductResourceFeedback!]
  userErrors: [BulkProductResourceFeedbackCreateUserError!]!
}
type BulkProductResourceFeedbackCreateUserError {
  code: BulkProductResourceFeedbackCreateUserErrorCode
  field: [String!]
  message: String!
}
enum BulkProductResourceFeedbackCreateUserErrorCode {
  MAXIMUM_FEEDBACK_LIMIT_EXCEEDED
  OUTDATED_FEEDBACK
  PRODUCT_NOT_FOUND
  INVALID
  BLANK
  PRESENT
  LESS_THAN_OR_EQUAL_TO
}
input BundlesDraftOrderBundleLineItemComponentInput {
  variantId: ID
  quantity: Int!
  uuid: String
}
type BundlesFeature {
  eligibleForBundles: Boolean!
  ineligibilityReason: String
  sellsBundles: Boolean!
}
enum BusinessCustomerErrorCode {
  INTERNAL_ERROR
  RESOURCE_NOT_FOUND
  FAILED_TO_DELETE
  REQUIRED
  NO_INPUT
  INVALID_INPUT
  UNEXPECTED_TYPE
  TOO_LONG
  LIMIT_REACHED
  INVALID
  BLANK
  TAKEN
}
type BusinessCustomerUserError {
  code: BusinessCustomerErrorCode
  field: [String!]
  message: String!
}
type BusinessEntity {
  address: BusinessEntityAddress!
  companyName: String
  displayName: String!
  id: ID!
  primary: Boolean!
  shopifyPaymentsAccount: ShopifyPaymentsAccount
}
type BusinessEntityAddress {
  address1: String
  address2: String
  city: String
  countryCode: CountryCode!
  province: String
  zip: String
}
type BuyerExperienceConfiguration {
  checkoutToDraft: Boolean!
  deposit: DepositConfiguration
  editableShippingAddress: Boolean!
  payNowOnly: Boolean!
  paymentTermsTemplate: PaymentTermsTemplate
}
input BuyerExperienceConfigurationInput {
  checkoutToDraft: Boolean
  paymentTermsTemplateId: ID
  editableShippingAddress: Boolean
  deposit: DepositInput
}
input CalculateExchangeLineItemInput {
  variantId: ID
  quantity: Int!
  appliedDiscount: ExchangeLineItemAppliedDiscountInput
}
input CalculateReturnInput {
  orderId: ID!
  returnLineItems: [CalculateReturnLineItemInput!]
  exchangeLineItems: [CalculateExchangeLineItemInput!]
  returnShippingFee: ReturnShippingFeeInput
}
input CalculateReturnLineItemInput {
  fulfillmentLineItemId: ID!
  restockingFee: RestockingFeeInput
  quantity: Int!
}
type CalculatedAutomaticDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  appliedTo: DiscountApplicationLevel!
  description: String
  id: ID!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  value: PricingValue!
}
type CalculatedDiscountAllocation {
  allocatedAmountSet: MoneyBag!
  discountApplication: CalculatedDiscountApplication!
}
interface CalculatedDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  appliedTo: DiscountApplicationLevel!
  description: String
  id: ID!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  value: PricingValue!
}
type CalculatedDiscountApplicationConnection {
  edges: [CalculatedDiscountApplicationEdge!]!
  nodes: [CalculatedDiscountApplication!]!
  pageInfo: PageInfo!
}
type CalculatedDiscountApplicationEdge {
  cursor: String!
  node: CalculatedDiscountApplication!
}
type CalculatedDiscountCodeApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  appliedTo: DiscountApplicationLevel!
  code: String!
  description: String
  id: ID!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  value: PricingValue!
}
type CalculatedDraftOrder {
  acceptAutomaticDiscounts: Boolean
  alerts: [ResourceAlert!]!
  allVariantPricesOverridden: Boolean!
  anyVariantPricesOverridden: Boolean!
  appliedDiscount: DraftOrderAppliedDiscount
  availableShippingRates: [ShippingRate!]!
  billingAddressMatchesShippingAddress: Boolean!
  currencyCode: CurrencyCode!
  customer: Customer
  discountCodes: [String!]!
  lineItems: [CalculatedDraftOrderLineItem!]!
  lineItemsSubtotalPrice: MoneyBag!
  marketName: String!
  marketRegionCountryCode: CountryCode!
  phone: String
  platformDiscounts: [DraftOrderPlatformDiscount!]!
  presentmentCurrencyCode: CurrencyCode!
  purchasingEntity: PurchasingEntity
  shippingLine: ShippingLine
  subtotalPrice: Money!
  subtotalPriceSet: MoneyBag!
  taxLines: [TaxLine!]!
  taxesIncluded: Boolean!
  totalDiscountsSet: MoneyBag!
  totalLineItemsPriceSet: MoneyBag!
  totalPrice: Money!
  totalPriceSet: MoneyBag!
  totalQuantityOfLineItems: Int!
  totalShippingPrice: Money!
  totalShippingPriceSet: MoneyBag!
  totalTax: Money!
  totalTaxSet: MoneyBag!
  transformerFingerprint: String
  warnings: [DraftOrderWarning!]!
}
type CalculatedDraftOrderLineItem {
  appliedDiscount: DraftOrderAppliedDiscount
  approximateDiscountedUnitPriceSet: MoneyBag!
  bundleComponents: [CalculatedDraftOrderLineItem!]!
  custom: Boolean!
  customAttributes: [Attribute!]!
  customAttributesV2: [TypedAttribute!]!
  discountedTotal: MoneyV2!
  discountedTotalSet: MoneyBag!
  discountedUnitPrice: MoneyV2!
  discountedUnitPriceSet: MoneyBag!
  fulfillmentService: FulfillmentService
  image: Image
  isGiftCard: Boolean!
  name: String!
  originalTotal: MoneyV2!
  originalTotalSet: MoneyBag!
  originalUnitPrice: MoneyV2!
  originalUnitPriceSet: MoneyBag!
  originalUnitPriceWithCurrency: MoneyV2
  priceOverride: MoneyV2
  product: Product
  quantity: Int!
  requiresShipping: Boolean!
  sku: String
  taxable: Boolean!
  title: String!
  totalDiscount: MoneyV2!
  totalDiscountSet: MoneyBag!
  uuid: String!
  variant: ProductVariant
  variantTitle: String
  vendor: String
  weight: Weight
}
type CalculatedExchangeLineItem {
  calculatedDiscountAllocations: [CalculatedDiscountAllocation!]!
  discountedUnitPriceSet: MoneyBag!
  id: ID
  originalUnitPriceSet: MoneyBag!
  quantity: Int!
  subtotalSet: MoneyBag!
  totalTaxSet: MoneyBag!
  variant: ProductVariant
}
type CalculatedLineItem {
  calculatedDiscountAllocations: [CalculatedDiscountAllocation!]!
  customAttributes: [Attribute!]!
  discountAllocations: [DiscountAllocation!]!
  discountedUnitPriceSet: MoneyBag!
  editableQuantity: Int!
  editableQuantityBeforeChanges: Int!
  editableSubtotalSet: MoneyBag!
  hasStagedLineItemDiscount: Boolean!
  id: ID!
  image: Image
  originalUnitPriceSet: MoneyBag!
  quantity: Int!
  restockable: Boolean!
  restocking: Boolean!
  sku: String
  stagedChanges: [OrderStagedChange!]!
  title: String!
  uneditableSubtotalSet: MoneyBag!
  variant: ProductVariant
  variantTitle: String
}
type CalculatedLineItemConnection {
  edges: [CalculatedLineItemEdge!]!
  nodes: [CalculatedLineItem!]!
  pageInfo: PageInfo!
}
type CalculatedLineItemEdge {
  cursor: String!
  node: CalculatedLineItem!
}
type CalculatedManualDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  appliedTo: DiscountApplicationLevel!
  description: String
  id: ID!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  value: PricingValue!
}
type CalculatedOrder {
  addedDiscountApplications: CalculatedDiscountApplicationConnection!
  addedLineItems: CalculatedLineItemConnection!
  cartDiscountAmountSet: MoneyBag
  committed: Boolean!
  id: ID!
  lineItems: CalculatedLineItemConnection!
  notificationPreviewHtml: HTML
  notificationPreviewTitle: String!
  originalOrder: Order!
  shippingLines: [CalculatedShippingLine!]!
  stagedChanges: OrderStagedChangeConnection!
  subtotalLineItemsQuantity: Int!
  subtotalPriceSet: MoneyBag
  taxLines: [TaxLine!]!
  totalOutstandingSet: MoneyBag!
  totalPriceSet: MoneyBag!
}
type CalculatedRestockingFee {
  amountSet: MoneyBag!
  id: ID!
  percentage: Float!
}
type CalculatedReturn {
  exchangeLineItems: [CalculatedExchangeLineItem!]!
  id: ID!
  returnLineItems: [CalculatedReturnLineItem!]!
  returnShippingFee: CalculatedReturnShippingFee
}
interface CalculatedReturnFee {
  amountSet: MoneyBag!
  id: ID!
}
type CalculatedReturnLineItem {
  fulfillmentLineItem: FulfillmentLineItem!
  id: ID
  quantity: Int!
  restockingFee: CalculatedRestockingFee
  subtotalBeforeOrderDiscountsSet: MoneyBag!
  subtotalSet: MoneyBag!
  totalTaxSet: MoneyBag!
}
type CalculatedReturnShippingFee {
  amountSet: MoneyBag!
  id: ID!
}
type CalculatedScriptDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  appliedTo: DiscountApplicationLevel!
  description: String
  id: ID!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  value: PricingValue!
}
type CalculatedShippingLine {
  id: ID
  price: MoneyBag!
  stagedStatus: CalculatedShippingLineStagedStatus!
  title: String!
}
enum CalculatedShippingLineStagedStatus {
  NONE
  ADDED
  REMOVED
}
type CardPaymentDetails {
  avsResultCode: String
  bin: String
  company: String
  cvvResultCode: String
  expirationMonth: Int
  expirationYear: Int
  name: String
  number: String
  paymentMethodName: String
  wallet: DigitalWallet
}
type CarrierServiceCreatePayload {
  carrierService: DeliveryCarrierService
  userErrors: [CarrierServiceCreateUserError!]!
}
type CarrierServiceCreateUserError {
  code: CarrierServiceCreateUserErrorCode
  field: [String!]
  message: String!
}
enum CarrierServiceCreateUserErrorCode {
  CARRIER_SERVICE_CREATE_FAILED
}
type CarrierServiceDeletePayload {
  deletedId: ID
  userErrors: [CarrierServiceDeleteUserError!]!
}
type CarrierServiceDeleteUserError {
  code: CarrierServiceDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum CarrierServiceDeleteUserErrorCode {
  CARRIER_SERVICE_DELETE_FAILED
}
enum CarrierServiceSortKeys {
  CREATED_AT
  ID
  RELEVANCE
  UPDATED_AT
}
type CarrierServiceUpdatePayload {
  carrierService: DeliveryCarrierService
  userErrors: [CarrierServiceUpdateUserError!]!
}
type CarrierServiceUpdateUserError {
  code: CarrierServiceUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum CarrierServiceUpdateUserErrorCode {
  CARRIER_SERVICE_UPDATE_FAILED
}
type CartTransform {
  blockOnFailure: Boolean!
  functionId: String!
  id: ID!
  metafield: Metafield
  metafields: MetafieldConnection!
}
type CartTransformConnection {
  edges: [CartTransformEdge!]!
  nodes: [CartTransform!]!
  pageInfo: PageInfo!
}
type CartTransformCreatePayload {
  cartTransform: CartTransform
  userErrors: [CartTransformCreateUserError!]!
}
type CartTransformCreateUserError {
  code: CartTransformCreateUserErrorCode
  field: [String!]
  message: String!
}
enum CartTransformCreateUserErrorCode {
  INPUT_INVALID
  FUNCTION_NOT_FOUND
  FUNCTION_ALREADY_REGISTERED
  FUNCTION_DOES_NOT_IMPLEMENT
  INVALID_METAFIELDS
}
type CartTransformDeletePayload {
  deletedId: ID
  userErrors: [CartTransformDeleteUserError!]!
}
type CartTransformDeleteUserError {
  code: CartTransformDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum CartTransformDeleteUserErrorCode {
  NOT_FOUND
  UNAUTHORIZED_APP_SCOPE
}
type CartTransformEdge {
  cursor: String!
  node: CartTransform!
}
type CartTransformEligibleOperations {
  expandOperation: Boolean!
  mergeOperation: Boolean!
  updateOperation: Boolean!
}
type CartTransformFeature {
  eligibleOperations: CartTransformEligibleOperations!
}
type CashRoundingAdjustment {
  paymentSet: MoneyBag!
  refundSet: MoneyBag!
}
type CashTrackingAdjustment {
  cash: MoneyV2!
  id: ID!
  note: String
  staffMember: StaffMember!
  time: DateTime!
}
type CashTrackingAdjustmentConnection {
  edges: [CashTrackingAdjustmentEdge!]!
  nodes: [CashTrackingAdjustment!]!
  pageInfo: PageInfo!
}
type CashTrackingAdjustmentEdge {
  cursor: String!
  node: CashTrackingAdjustment!
}
type CashTrackingSession {
  adjustments: CashTrackingAdjustmentConnection!
  cashTrackingEnabled: Boolean!
  cashTransactions: OrderTransactionConnection!
  closingBalance: MoneyV2
  closingNote: String
  closingStaffMember: StaffMember
  closingTime: DateTime
  expectedBalance: MoneyV2!
  expectedClosingBalance: MoneyV2
  expectedOpeningBalance: MoneyV2
  id: ID!
  location: Location
  netCashSales: MoneyV2!
  openingBalance: MoneyV2!
  openingNote: String
  openingStaffMember: StaffMember
  openingTime: DateTime!
  registerName: String!
  totalAdjustments: MoneyV2
  totalCashRefunds: MoneyV2!
  totalCashSales: MoneyV2!
  totalDiscrepancy: MoneyV2
}
type CashTrackingSessionConnection {
  edges: [CashTrackingSessionEdge!]!
  nodes: [CashTrackingSession!]!
  pageInfo: PageInfo!
}
type CashTrackingSessionEdge {
  cursor: String!
  node: CashTrackingSession!
}
enum CashTrackingSessionTransactionsSortKeys {
  ID
  PROCESSED_AT
  RELEVANCE
}
enum CashTrackingSessionsSortKeys {
  CLOSING_TIME_ASC
  CLOSING_TIME_DESC
  ID
  OPENING_TIME_ASC
  OPENING_TIME_DESC
  RELEVANCE
  TOTAL_DISCREPANCY_ASC
  TOTAL_DISCREPANCY_DESC
}
interface Catalog {
  id: ID!
  operations: [ResourceOperation!]!
  priceList: PriceList
  publication: Publication
  status: CatalogStatus!
  title: String!
}
type CatalogConnection {
  edges: [CatalogEdge!]!
  nodes: [Catalog!]!
  pageInfo: PageInfo!
}
input CatalogContextInput {
  companyLocationIds: [ID!]
}
type CatalogContextUpdatePayload {
  catalog: Catalog
  userErrors: [CatalogUserError!]!
}
input CatalogCreateInput {
  title: String!
  status: CatalogStatus!
  context: CatalogContextInput!
  priceListId: ID
  publicationId: ID
}
type CatalogCreatePayload {
  catalog: Catalog
  userErrors: [CatalogUserError!]!
}
type CatalogCsvOperation {
  id: ID!
  processedRowCount: Int
  rowCount: RowCount
  status: ResourceOperationStatus!
}
type CatalogDeletePayload {
  deletedId: ID
  userErrors: [CatalogUserError!]!
}
type CatalogEdge {
  cursor: String!
  node: Catalog!
}
enum CatalogSortKeys {
  ID
  RELEVANCE
  TITLE
}
enum CatalogStatus {
  ACTIVE
  ARCHIVED
  DRAFT
}
enum CatalogType {
  NONE
  APP
  COMPANY_LOCATION
  MARKET
}
input CatalogUpdateInput {
  title: String
  status: CatalogStatus
  context: CatalogContextInput
  priceListId: ID
  publicationId: ID
}
type CatalogUpdatePayload {
  catalog: Catalog
  userErrors: [CatalogUserError!]!
}
type CatalogUserError {
  code: CatalogUserErrorCode
  field: [String!]
  message: String!
}
enum CatalogUserErrorCode {
  APP_CATALOG_PRICE_LIST_ASSIGNMENT
  CATALOG_FAILED_TO_SAVE
  CATALOG_NOT_FOUND
  PRICE_LIST_NOT_ALLOWED_FOR_PRIMARY_MARKET
  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES
  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_PRICE_BREAKS
  CANNOT_ADD_MORE_THAN_ONE_MARKET
  COMPANY_LOCATION_CATALOG_STATUS_PLAN
  CONTEXT_ALREADY_ASSIGNED_TO_CATALOG
  CONTEXT_CATALOG_LIMIT_REACHED
  COMPANY_LOCATION_NOT_FOUND
  CONTEXT_DRIVER_MISMATCH
  COUNTRY_PRICE_LIST_ASSIGNMENT
  INVALID_CATALOG_CONTEXT_TYPE
  MARKET_CATALOG_STATUS
  MARKET_NOT_FOUND
  MARKET_AND_PRICE_LIST_CURRENCY_MISMATCH
  MARKET_TAKEN
  MUST_PROVIDE_EXACTLY_ONE_CONTEXT_TYPE
  PRICE_LIST_FAILED_TO_SAVE
  PRICE_LIST_NOT_FOUND
  PRICE_LIST_LOCKED
  PUBLICATION_NOT_FOUND
  REQUIRES_CONTEXTS_TO_ADD_OR_REMOVE
  UNSUPPORTED_CATALOG_ACTION
  CANNOT_CREATE_APP_CATALOG
  CANNOT_MODIFY_APP_CATALOG
  CANNOT_DELETE_APP_CATALOG
  CANNOT_CREATE_MARKET_CATALOG
  CANNOT_MODIFY_MARKET_CATALOG
  CANNOT_DELETE_MARKET_CATALOG
  INVALID
  TAKEN
  TOO_LONG
  TOO_SHORT
  BLANK
}
type Channel {
  app: App!
  collectionPublicationsV3: ResourcePublicationConnection!
  collections: CollectionConnection!
  handle: String!
  hasCollection: Boolean!
  id: ID!
  name: String!
  navigationItems: [NavigationItem!]!
  overviewPath: URL
  productPublications: ProductPublicationConnection!
  productPublicationsV3: ResourcePublicationConnection!
  products: ProductConnection!
  productsCount: Count
  supportsFuturePublishing: Boolean!
}
type ChannelConnection {
  edges: [ChannelEdge!]!
  nodes: [Channel!]!
  pageInfo: PageInfo!
}
type ChannelDefinition {
  channelName: String!
  handle: String!
  id: ID!
  isMarketplace: Boolean!
  subChannelName: String!
  svgIcon: String
}
type ChannelEdge {
  cursor: String!
  node: Channel!
}
type ChannelInformation {
  app: App!
  channelDefinition: ChannelDefinition
  channelId: ID!
  id: ID!
}
type CheckoutBranding {
  customizations: CheckoutBrandingCustomizations
  designSystem: CheckoutBrandingDesignSystem
}
enum CheckoutBrandingBackground {
  BASE
  SUBDUED
  TRANSPARENT
}
enum CheckoutBrandingBackgroundStyle {
  SOLID
  NONE
}
enum CheckoutBrandingBorder {
  NONE
  BLOCK_END
  FULL
}
enum CheckoutBrandingBorderStyle {
  BASE
  DASHED
  DOTTED
}
enum CheckoutBrandingBorderWidth {
  BASE
  LARGE_100
  LARGE_200
  LARGE
}
type CheckoutBrandingButton {
  background: CheckoutBrandingBackgroundStyle
  blockPadding: CheckoutBrandingSpacing
  border: CheckoutBrandingSimpleBorder
  cornerRadius: CheckoutBrandingCornerRadius
  inlinePadding: CheckoutBrandingSpacing
  typography: CheckoutBrandingTypographyStyle
}
type CheckoutBrandingButtonColorRoles {
  accent: String
  background: String
  border: String
  decorative: String
  hover: CheckoutBrandingColorRoles
  icon: String
  text: String
}
input CheckoutBrandingButtonColorRolesInput {
  background: String
  text: String
  border: String
  icon: String
  accent: String
  decorative: String
  hover: CheckoutBrandingColorRolesInput
}
input CheckoutBrandingButtonInput {
  background: CheckoutBrandingBackgroundStyle
  border: CheckoutBrandingSimpleBorder
  cornerRadius: CheckoutBrandingCornerRadius
  blockPadding: CheckoutBrandingSpacing
  inlinePadding: CheckoutBrandingSpacing
  typography: CheckoutBrandingTypographyStyleInput
}
type CheckoutBrandingBuyerJourney {
  visibility: CheckoutBrandingVisibility
}
input CheckoutBrandingBuyerJourneyInput {
  visibility: CheckoutBrandingVisibility
}
type CheckoutBrandingCartLink {
  visibility: CheckoutBrandingVisibility
}
enum CheckoutBrandingCartLinkContentType {
  ICON
  IMAGE
  TEXT
}
input CheckoutBrandingCartLinkInput {
  visibility: CheckoutBrandingVisibility
}
type CheckoutBrandingCheckbox {
  cornerRadius: CheckoutBrandingCornerRadius
}
input CheckoutBrandingCheckboxInput {
  cornerRadius: CheckoutBrandingCornerRadius
}
type CheckoutBrandingChoiceList {
  group: CheckoutBrandingChoiceListGroup
}
type CheckoutBrandingChoiceListGroup {
  spacing: CheckoutBrandingSpacingKeyword
}
input CheckoutBrandingChoiceListGroupInput {
  spacing: CheckoutBrandingSpacingKeyword
}
input CheckoutBrandingChoiceListInput {
  group: CheckoutBrandingChoiceListGroupInput
}
type CheckoutBrandingColorGlobal {
  accent: String
  brand: String
  critical: String
  decorative: String
  info: String
  success: String
  warning: String
}
input CheckoutBrandingColorGlobalInput {
  info: String
  success: String
  warning: String
  critical: String
  brand: String
  accent: String
  decorative: String
}
type CheckoutBrandingColorRoles {
  accent: String
  background: String
  border: String
  decorative: String
  icon: String
  text: String
}
input CheckoutBrandingColorRolesInput {
  background: String
  text: String
  border: String
  icon: String
  accent: String
  decorative: String
}
type CheckoutBrandingColorScheme {
  base: CheckoutBrandingColorRoles
  control: CheckoutBrandingControlColorRoles
  primaryButton: CheckoutBrandingButtonColorRoles
  secondaryButton: CheckoutBrandingButtonColorRoles
}
input CheckoutBrandingColorSchemeInput {
  base: CheckoutBrandingColorRolesInput
  control: CheckoutBrandingControlColorRolesInput
  primaryButton: CheckoutBrandingButtonColorRolesInput
  secondaryButton: CheckoutBrandingButtonColorRolesInput
}
enum CheckoutBrandingColorSchemeSelection {
  TRANSPARENT
  COLOR_SCHEME1
  COLOR_SCHEME2
  COLOR_SCHEME3
  COLOR_SCHEME4
}
type CheckoutBrandingColorSchemes {
  scheme1: CheckoutBrandingColorScheme
  scheme2: CheckoutBrandingColorScheme
  scheme3: CheckoutBrandingColorScheme
  scheme4: CheckoutBrandingColorScheme
}
input CheckoutBrandingColorSchemesInput {
  scheme1: CheckoutBrandingColorSchemeInput
  scheme2: CheckoutBrandingColorSchemeInput
  scheme3: CheckoutBrandingColorSchemeInput
  scheme4: CheckoutBrandingColorSchemeInput
}
enum CheckoutBrandingColorSelection {
  TRANSPARENT
}
type CheckoutBrandingColors {
  global: CheckoutBrandingColorGlobal
  schemes: CheckoutBrandingColorSchemes
}
input CheckoutBrandingColorsInput {
  global: CheckoutBrandingColorGlobalInput
  schemes: CheckoutBrandingColorSchemesInput
}
type CheckoutBrandingContainerDivider {
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
  visibility: CheckoutBrandingVisibility
}
input CheckoutBrandingContainerDividerInput {
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
  visibility: CheckoutBrandingVisibility
}
type CheckoutBrandingContent {
  divider: CheckoutBrandingContainerDivider
}
input CheckoutBrandingContentInput {
  divider: CheckoutBrandingContainerDividerInput
}
type CheckoutBrandingControl {
  border: CheckoutBrandingSimpleBorder
  color: CheckoutBrandingColorSelection
  cornerRadius: CheckoutBrandingCornerRadius
  labelPosition: CheckoutBrandingLabelPosition
}
type CheckoutBrandingControlColorRoles {
  accent: String
  background: String
  border: String
  decorative: String
  icon: String
  selected: CheckoutBrandingColorRoles
  text: String
}
input CheckoutBrandingControlColorRolesInput {
  background: String
  text: String
  border: String
  icon: String
  accent: String
  decorative: String
  selected: CheckoutBrandingColorRolesInput
}
input CheckoutBrandingControlInput {
  color: CheckoutBrandingColorSelection
  cornerRadius: CheckoutBrandingCornerRadius
  border: CheckoutBrandingSimpleBorder
  labelPosition: CheckoutBrandingLabelPosition
}
enum CheckoutBrandingCornerRadius {
  NONE
  SMALL
  BASE
  LARGE
}
type CheckoutBrandingCornerRadiusVariables {
  base: Int
  large: Int
  small: Int
}
input CheckoutBrandingCornerRadiusVariablesInput {
  small: Int
  base: Int
  large: Int
}
type CheckoutBrandingCustomFont {
  genericFileId: ID
  sources: String
  weight: Int
}
input CheckoutBrandingCustomFontGroupInput {
  base: CheckoutBrandingCustomFontInput!
  bold: CheckoutBrandingCustomFontInput!
  loadingStrategy: CheckoutBrandingFontLoadingStrategy
}
input CheckoutBrandingCustomFontInput {
  weight: Int!
  genericFileId: ID!
}
type CheckoutBrandingCustomizations {
  buyerJourney: CheckoutBrandingBuyerJourney
  cartLink: CheckoutBrandingCartLink
  checkbox: CheckoutBrandingCheckbox
  choiceList: CheckoutBrandingChoiceList
  content: CheckoutBrandingContent
  control: CheckoutBrandingControl
  divider: CheckoutBrandingDividerStyle
  expressCheckout: CheckoutBrandingExpressCheckout
  favicon: CheckoutBrandingImage
  footer: CheckoutBrandingFooter
  global: CheckoutBrandingGlobal
  header: CheckoutBrandingHeader
  headingLevel1: CheckoutBrandingHeadingLevel
  headingLevel2: CheckoutBrandingHeadingLevel
  headingLevel3: CheckoutBrandingHeadingLevel
  main: CheckoutBrandingMain
  merchandiseThumbnail: CheckoutBrandingMerchandiseThumbnail
  orderSummary: CheckoutBrandingOrderSummary
  primaryButton: CheckoutBrandingButton
  secondaryButton: CheckoutBrandingButton
  select: CheckoutBrandingSelect
  textField: CheckoutBrandingTextField
}
input CheckoutBrandingCustomizationsInput {
  global: CheckoutBrandingGlobalInput
  header: CheckoutBrandingHeaderInput
  headingLevel1: CheckoutBrandingHeadingLevelInput
  headingLevel2: CheckoutBrandingHeadingLevelInput
  headingLevel3: CheckoutBrandingHeadingLevelInput
  footer: CheckoutBrandingFooterInput
  main: CheckoutBrandingMainInput
  orderSummary: CheckoutBrandingOrderSummaryInput
  control: CheckoutBrandingControlInput
  textField: CheckoutBrandingTextFieldInput
  checkbox: CheckoutBrandingCheckboxInput
  select: CheckoutBrandingSelectInput
  primaryButton: CheckoutBrandingButtonInput
  secondaryButton: CheckoutBrandingButtonInput
  favicon: CheckoutBrandingImageInput
  choiceList: CheckoutBrandingChoiceListInput
  merchandiseThumbnail: CheckoutBrandingMerchandiseThumbnailInput
  expressCheckout: CheckoutBrandingExpressCheckoutInput
  content: CheckoutBrandingContentInput
  buyerJourney: CheckoutBrandingBuyerJourneyInput
  cartLink: CheckoutBrandingCartLinkInput
  divider: CheckoutBrandingDividerStyleInput
}
type CheckoutBrandingDesignSystem {
  colors: CheckoutBrandingColors
  cornerRadius: CheckoutBrandingCornerRadiusVariables
  typography: CheckoutBrandingTypography
}
input CheckoutBrandingDesignSystemInput {
  colors: CheckoutBrandingColorsInput
  typography: CheckoutBrandingTypographyInput
  cornerRadius: CheckoutBrandingCornerRadiusVariablesInput
}
type CheckoutBrandingDividerStyle {
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
}
input CheckoutBrandingDividerStyleInput {
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
}
type CheckoutBrandingExpressCheckout {
  button: CheckoutBrandingExpressCheckoutButton
}
type CheckoutBrandingExpressCheckoutButton {
  cornerRadius: CheckoutBrandingCornerRadius
}
input CheckoutBrandingExpressCheckoutButtonInput {
  cornerRadius: CheckoutBrandingCornerRadius
}
input CheckoutBrandingExpressCheckoutInput {
  button: CheckoutBrandingExpressCheckoutButtonInput
}
interface CheckoutBrandingFont {
  sources: String
  weight: Int
}
type CheckoutBrandingFontGroup {
  base: CheckoutBrandingFont
  bold: CheckoutBrandingFont
  loadingStrategy: CheckoutBrandingFontLoadingStrategy
  name: String
}
input CheckoutBrandingFontGroupInput {
  shopifyFontGroup: CheckoutBrandingShopifyFontGroupInput
  customFontGroup: CheckoutBrandingCustomFontGroupInput
}
enum CheckoutBrandingFontLoadingStrategy {
  AUTO
  BLOCK
  SWAP
  FALLBACK
  OPTIONAL
}
type CheckoutBrandingFontSize {
  base: Float
  ratio: Float
}
input CheckoutBrandingFontSizeInput {
  base: Float
  ratio: Float
}
type CheckoutBrandingFooter {
  alignment: CheckoutBrandingFooterAlignment
  colorScheme: CheckoutBrandingColorSchemeSelection
  content: CheckoutBrandingFooterContent
  divided: Boolean
  padding: CheckoutBrandingSpacingKeyword
  position: CheckoutBrandingFooterPosition
}
enum CheckoutBrandingFooterAlignment {
  START
  CENTER
  END
}
type CheckoutBrandingFooterContent {
  visibility: CheckoutBrandingVisibility
}
input CheckoutBrandingFooterContentInput {
  visibility: CheckoutBrandingVisibility
}
input CheckoutBrandingFooterInput {
  position: CheckoutBrandingFooterPosition
  divided: Boolean
  alignment: CheckoutBrandingFooterAlignment
  content: CheckoutBrandingFooterContentInput
  colorScheme: CheckoutBrandingColorSchemeSelection
  padding: CheckoutBrandingSpacingKeyword
}
enum CheckoutBrandingFooterPosition {
  END
  INLINE
}
type CheckoutBrandingGlobal {
  cornerRadius: CheckoutBrandingGlobalCornerRadius
  typography: CheckoutBrandingTypographyStyleGlobal
}
enum CheckoutBrandingGlobalCornerRadius {
  NONE
}
input CheckoutBrandingGlobalInput {
  cornerRadius: CheckoutBrandingGlobalCornerRadius
  typography: CheckoutBrandingTypographyStyleGlobalInput
}
type CheckoutBrandingHeader {
  alignment: CheckoutBrandingHeaderAlignment
  banner: CheckoutBrandingImage
  cartLink: CheckoutBrandingHeaderCartLink
  colorScheme: CheckoutBrandingColorSchemeSelection
  divided: Boolean
  logo: CheckoutBrandingLogo
  padding: CheckoutBrandingSpacingKeyword
  position: CheckoutBrandingHeaderPosition
}
enum CheckoutBrandingHeaderAlignment {
  START
  CENTER
  END
}
type CheckoutBrandingHeaderCartLink {
  contentType: CheckoutBrandingCartLinkContentType
  image: Image
}
input CheckoutBrandingHeaderCartLinkInput {
  contentType: CheckoutBrandingCartLinkContentType
  image: CheckoutBrandingImageInput
}
input CheckoutBrandingHeaderInput {
  alignment: CheckoutBrandingHeaderAlignment
  position: CheckoutBrandingHeaderPosition
  logo: CheckoutBrandingLogoInput
  banner: CheckoutBrandingImageInput
  divided: Boolean
  cartLink: CheckoutBrandingHeaderCartLinkInput
  colorScheme: CheckoutBrandingColorSchemeSelection
  padding: CheckoutBrandingSpacingKeyword
}
enum CheckoutBrandingHeaderPosition {
  INLINE
  INLINE_SECONDARY
  START
}
type CheckoutBrandingHeadingLevel {
  typography: CheckoutBrandingTypographyStyle
}
input CheckoutBrandingHeadingLevelInput {
  typography: CheckoutBrandingTypographyStyleInput
}
type CheckoutBrandingImage {
  image: Image
}
input CheckoutBrandingImageInput {
  mediaImageId: ID
}
input CheckoutBrandingInput {
  designSystem: CheckoutBrandingDesignSystemInput
  customizations: CheckoutBrandingCustomizationsInput
}
enum CheckoutBrandingLabelPosition {
  INSIDE
  OUTSIDE
}
type CheckoutBrandingLogo {
  image: Image
  maxWidth: Int
  visibility: CheckoutBrandingVisibility
}
input CheckoutBrandingLogoInput {
  image: CheckoutBrandingImageInput
  maxWidth: Int
  visibility: CheckoutBrandingVisibility
}
type CheckoutBrandingMain {
  backgroundImage: CheckoutBrandingImage
  colorScheme: CheckoutBrandingColorSchemeSelection
  divider: CheckoutBrandingContainerDivider
  section: CheckoutBrandingMainSection
}
input CheckoutBrandingMainInput {
  colorScheme: CheckoutBrandingColorSchemeSelection
  backgroundImage: CheckoutBrandingImageInput
  divider: CheckoutBrandingContainerDividerInput
  section: CheckoutBrandingMainSectionInput
}
type CheckoutBrandingMainSection {
  background: CheckoutBrandingBackground
  border: CheckoutBrandingSimpleBorder
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
  colorScheme: CheckoutBrandingColorSchemeSelection
  cornerRadius: CheckoutBrandingCornerRadius
  padding: CheckoutBrandingSpacingKeyword
  shadow: CheckoutBrandingShadow
}
input CheckoutBrandingMainSectionInput {
  colorScheme: CheckoutBrandingColorSchemeSelection
  background: CheckoutBrandingBackground
  cornerRadius: CheckoutBrandingCornerRadius
  border: CheckoutBrandingSimpleBorder
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
  shadow: CheckoutBrandingShadow
  padding: CheckoutBrandingSpacingKeyword
}
type CheckoutBrandingMerchandiseThumbnail {
  badge: CheckoutBrandingMerchandiseThumbnailBadge
  border: CheckoutBrandingSimpleBorder
  cornerRadius: CheckoutBrandingCornerRadius
  fit: CheckoutBrandingObjectFit
}
type CheckoutBrandingMerchandiseThumbnailBadge {
  background: CheckoutBrandingMerchandiseThumbnailBadgeBackground
}
enum CheckoutBrandingMerchandiseThumbnailBadgeBackground {
  ACCENT
  BASE
}
input CheckoutBrandingMerchandiseThumbnailBadgeInput {
  background: CheckoutBrandingMerchandiseThumbnailBadgeBackground
}
input CheckoutBrandingMerchandiseThumbnailInput {
  border: CheckoutBrandingSimpleBorder
  cornerRadius: CheckoutBrandingCornerRadius
  fit: CheckoutBrandingObjectFit
  badge: CheckoutBrandingMerchandiseThumbnailBadgeInput
}
enum CheckoutBrandingObjectFit {
  CONTAIN
  COVER
}
type CheckoutBrandingOrderSummary {
  backgroundImage: CheckoutBrandingImage
  colorScheme: CheckoutBrandingColorSchemeSelection
  divider: CheckoutBrandingContainerDivider
  section: CheckoutBrandingOrderSummarySection
}
input CheckoutBrandingOrderSummaryInput {
  colorScheme: CheckoutBrandingColorSchemeSelection
  backgroundImage: CheckoutBrandingImageInput
  divider: CheckoutBrandingContainerDividerInput
  section: CheckoutBrandingOrderSummarySectionInput
}
type CheckoutBrandingOrderSummarySection {
  background: CheckoutBrandingBackground
  border: CheckoutBrandingSimpleBorder
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
  colorScheme: CheckoutBrandingColorSchemeSelection
  cornerRadius: CheckoutBrandingCornerRadius
  padding: CheckoutBrandingSpacingKeyword
  shadow: CheckoutBrandingShadow
}
input CheckoutBrandingOrderSummarySectionInput {
  colorScheme: CheckoutBrandingColorSchemeSelection
  background: CheckoutBrandingBackground
  cornerRadius: CheckoutBrandingCornerRadius
  border: CheckoutBrandingSimpleBorder
  borderStyle: CheckoutBrandingBorderStyle
  borderWidth: CheckoutBrandingBorderWidth
  shadow: CheckoutBrandingShadow
  padding: CheckoutBrandingSpacingKeyword
}
type CheckoutBrandingSelect {
  border: CheckoutBrandingBorder
  typography: CheckoutBrandingTypographyStyle
}
input CheckoutBrandingSelectInput {
  border: CheckoutBrandingBorder
  typography: CheckoutBrandingTypographyStyleInput
}
enum CheckoutBrandingShadow {
  SMALL_200
  SMALL_100
  BASE
  LARGE_100
  LARGE_200
}
type CheckoutBrandingShopifyFont {
  sources: String
  weight: Int
}
input CheckoutBrandingShopifyFontGroupInput {
  name: String!
  baseWeight: Int
  boldWeight: Int
  loadingStrategy: CheckoutBrandingFontLoadingStrategy
}
enum CheckoutBrandingSimpleBorder {
  NONE
  FULL
}
enum CheckoutBrandingSpacing {
  NONE
  EXTRA_TIGHT
  TIGHT
  BASE
  LOOSE
  EXTRA_LOOSE
}
enum CheckoutBrandingSpacingKeyword {
  NONE
  BASE
  SMALL
  SMALL_100
  SMALL_200
  SMALL_300
  SMALL_400
  SMALL_500
  LARGE
  LARGE_100
  LARGE_200
  LARGE_300
  LARGE_400
  LARGE_500
}
type CheckoutBrandingTextField {
  border: CheckoutBrandingBorder
  typography: CheckoutBrandingTypographyStyle
}
input CheckoutBrandingTextFieldInput {
  border: CheckoutBrandingBorder
  typography: CheckoutBrandingTypographyStyleInput
}
type CheckoutBrandingTypography {
  primary: CheckoutBrandingFontGroup
  secondary: CheckoutBrandingFontGroup
  size: CheckoutBrandingFontSize
}
enum CheckoutBrandingTypographyFont {
  PRIMARY
  SECONDARY
}
input CheckoutBrandingTypographyInput {
  size: CheckoutBrandingFontSizeInput
  primary: CheckoutBrandingFontGroupInput
  secondary: CheckoutBrandingFontGroupInput
}
enum CheckoutBrandingTypographyKerning {
  BASE
  LOOSE
  EXTRA_LOOSE
}
enum CheckoutBrandingTypographyLetterCase {
  LOWER
  NONE
  TITLE
  UPPER
}
enum CheckoutBrandingTypographySize {
  EXTRA_SMALL
  SMALL
  BASE
  MEDIUM
  LARGE
  EXTRA_LARGE
  EXTRA_EXTRA_LARGE
}
type CheckoutBrandingTypographyStyle {
  font: CheckoutBrandingTypographyFont
  kerning: CheckoutBrandingTypographyKerning
  letterCase: CheckoutBrandingTypographyLetterCase
  size: CheckoutBrandingTypographySize
  weight: CheckoutBrandingTypographyWeight
}
type CheckoutBrandingTypographyStyleGlobal {
  kerning: CheckoutBrandingTypographyKerning
  letterCase: CheckoutBrandingTypographyLetterCase
}
input CheckoutBrandingTypographyStyleGlobalInput {
  letterCase: CheckoutBrandingTypographyLetterCase
  kerning: CheckoutBrandingTypographyKerning
}
input CheckoutBrandingTypographyStyleInput {
  font: CheckoutBrandingTypographyFont
  size: CheckoutBrandingTypographySize
  weight: CheckoutBrandingTypographyWeight
  letterCase: CheckoutBrandingTypographyLetterCase
  kerning: CheckoutBrandingTypographyKerning
}
enum CheckoutBrandingTypographyWeight {
  BASE
  BOLD
}
type CheckoutBrandingUpsertPayload {
  checkoutBranding: CheckoutBranding
  userErrors: [CheckoutBrandingUpsertUserError!]!
}
type CheckoutBrandingUpsertUserError {
  code: CheckoutBrandingUpsertUserErrorCode
  field: [String!]
  message: String!
}
enum CheckoutBrandingUpsertUserErrorCode {
  INTERNAL_ERROR
}
enum CheckoutBrandingVisibility {
  HIDDEN
  VISIBLE
}
type CheckoutProfile {
  createdAt: DateTime!
  editedAt: DateTime!
  id: ID!
  isPublished: Boolean!
  name: String!
  typOspPagesActive: Boolean!
  updatedAt: DateTime!
}
type CheckoutProfileConnection {
  edges: [CheckoutProfileEdge!]!
  nodes: [CheckoutProfile!]!
  pageInfo: PageInfo!
}
type CheckoutProfileEdge {
  cursor: String!
  node: CheckoutProfile!
}
enum CheckoutProfileSortKeys {
  CREATED_AT
  EDITED_AT
  ID
  IS_PUBLISHED
  RELEVANCE
  UPDATED_AT
}
input ChildProductRelationInput {
  childProductId: ID!
  selectedParentOptionValues: [SelectedVariantOptionInput!]!
}
enum CodeDiscountSortKeys {
  CREATED_AT
  ENDS_AT
  ID
  RELEVANCE
  STARTS_AT
  TITLE
  UPDATED_AT
}
type Collection {
  availablePublicationsCount: Count
  description: String!
  descriptionHtml: HTML!
  events: EventConnection!
  feedback: ResourceFeedback
  handle: String!
  hasProduct: Boolean!
  id: ID!
  image: Image
  legacyResourceId: UnsignedInt64!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  products: ProductConnection!
  productsCount: Count
  publicationCount: Int!
  publications: CollectionPublicationConnection!
  publishedOnChannel: Boolean!
  publishedOnCurrentChannel: Boolean!
  publishedOnCurrentPublication: Boolean!
  publishedOnPublication: Boolean!
  resourcePublications: ResourcePublicationConnection!
  resourcePublicationsCount: Count
  resourcePublicationsV2: ResourcePublicationV2Connection!
  ruleSet: CollectionRuleSet
  seo: SEO!
  sortOrder: CollectionSortOrder!
  storefrontId: StorefrontID!
  templateSuffix: String
  title: String!
  translations: [Translation!]!
  unpublishedChannels: ChannelConnection!
  unpublishedPublications: PublicationConnection!
  updatedAt: DateTime!
}
type CollectionAddProductsPayload {
  collection: Collection
  userErrors: [UserError!]!
}
type CollectionAddProductsV2Payload {
  job: Job
  userErrors: [CollectionAddProductsV2UserError!]!
}
type CollectionAddProductsV2UserError {
  code: CollectionAddProductsV2UserErrorCode
  field: [String!]
  message: String!
}
enum CollectionAddProductsV2UserErrorCode {
  CANT_ADD_TO_SMART_COLLECTION
  COLLECTION_DOES_NOT_EXIST
}
type CollectionConnection {
  edges: [CollectionEdge!]!
  nodes: [Collection!]!
  pageInfo: PageInfo!
}
type CollectionCreatePayload {
  collection: Collection
  userErrors: [UserError!]!
}
input CollectionDeleteInput {
  id: ID!
}
type CollectionDeletePayload {
  deletedCollectionId: ID
  shop: Shop!
  userErrors: [UserError!]!
}
type CollectionEdge {
  cursor: String!
  node: Collection!
}
input CollectionInput {
  descriptionHtml: String
  handle: String
  id: ID
  image: ImageInput
  products: [ID!]
  ruleSet: CollectionRuleSetInput
  templateSuffix: String
  sortOrder: CollectionSortOrder
  title: String
  metafields: [MetafieldInput!]
  seo: SEOInput
  redirectNewHandle: Boolean
}
type CollectionPublication {
  channel: Channel!
  collection: Collection!
  isPublished: Boolean!
  publication: Publication!
  publishDate: DateTime!
}
type CollectionPublicationConnection {
  edges: [CollectionPublicationEdge!]!
  nodes: [CollectionPublication!]!
  pageInfo: PageInfo!
}
type CollectionPublicationEdge {
  cursor: String!
  node: CollectionPublication!
}
input CollectionPublicationInput {
  publicationId: ID
}
input CollectionPublishInput {
  id: ID!
  collectionPublications: [CollectionPublicationInput!]!
}
type CollectionPublishPayload {
  collection: Collection
  collectionPublications: [CollectionPublication!]
  shop: Shop!
  userErrors: [UserError!]!
}
type CollectionRemoveProductsPayload {
  job: Job
  userErrors: [UserError!]!
}
type CollectionReorderProductsPayload {
  job: Job
  userErrors: [UserError!]!
}
type CollectionRule {
  column: CollectionRuleColumn!
  condition: String!
  conditionObject: CollectionRuleConditionObject
  relation: CollectionRuleRelation!
}
type CollectionRuleCategoryCondition {
  value: TaxonomyCategory!
}
enum CollectionRuleColumn {
  TAG
  TITLE
  TYPE
  PRODUCT_TAXONOMY_NODE_ID
  PRODUCT_CATEGORY_ID
  VENDOR
  VARIANT_PRICE
  IS_PRICE_REDUCED
  VARIANT_COMPARE_AT_PRICE
  VARIANT_WEIGHT
  VARIANT_INVENTORY
  VARIANT_TITLE
  PRODUCT_METAFIELD_DEFINITION
  VARIANT_METAFIELD_DEFINITION
}
union CollectionRuleConditionObject = CollectionRuleCategoryCondition | CollectionRuleMetafieldCondition | CollectionRuleProductCategoryCondition | CollectionRuleTextCondition
type CollectionRuleConditions {
  allowedRelations: [CollectionRuleRelation!]!
  defaultRelation: CollectionRuleRelation!
  ruleObject: CollectionRuleConditionsRuleObject
  ruleType: CollectionRuleColumn!
}
union CollectionRuleConditionsRuleObject = CollectionRuleMetafieldCondition
input CollectionRuleInput {
  column: CollectionRuleColumn!
  relation: CollectionRuleRelation!
  condition: String!
  conditionObjectId: ID
}
type CollectionRuleMetafieldCondition {
  metafieldDefinition: MetafieldDefinition!
}
type CollectionRuleProductCategoryCondition {
  value: ProductTaxonomyNode!
}
enum CollectionRuleRelation {
  CONTAINS
  ENDS_WITH
  EQUALS
  GREATER_THAN
  IS_NOT_SET
  IS_SET
  LESS_THAN
  NOT_CONTAINS
  NOT_EQUALS
  STARTS_WITH
}
type CollectionRuleSet {
  appliedDisjunctively: Boolean!
  rules: [CollectionRule!]!
}
input CollectionRuleSetInput {
  appliedDisjunctively: Boolean!
  rules: [CollectionRuleInput!]
}
type CollectionRuleTextCondition {
  value: String!
}
enum CollectionSortKeys {
  ID
  RELEVANCE
  TITLE
  UPDATED_AT
}
enum CollectionSortOrder {
  ALPHA_ASC
  ALPHA_DESC
  BEST_SELLING
  CREATED
  CREATED_DESC
  MANUAL
  PRICE_ASC
  PRICE_DESC
}
input CollectionUnpublishInput {
  id: ID!
  collectionPublications: [CollectionPublicationInput!]!
}
type CollectionUnpublishPayload {
  collection: Collection
  shop: Shop!
  userErrors: [UserError!]!
}
type CollectionUpdatePayload {
  collection: Collection
  job: Job
  userErrors: [UserError!]!
}
scalar Color
type CombinedListing {
  combinedListingChildren: CombinedListingChildConnection!
  parentProduct: Product!
}
type CombinedListingChild {
  parentVariant: ProductVariant!
  product: Product!
}
type CombinedListingChildConnection {
  edges: [CombinedListingChildEdge!]!
  nodes: [CombinedListingChild!]!
  pageInfo: PageInfo!
}
type CombinedListingChildEdge {
  cursor: String!
  node: CombinedListingChild!
}
type CombinedListingUpdatePayload {
  product: Product
  userErrors: [CombinedListingUpdateUserError!]!
}
type CombinedListingUpdateUserError {
  code: CombinedListingUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum CombinedListingUpdateUserErrorCode {
  CANNOT_HAVE_DUPLICATED_PRODUCTS
  CANNOT_HAVE_PARENT_AS_CHILD
  CANNOT_HAVE_REPEATED_OPTION_VALUES
  CANNOT_HAVE_REPEATED_OPTIONS
  CANT_ADD_OPTIONS_VALUES_IF_ALREADY_EXISTS
  COMBINED_LISTINGS_NOT_ENABLED
  EDIT_AND_REMOVE_ON_SAME_PRODUCTS
  FAILED_TO_ADD_PRODUCTS
  FAILED_TO_REMOVE_PRODUCTS
  FAILED_TO_UPDATE_PRODUCTS
  LINKED_METAFIELD_CANNOT_BE_CHANGED
  LINKED_METAFIELD_VALUE_MISSING
  LINKED_METAFIELDS_CANNOT_BE_REPEATED
  LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP
  MISSING_OPTION_VALUES
  MUST_HAVE_SELECTED_OPTION_VALUES
  OPTION_NAME_CANNOT_BE_BLANK
  OPTION_NOT_FOUND
  OPTIONS_MUST_BE_EQUAL_TO_THE_OTHER_COMPONENTS
  OPTION_VALUES_CANNOT_BE_BLANK
  OPTION_VALUES_CANNOT_BE_EMPTY
  PARENT_PRODUCT_MUST_BE_A_COMBINED_LISTING
  PRODUCT_IS_ALREADY_A_CHILD
  PRODUCT_MEMBERSHIP_NOT_FOUND
  PRODUCT_NOT_FOUND
  TITLE_TOO_LONG
  TOO_MANY_VARIANTS
  TOO_MANY_PRODUCTS
  UNEXPECTED_ERROR
}
enum CombinedListingsRole {
  PARENT
  CHILD
}
type Comment {
  article: Article
  author: CommentAuthor!
  body: String!
  bodyHtml: HTML!
  createdAt: DateTime!
  events: EventConnection!
  id: ID!
  ip: String
  isPublished: Boolean!
  publishedAt: DateTime
  status: CommentStatus!
  updatedAt: DateTime
  userAgent: String
}
type CommentApprovePayload {
  comment: Comment
  userErrors: [CommentApproveUserError!]!
}
type CommentApproveUserError {
  code: CommentApproveUserErrorCode
  field: [String!]
  message: String!
}
enum CommentApproveUserErrorCode {
  NOT_FOUND
}
type CommentAuthor {
  email: String!
  name: String!
}
type CommentConnection {
  edges: [CommentEdge!]!
  nodes: [Comment!]!
  pageInfo: PageInfo!
}
type CommentDeletePayload {
  deletedCommentId: ID
  userErrors: [CommentDeleteUserError!]!
}
type CommentDeleteUserError {
  code: CommentDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum CommentDeleteUserErrorCode {
  NOT_FOUND
}
type CommentEdge {
  cursor: String!
  node: Comment!
}
type CommentEvent {
  action: String!
  appTitle: String
  attachments: [CommentEventAttachment!]!
  attributeToApp: Boolean!
  attributeToUser: Boolean!
  author: StaffMember!
  canDelete: Boolean!
  canEdit: Boolean!
  createdAt: DateTime!
  criticalAlert: Boolean!
  edited: Boolean!
  embed: CommentEventEmbed
  id: ID!
  message: FormattedString!
  rawMessage: String!
  subject: CommentEventSubject
}
type CommentEventAttachment {
  fileExtension: String
  id: ID!
  image: Image
  name: String!
  size: Int!
  url: URL!
}
union CommentEventEmbed = Customer | DraftOrder | Order | Product | ProductVariant
interface CommentEventSubject {
  hasTimelineComment: Boolean!
  id: ID!
}
type CommentNotSpamPayload {
  comment: Comment
  userErrors: [CommentNotSpamUserError!]!
}
type CommentNotSpamUserError {
  code: CommentNotSpamUserErrorCode
  field: [String!]
  message: String!
}
enum CommentNotSpamUserErrorCode {
  NOT_FOUND
}
enum CommentPolicy {
  AUTO_PUBLISHED
  CLOSED
  MODERATED
}
enum CommentSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
type CommentSpamPayload {
  comment: Comment
  userErrors: [CommentSpamUserError!]!
}
type CommentSpamUserError {
  code: CommentSpamUserErrorCode
  field: [String!]
  message: String!
}
enum CommentSpamUserErrorCode {
  NOT_FOUND
}
enum CommentStatus {
  SPAM
  REMOVED
  PUBLISHED
  UNAPPROVED
  PENDING
}
type CompaniesDeletePayload {
  deletedCompanyIds: [ID!]
  userErrors: [BusinessCustomerUserError!]!
}
type Company {
  contactCount: Int!
  contactRoles: CompanyContactRoleConnection!
  contacts: CompanyContactConnection!
  contactsCount: Count
  createdAt: DateTime!
  customerSince: DateTime!
  defaultCursor: String!
  defaultRole: CompanyContactRole
  draftOrders: DraftOrderConnection!
  events: EventConnection!
  externalId: String
  hasTimelineComment: Boolean!
  id: ID!
  lifetimeDuration: String!
  locations: CompanyLocationConnection!
  locationsCount: Count
  mainContact: CompanyContact
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  name: String!
  note: String
  orders: OrderConnection!
  ordersCount: Count
  totalSpent: MoneyV2!
  updatedAt: DateTime!
}
type CompanyAddress {
  address1: String!
  address2: String
  city: String
  companyName: String!
  country: String
  countryCode: CountryCode!
  createdAt: DateTime!
  firstName: String
  formattedAddress: [String!]!
  formattedArea: String
  id: ID!
  lastName: String
  phone: String
  province: String
  recipient: String
  updatedAt: DateTime!
  zip: String
  zoneCode: String
}
type CompanyAddressDeletePayload {
  deletedAddressId: ID
  userErrors: [BusinessCustomerUserError!]!
}
input CompanyAddressInput {
  address1: String
  address2: String
  city: String
  zip: String
  recipient: String
  firstName: String
  lastName: String
  phone: String
  zoneCode: String
  countryCode: CountryCode
}
enum CompanyAddressType {
  BILLING
  SHIPPING
}
type CompanyAssignCustomerAsContactPayload {
  companyContact: CompanyContact
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyAssignMainContactPayload {
  company: Company
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyConnection {
  edges: [CompanyEdge!]!
  nodes: [Company!]!
  pageInfo: PageInfo!
}
type CompanyContact {
  company: Company!
  createdAt: DateTime!
  customer: Customer!
  draftOrders: DraftOrderConnection!
  id: ID!
  isMainContact: Boolean!
  lifetimeDuration: String!
  locale: String
  orders: OrderConnection!
  roleAssignments: CompanyContactRoleAssignmentConnection!
  title: String
  updatedAt: DateTime!
}
type CompanyContactAssignRolePayload {
  companyContactRoleAssignment: CompanyContactRoleAssignment
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactAssignRolesPayload {
  roleAssignments: [CompanyContactRoleAssignment!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactConnection {
  edges: [CompanyContactEdge!]!
  nodes: [CompanyContact!]!
  pageInfo: PageInfo!
}
type CompanyContactCreatePayload {
  companyContact: CompanyContact
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactDeletePayload {
  deletedCompanyContactId: ID
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactEdge {
  cursor: String!
  node: CompanyContact!
}
input CompanyContactInput {
  firstName: String
  lastName: String
  email: String
  title: String
  locale: String
  phone: String
}
type CompanyContactRemoveFromCompanyPayload {
  removedCompanyContactId: ID
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactRevokeRolePayload {
  revokedCompanyContactRoleAssignmentId: ID
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactRevokeRolesPayload {
  revokedRoleAssignmentIds: [ID!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactRole {
  id: ID!
  name: String!
  note: String
}
input CompanyContactRoleAssign {
  companyContactRoleId: ID!
  companyLocationId: ID!
}
type CompanyContactRoleAssignment {
  company: Company!
  companyContact: CompanyContact!
  companyLocation: CompanyLocation!
  createdAt: DateTime!
  id: ID!
  role: CompanyContactRole!
  updatedAt: DateTime!
}
type CompanyContactRoleAssignmentConnection {
  edges: [CompanyContactRoleAssignmentEdge!]!
  nodes: [CompanyContactRoleAssignment!]!
  pageInfo: PageInfo!
}
type CompanyContactRoleAssignmentEdge {
  cursor: String!
  node: CompanyContactRoleAssignment!
}
enum CompanyContactRoleAssignmentSortKeys {
  CREATED_AT
  ID
  LOCATION_NAME
  RELEVANCE
  UPDATED_AT
}
type CompanyContactRoleConnection {
  edges: [CompanyContactRoleEdge!]!
  nodes: [CompanyContactRole!]!
  pageInfo: PageInfo!
}
type CompanyContactRoleEdge {
  cursor: String!
  node: CompanyContactRole!
}
enum CompanyContactRoleSortKeys {
  CREATED_AT
  ID
  RELEVANCE
  UPDATED_AT
}
type CompanyContactSendWelcomeEmailPayload {
  companyContact: CompanyContact
  userErrors: [BusinessCustomerUserError!]!
}
enum CompanyContactSortKeys {
  COMPANY_ID
  CREATED_AT
  EMAIL
  ID
  NAME
  NAME_EMAIL
  RELEVANCE
  TITLE
  UPDATED_AT
}
type CompanyContactUpdatePayload {
  companyContact: CompanyContact
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyContactsDeletePayload {
  deletedCompanyContactIds: [ID!]
  userErrors: [BusinessCustomerUserError!]!
}
input CompanyCreateInput {
  company: CompanyInput!
  companyContact: CompanyContactInput
  companyLocation: CompanyLocationInput
}
type CompanyCreatePayload {
  company: Company
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyDeletePayload {
  deletedCompanyId: ID
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyEdge {
  cursor: String!
  node: Company!
}
input CompanyInput {
  name: String
  note: String
  externalId: String
  customerSince: DateTime
}
type CompanyLocation {
  billingAddress: CompanyAddress
  buyerExperienceConfiguration: BuyerExperienceConfiguration
  catalogs: CatalogConnection!
  catalogsCount: Count
  company: Company!
  createdAt: DateTime!
  currency: CurrencyCode!
  defaultCursor: String!
  draftOrders: DraftOrderConnection!
  events: EventConnection!
  externalId: String
  hasTimelineComment: Boolean!
  id: ID!
  inCatalog: Boolean!
  locale: String
  market: Market!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  name: String!
  note: String
  orderCount: Int!
  orders: OrderConnection!
  ordersCount: Count
  phone: String
  roleAssignments: CompanyContactRoleAssignmentConnection!
  shippingAddress: CompanyAddress
  staffMemberAssignments: CompanyLocationStaffMemberAssignmentConnection!
  taxExemptions: [TaxExemption!]!
  taxRegistrationId: String
  taxSettings: CompanyLocationTaxSettings!
  totalSpent: MoneyV2!
  updatedAt: DateTime!
}
type CompanyLocationAssignAddressPayload {
  addresses: [CompanyAddress!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationAssignRolesPayload {
  roleAssignments: [CompanyContactRoleAssignment!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationAssignStaffMembersPayload {
  companyLocationStaffMemberAssignments: [CompanyLocationStaffMemberAssignment!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationAssignTaxExemptionsPayload {
  companyLocation: CompanyLocation
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationCatalog {
  companyLocations: CompanyLocationConnection!
  companyLocationsCount: Count
  id: ID!
  operations: [ResourceOperation!]!
  priceList: PriceList
  publication: Publication
  status: CatalogStatus!
  title: String!
}
type CompanyLocationConnection {
  edges: [CompanyLocationEdge!]!
  nodes: [CompanyLocation!]!
  pageInfo: PageInfo!
}
type CompanyLocationCreatePayload {
  companyLocation: CompanyLocation
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationCreateTaxRegistrationPayload {
  companyLocation: CompanyLocation
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationDeletePayload {
  deletedCompanyLocationId: ID
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationEdge {
  cursor: String!
  node: CompanyLocation!
}
input CompanyLocationInput {
  name: String
  phone: String
  locale: String
  externalId: String
  note: String
  buyerExperienceConfiguration: BuyerExperienceConfigurationInput
  billingAddress: CompanyAddressInput
  shippingAddress: CompanyAddressInput
  billingSameAsShipping: Boolean
  taxRegistrationId: String
  taxExemptions: [TaxExemption!]
  taxExempt: Boolean
}
type CompanyLocationRemoveStaffMembersPayload {
  deletedCompanyLocationStaffMemberAssignmentIds: [ID!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationRevokeRolesPayload {
  revokedRoleAssignmentIds: [ID!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationRevokeTaxExemptionsPayload {
  companyLocation: CompanyLocation
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationRevokeTaxRegistrationPayload {
  companyLocation: CompanyLocation
  userErrors: [BusinessCustomerUserError!]!
}
input CompanyLocationRoleAssign {
  companyContactRoleId: ID!
  companyContactId: ID!
}
enum CompanyLocationSortKeys {
  COMPANY_AND_LOCATION_NAME
  COMPANY_ID
  CREATED_AT
  ID
  NAME
  RELEVANCE
  UPDATED_AT
}
type CompanyLocationStaffMemberAssignment {
  companyLocation: CompanyLocation!
  id: ID!
  staffMember: StaffMember!
}
type CompanyLocationStaffMemberAssignmentConnection {
  edges: [CompanyLocationStaffMemberAssignmentEdge!]!
  nodes: [CompanyLocationStaffMemberAssignment!]!
  pageInfo: PageInfo!
}
type CompanyLocationStaffMemberAssignmentEdge {
  cursor: String!
  node: CompanyLocationStaffMemberAssignment!
}
enum CompanyLocationStaffMemberAssignmentSortKeys {
  CREATED_AT
  ID
  RELEVANCE
  UPDATED_AT
}
type CompanyLocationTaxSettings {
  taxExempt: Boolean!
  taxExemptions: [TaxExemption!]!
  taxRegistrationId: String
}
type CompanyLocationTaxSettingsUpdatePayload {
  companyLocation: CompanyLocation
  userErrors: [BusinessCustomerUserError!]!
}
input CompanyLocationUpdateInput {
  name: String
  phone: String
  locale: String
  externalId: String
  note: String
  buyerExperienceConfiguration: BuyerExperienceConfigurationInput
}
type CompanyLocationUpdatePayload {
  companyLocation: CompanyLocation
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyLocationsDeletePayload {
  deletedCompanyLocationIds: [ID!]
  userErrors: [BusinessCustomerUserError!]!
}
type CompanyRevokeMainContactPayload {
  company: Company
  userErrors: [BusinessCustomerUserError!]!
}
enum CompanySortKeys {
  CREATED_AT
  ID
  NAME
  ORDER_COUNT
  RELEVANCE
  SINCE_DATE
  TOTAL_SPENT
  UPDATED_AT
}
type CompanyUpdatePayload {
  company: Company
  userErrors: [BusinessCustomerUserError!]!
}
input ContextualPricingContext {
  country: CountryCode
  companyLocationId: ID
}
input ContextualPublicationContext {
  country: CountryCode
  companyLocationId: ID
}
type Count {
  count: Int!
  precision: CountPrecision!
}
enum CountPrecision {
  EXACT
  AT_LEAST
}
type CountriesInShippingZones {
  countryCodes: [CountryCode!]!
  includeRestOfWorld: Boolean!
}
enum CountryCode {
  AF
  AX
  AL
  DZ
  AD
  AO
  AI
  AG
  AR
  AM
  AW
  AC
  AU
  AT
  AZ
  BS
  BH
  BD
  BB
  BY
  BE
  BZ
  BJ
  BM
  BT
  BO
  BA
  BW
  BV
  BR
  IO
  BN
  BG
  BF
  BI
  KH
  CA
  CV
  BQ
  KY
  CF
  TD
  CL
  CN
  CX
  CC
  CO
  KM
  CG
  CD
  CK
  CR
  HR
  CU
  CW
  CY
  CZ
  CI
  DK
  DJ
  DM
  DO
  EC
  EG
  SV
  GQ
  ER
  EE
  SZ
  ET
  FK
  FO
  FJ
  FI
  FR
  GF
  PF
  TF
  GA
  GM
  GE
  DE
  GH
  GI
  GR
  GL
  GD
  GP
  GT
  GG
  GN
  GW
  GY
  HT
  HM
  VA
  HN
  HK
  HU
  IS
  IN
  ID
  IR
  IQ
  IE
  IM
  IL
  IT
  JM
  JP
  JE
  JO
  KZ
  KE
  KI
  KP
  XK
  KW
  KG
  LA
  LV
  LB
  LS
  LR
  LY
  LI
  LT
  LU
  MO
  MG
  MW
  MY
  MV
  ML
  MT
  MQ
  MR
  MU
  YT
  MX
  MD
  MC
  MN
  ME
  MS
  MA
  MZ
  MM
  NA
  NR
  NP
  NL
  AN
  NC
  NZ
  NI
  NE
  NG
  NU
  NF
  MK
  NO
  OM
  PK
  PS
  PA
  PG
  PY
  PE
  PH
  PN
  PL
  PT
  QA
  CM
  RE
  RO
  RU
  RW
  BL
  SH
  KN
  LC
  MF
  PM
  WS
  SM
  ST
  SA
  SN
  RS
  SC
  SL
  SG
  SX
  SK
  SI
  SB
  SO
  ZA
  GS
  KR
  SS
  ES
  LK
  VC
  SD
  SR
  SJ
  SE
  CH
  SY
  TW
  TJ
  TZ
  TH
  TL
  TG
  TK
  TO
  TT
  TA
  TN
  TR
  TM
  TC
  TV
  UG
  UA
  AE
  GB
  US
  UM
  UY
  UZ
  VU
  VE
  VN
  VG
  WF
  EH
  YE
  ZM
  ZW
  ZZ
}
type CountryHarmonizedSystemCode {
  countryCode: CountryCode!
  harmonizedSystemCode: String!
}
type CountryHarmonizedSystemCodeConnection {
  edges: [CountryHarmonizedSystemCodeEdge!]!
  nodes: [CountryHarmonizedSystemCode!]!
  pageInfo: PageInfo!
}
type CountryHarmonizedSystemCodeEdge {
  cursor: String!
  node: CountryHarmonizedSystemCode!
}
input CountryHarmonizedSystemCodeInput {
  harmonizedSystemCode: String!
  countryCode: CountryCode!
}
input CreateMediaInput {
  originalSource: String!
  alt: String
  mediaContentType: MediaContentType!
}
enum CropRegion {
  CENTER
  TOP
  BOTTOM
  LEFT
  RIGHT
}
enum CurrencyCode {
  USD
  EUR
  GBP
  CAD
  AFN
  ALL
  DZD
  AOA
  ARS
  AMD
  AWG
  AUD
  BBD
  AZN
  BDT
  BSD
  BHD
  BIF
  BYN
  BZD
  BMD
  BTN
  BAM
  BRL
  BOB
  BWP
  BND
  BGN
  MMK
  KHR
  CVE
  KYD
  XAF
  CLP
  CNY
  COP
  KMF
  CDF
  CRC
  HRK
  CZK
  DKK
  DJF
  DOP
  XCD
  EGP
  ERN
  ETB
  FKP
  XPF
  FJD
  GIP
  GMD
  GHS
  GTQ
  GYD
  GEL
  GNF
  HTG
  HNL
  HKD
  HUF
  ISK
  INR
  IDR
  ILS
  IRR
  IQD
  JMD
  JPY
  JEP
  JOD
  KZT
  KES
  KID
  KWD
  KGS
  LAK
  LVL
  LBP
  LSL
  LRD
  LYD
  LTL
  MGA
  MKD
  MOP
  MWK
  MVR
  MRU
  MXN
  MYR
  MUR
  MDL
  MAD
  MNT
  MZN
  NAD
  NPR
  ANG
  NZD
  NIO
  NGN
  NOK
  OMR
  PAB
  PKR
  PGK
  PYG
  PEN
  PHP
  PLN
  QAR
  RON
  RUB
  RWF
  WST
  SHP
  SAR
  RSD
  SCR
  SLL
  SGD
  SDG
  SOS
  SYP
  ZAR
  KRW
  SSP
  SBD
  LKR
  SRD
  SZL
  SEK
  CHF
  TWD
  THB
  TJS
  TZS
  TOP
  TTD
  TND
  TRY
  TMT
  UGX
  UAH
  AED
  UYU
  UZS
  VUV
  VES
  VND
  XOF
  YER
  ZMW
  BYR
  STD
  STN
  VED
  VEF
  XXX
}
type CurrencyFormats {
  moneyFormat: FormattedString!
  moneyInEmailsFormat: String!
  moneyWithCurrencyFormat: FormattedString!
  moneyWithCurrencyInEmailsFormat: String!
}
type CurrencySetting {
  currencyCode: CurrencyCode!
  currencyName: String!
  enabled: Boolean!
  rateUpdatedAt: DateTime
}
type CurrencySettingConnection {
  edges: [CurrencySettingEdge!]!
  nodes: [CurrencySetting!]!
  pageInfo: PageInfo!
}
type CurrencySettingEdge {
  cursor: String!
  node: CurrencySetting!
}
input CustomShippingPackageInput {
  weight: WeightInput
  dimensions: ObjectDimensionsInput
  default: Boolean
  name: String
  type: ShippingPackageType
}
type Customer {
  addresses: [MailingAddress!]!
  addressesV2: MailingAddressConnection!
  amountSpent: MoneyV2!
  canDelete: Boolean!
  companyContactProfiles: [CompanyContact!]!
  createdAt: DateTime!
  dataSaleOptOut: Boolean!
  defaultAddress: MailingAddress
  displayName: String!
  email: String
  emailMarketingConsent: CustomerEmailMarketingConsentState
  events: EventConnection!
  firstName: String
  hasTimelineComment: Boolean!
  id: ID!
  image: Image!
  lastName: String
  lastOrder: Order
  legacyResourceId: UnsignedInt64!
  lifetimeDuration: String!
  locale: String!
  market: Market
  mergeable: CustomerMergeable!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  multipassIdentifier: String
  note: String
  numberOfOrders: UnsignedInt64!
  orders: OrderConnection!
  paymentMethods: CustomerPaymentMethodConnection!
  phone: String
  productSubscriberStatus: CustomerProductSubscriberStatus!
  smsMarketingConsent: CustomerSmsMarketingConsentState
  state: CustomerState!
  statistics: CustomerStatistics!
  storeCreditAccounts: StoreCreditAccountConnection!
  subscriptionContracts: SubscriptionContractConnection!
  tags: [String!]!
  taxExempt: Boolean!
  taxExemptions: [TaxExemption!]!
  unsubscribeUrl: URL!
  updatedAt: DateTime!
  validEmailAddress: Boolean!
  verifiedEmail: Boolean!
}
type CustomerAccountAppExtensionPage {
  appExtensionUuid: String
  defaultCursor: String!
  handle: String!
  id: ID!
  title: String!
}
type CustomerAccountNativePage {
  defaultCursor: String!
  handle: String!
  id: ID!
  pageType: CustomerAccountNativePagePageType!
  title: String!
}
enum CustomerAccountNativePagePageType {
  NATIVE_ORDERS
  NATIVE_SETTINGS
  NATIVE_PROFILE
  UNKNOWN
}
interface CustomerAccountPage {
  defaultCursor: String!
  handle: String!
  id: ID!
  title: String!
}
type CustomerAccountPageConnection {
  edges: [CustomerAccountPageEdge!]!
  nodes: [CustomerAccountPage!]!
  pageInfo: PageInfo!
}
type CustomerAccountPageEdge {
  cursor: String!
  node: CustomerAccountPage!
}
type CustomerAccountsV2 {
  customerAccountsVersion: CustomerAccountsVersion!
  loginLinksVisibleOnStorefrontAndCheckout: Boolean!
  loginRequiredAtCheckout: Boolean!
  url: URL
}
enum CustomerAccountsVersion {
  CLASSIC
  NEW_CUSTOMER_ACCOUNTS
}
type CustomerAddTaxExemptionsPayload {
  customer: Customer
  userErrors: [UserError!]!
}
enum CustomerCancelDataErasureErrorCode {
  DOES_NOT_EXIST
  FAILED_TO_CANCEL
  NOT_BEING_ERASED
}
type CustomerCancelDataErasurePayload {
  customerId: ID
  userErrors: [CustomerCancelDataErasureUserError!]!
}
type CustomerCancelDataErasureUserError {
  code: CustomerCancelDataErasureErrorCode
  field: [String!]
  message: String!
}
type CustomerConnection {
  edges: [CustomerEdge!]!
  nodes: [Customer!]!
  pageInfo: PageInfo!
}
enum CustomerConsentCollectedFrom {
  SHOPIFY
  OTHER
}
type CustomerCreatePayload {
  customer: Customer
  userErrors: [UserError!]!
}
type CustomerCreditCard {
  billingAddress: CustomerCreditCardBillingAddress
  brand: String!
  expiresSoon: Boolean!
  expiryMonth: Int!
  expiryYear: Int!
  firstDigits: String
  isRevocable: Boolean!
  lastDigits: String!
  maskedNumber: String!
  name: String!
  source: String
  virtualLastDigits: String
}
type CustomerCreditCardBillingAddress {
  address1: String
  city: String
  country: String
  countryCode: CountryCode
  firstName: String
  lastName: String
  province: String
  provinceCode: String
  zip: String
}
input CustomerDeleteInput {
  id: ID!
}
type CustomerDeletePayload {
  deletedCustomerId: ID
  shop: Shop!
  userErrors: [UserError!]!
}
type CustomerEdge {
  cursor: String!
  node: Customer!
}
type CustomerEmailAddress {
  emailAddress: String!
  marketingState: CustomerEmailAddressMarketingState!
  marketingUnsubscribeUrl: URL!
  openTrackingLevel: CustomerEmailAddressOpenTrackingLevel!
  openTrackingUrl: URL!
}
enum CustomerEmailAddressMarketingState {
  INVALID
  NOT_SUBSCRIBED
  PENDING
  SUBSCRIBED
  UNSUBSCRIBED
}
enum CustomerEmailAddressOpenTrackingLevel {
  UNKNOWN
  OPTED_IN
  OPTED_OUT
}
input CustomerEmailMarketingConsentInput {
  marketingOptInLevel: CustomerMarketingOptInLevel
  marketingState: CustomerEmailMarketingState!
  consentUpdatedAt: DateTime
}
type CustomerEmailMarketingConsentState {
  consentUpdatedAt: DateTime
  marketingOptInLevel: CustomerMarketingOptInLevel
  marketingState: CustomerEmailMarketingState!
}
input CustomerEmailMarketingConsentUpdateInput {
  customerId: ID!
  emailMarketingConsent: CustomerEmailMarketingConsentInput!
}
type CustomerEmailMarketingConsentUpdatePayload {
  customer: Customer
  userErrors: [CustomerEmailMarketingConsentUpdateUserError!]!
}
type CustomerEmailMarketingConsentUpdateUserError {
  code: CustomerEmailMarketingConsentUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerEmailMarketingConsentUpdateUserErrorCode {
  INVALID
  INCLUSION
  INTERNAL_ERROR
  MISSING_ARGUMENT
}
enum CustomerEmailMarketingState {
  NOT_SUBSCRIBED
  PENDING
  SUBSCRIBED
  UNSUBSCRIBED
  REDACTED
  INVALID
}
type CustomerGenerateAccountActivationUrlPayload {
  accountActivationUrl: URL
  userErrors: [UserError!]!
}
input CustomerIdentifierInput {
  id: ID
  customId: UniqueMetafieldValueInput
  emailAddress: String
  phoneNumber: String
}
input CustomerInput {
  addresses: [MailingAddressInput!]
  email: String
  firstName: String
  id: ID
  lastName: String
  locale: String
  metafields: [MetafieldInput!]
  note: String
  phone: String
  tags: [String!]
  emailMarketingConsent: CustomerEmailMarketingConsentInput
  smsMarketingConsent: CustomerSmsMarketingConsentInput
  taxExempt: Boolean
  taxExemptions: [TaxExemption!]
}
type CustomerJourney {
  customerOrderIndex: Int!
  daysToConversion: Int!
  firstVisit: CustomerVisit!
  lastVisit: CustomerVisit
  moments: [CustomerMoment!]!
}
type CustomerJourneySummary {
  customerOrderIndex: Int
  daysToConversion: Int
  firstVisit: CustomerVisit
  lastVisit: CustomerVisit
  moments: CustomerMomentConnection
  momentsCount: Count
  ready: Boolean!
}
enum CustomerMarketingOptInLevel {
  SINGLE_OPT_IN
  CONFIRMED_OPT_IN
  UNKNOWN
}
type CustomerMergeError {
  errorFields: [CustomerMergeErrorFieldType!]!
  message: String!
}
enum CustomerMergeErrorCode {
  INTERNAL_ERROR
  INVALID_CUSTOMER
  INVALID_CUSTOMER_ID
  CUSTOMER_HAS_GIFT_CARDS
  MISSING_OVERRIDE_ATTRIBUTE
  OVERRIDE_ATTRIBUTE_INVALID
}
enum CustomerMergeErrorFieldType {
  DELETED_AT
  REDACTED_AT
  SUBSCRIPTIONS
  MERGE_IN_PROGRESS
  GIFT_CARDS
  STORE_CREDIT
  COMPANY_CONTACT
  CUSTOMER_PAYMENT_METHODS
  PENDING_DATA_REQUEST
  MULTIPASS_IDENTIFIER
}
input CustomerMergeOverrideFields {
  customerIdOfFirstNameToKeep: ID
  customerIdOfLastNameToKeep: ID
  customerIdOfEmailToKeep: ID
  customerIdOfPhoneNumberToKeep: ID
  customerIdOfDefaultAddressToKeep: ID
  note: String
  tags: [String!]
}
type CustomerMergePayload {
  job: Job
  resultingCustomerId: ID
  userErrors: [CustomerMergeUserError!]!
}
type CustomerMergePreview {
  alternateFields: CustomerMergePreviewAlternateFields
  blockingFields: CustomerMergePreviewBlockingFields
  customerMergeErrors: [CustomerMergeError!]
  defaultFields: CustomerMergePreviewDefaultFields
  resultingCustomerId: ID
}
type CustomerMergePreviewAlternateFields {
  defaultAddress: MailingAddress
  email: CustomerEmailAddress
  firstName: String
  lastName: String
  phoneNumber: CustomerPhoneNumber
}
type CustomerMergePreviewBlockingFields {
  note: String
  tags: [String!]!
}
type CustomerMergePreviewDefaultFields {
  addresses: MailingAddressConnection!
  defaultAddress: MailingAddress
  discountNodeCount: UnsignedInt64!
  discountNodes: DiscountNodeConnection!
  displayName: String!
  draftOrderCount: UnsignedInt64!
  draftOrders: DraftOrderConnection!
  email: CustomerEmailAddress
  firstName: String
  giftCardCount: UnsignedInt64!
  giftCards: GiftCardConnection!
  lastName: String
  metafieldCount: UnsignedInt64!
  note: String
  orderCount: UnsignedInt64!
  orders: OrderConnection!
  phoneNumber: CustomerPhoneNumber
  tags: [String!]!
}
type CustomerMergeRequest {
  customerMergeErrors: [CustomerMergeError!]!
  jobId: ID
  resultingCustomerId: ID!
  status: CustomerMergeRequestStatus!
}
enum CustomerMergeRequestStatus {
  REQUESTED
  IN_PROGRESS
  COMPLETED
  FAILED
}
type CustomerMergeUserError {
  code: CustomerMergeErrorCode
  field: [String!]
  message: String!
}
type CustomerMergeable {
  errorFields: [CustomerMergeErrorFieldType!]!
  isMergeable: Boolean!
  mergeInProgress: CustomerMergeRequest
  reason: String
}
interface CustomerMoment {
  occurredAt: DateTime!
}
type CustomerMomentConnection {
  edges: [CustomerMomentEdge!]!
  nodes: [CustomerMoment!]!
  pageInfo: PageInfo!
}
type CustomerMomentEdge {
  cursor: String!
  node: CustomerMoment!
}
union CustomerPaymentInstrument = CustomerCreditCard | CustomerPaypalBillingAgreement | CustomerShopPayAgreement
type CustomerPaymentInstrumentBillingAddress {
  address1: String
  city: String
  country: String
  countryCode: CountryCode
  name: String
  province: String
  provinceCode: String
  zip: String
}
type CustomerPaymentMethod {
  customer: Customer
  id: ID!
  instrument: CustomerPaymentInstrument
  revokedAt: DateTime
  revokedReason: CustomerPaymentMethodRevocationReason
  subscriptionContracts: SubscriptionContractConnection!
}
type CustomerPaymentMethodConnection {
  edges: [CustomerPaymentMethodEdge!]!
  nodes: [CustomerPaymentMethod!]!
  pageInfo: PageInfo!
}
type CustomerPaymentMethodCreateFromDuplicationDataPayload {
  customerPaymentMethod: CustomerPaymentMethod
  userErrors: [CustomerPaymentMethodCreateFromDuplicationDataUserError!]!
}
type CustomerPaymentMethodCreateFromDuplicationDataUserError {
  code: CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerPaymentMethodCreateFromDuplicationDataUserErrorCode {
  TOO_MANY_REQUESTS
  CUSTOMER_DOES_NOT_EXIST
  INVALID_ENCRYPTED_DUPLICATION_DATA
}
type CustomerPaymentMethodCreditCardCreatePayload {
  customerPaymentMethod: CustomerPaymentMethod
  processing: Boolean
  userErrors: [UserError!]!
}
type CustomerPaymentMethodCreditCardUpdatePayload {
  customerPaymentMethod: CustomerPaymentMethod
  processing: Boolean
  userErrors: [UserError!]!
}
type CustomerPaymentMethodEdge {
  cursor: String!
  node: CustomerPaymentMethod!
}
type CustomerPaymentMethodGetDuplicationDataPayload {
  encryptedDuplicationData: String
  userErrors: [CustomerPaymentMethodGetDuplicationDataUserError!]!
}
type CustomerPaymentMethodGetDuplicationDataUserError {
  code: CustomerPaymentMethodGetDuplicationDataUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerPaymentMethodGetDuplicationDataUserErrorCode {
  PAYMENT_METHOD_DOES_NOT_EXIST
  INVALID_INSTRUMENT
  TOO_MANY_REQUESTS
  CUSTOMER_DOES_NOT_EXIST
  SAME_SHOP
  INVALID_ORGANIZATION_SHOP
}
type CustomerPaymentMethodGetUpdateUrlPayload {
  updatePaymentMethodUrl: URL
  userErrors: [CustomerPaymentMethodGetUpdateUrlUserError!]!
}
type CustomerPaymentMethodGetUpdateUrlUserError {
  code: CustomerPaymentMethodGetUpdateUrlUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerPaymentMethodGetUpdateUrlUserErrorCode {
  PAYMENT_METHOD_DOES_NOT_EXIST
  INVALID_INSTRUMENT
  TOO_MANY_REQUESTS
  CUSTOMER_DOES_NOT_EXIST
}
type CustomerPaymentMethodPaypalBillingAgreementCreatePayload {
  customerPaymentMethod: CustomerPaymentMethod
  userErrors: [CustomerPaymentMethodUserError!]!
}
type CustomerPaymentMethodPaypalBillingAgreementUpdatePayload {
  customerPaymentMethod: CustomerPaymentMethod
  userErrors: [CustomerPaymentMethodUserError!]!
}
type CustomerPaymentMethodRemoteCreatePayload {
  customerPaymentMethod: CustomerPaymentMethod
  userErrors: [CustomerPaymentMethodRemoteUserError!]!
}
input CustomerPaymentMethodRemoteInput {
  stripePaymentMethod: RemoteStripePaymentMethodInput
  authorizeNetCustomerPaymentProfile: RemoteAuthorizeNetCustomerPaymentProfileInput
  braintreePaymentMethod: RemoteBraintreePaymentMethodInput
}
type CustomerPaymentMethodRemoteUserError {
  code: CustomerPaymentMethodRemoteUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerPaymentMethodRemoteUserErrorCode {
  INVALID
  PRESENT
  TAKEN
  EXACTLY_ONE_REMOTE_REFERENCE_REQUIRED
  AUTHORIZE_NET_NOT_ENABLED_FOR_SUBSCRIPTIONS
  BRAINTREE_NOT_ENABLED_FOR_SUBSCRIPTIONS
}
enum CustomerPaymentMethodRevocationReason {
  AUTHORIZE_NET_GATEWAY_NOT_ENABLED
  AUTHORIZE_NET_RETURNED_NO_PAYMENT_METHOD
  FAILED_TO_UPDATE_CREDIT_CARD
  STRIPE_API_AUTHENTICATION_ERROR
  STRIPE_API_INVALID_REQUEST_ERROR
  STRIPE_GATEWAY_NOT_ENABLED
  STRIPE_RETURNED_NO_PAYMENT_METHOD
  STRIPE_PAYMENT_METHOD_NOT_CARD
  BRAINTREE_API_AUTHENTICATION_ERROR
  BRAINTREE_GATEWAY_NOT_ENABLED
  BRAINTREE_RETURNED_NO_PAYMENT_METHOD
  BRAINTREE_PAYMENT_METHOD_NOT_CARD
  PAYMENT_METHOD_VERIFICATION_FAILED
  THREE_D_SECURE_FLOW_IN_VERIFICATION_NOT_IMPLEMENTED
  MANUALLY_REVOKED
  FAILED_TO_RETRIEVE_BILLING_ADDRESS
  MERGED
}
type CustomerPaymentMethodRevokePayload {
  revokedCustomerPaymentMethodId: ID
  userErrors: [UserError!]!
}
type CustomerPaymentMethodSendUpdateEmailPayload {
  customer: Customer
  userErrors: [UserError!]!
}
type CustomerPaymentMethodUserError {
  code: CustomerPaymentMethodUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerPaymentMethodUserErrorCode {
  INVALID
  PRESENT
  TAKEN
}
type CustomerPaypalBillingAgreement {
  billingAddress: CustomerPaymentInstrumentBillingAddress
  inactive: Boolean!
  isRevocable: Boolean!
  paypalAccountEmail: String
}
type CustomerPhoneNumber {
  marketingState: CustomerSmsMarketingState!
  phoneNumber: String!
}
enum CustomerPredictedSpendTier {
  HIGH
  MEDIUM
  LOW
}
enum CustomerProductSubscriberStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  FAILED
  NEVER_SUBSCRIBED
  PAUSED
}
type CustomerRemoveTaxExemptionsPayload {
  customer: Customer
  userErrors: [UserError!]!
}
type CustomerReplaceTaxExemptionsPayload {
  customer: Customer
  userErrors: [UserError!]!
}
enum CustomerRequestDataErasureErrorCode {
  DOES_NOT_EXIST
  FAILED_TO_REQUEST
}
type CustomerRequestDataErasurePayload {
  customerId: ID
  userErrors: [CustomerRequestDataErasureUserError!]!
}
type CustomerRequestDataErasureUserError {
  code: CustomerRequestDataErasureErrorCode
  field: [String!]
  message: String!
}
enum CustomerSavedSearchSortKeys {
  ID
  NAME
  RELEVANCE
}
type CustomerSegmentMember {
  amountSpent: MoneyV2
  defaultAddress: MailingAddress
  defaultEmailAddress: CustomerEmailAddress
  defaultPhoneNumber: CustomerPhoneNumber
  displayName: String!
  firstName: String
  id: ID!
  lastName: String
  lastOrderId: ID
  mergeable: CustomerMergeable!
  metafield: Metafield
  metafields: MetafieldConnection!
  note: String
  numberOfOrders: UnsignedInt64
}
type CustomerSegmentMemberConnection {
  edges: [CustomerSegmentMemberEdge!]!
  pageInfo: PageInfo!
  statistics: SegmentStatistics!
  totalCount: Int!
}
type CustomerSegmentMemberEdge {
  cursor: String!
  node: CustomerSegmentMember!
}
type CustomerSegmentMembersQuery {
  currentCount: Int!
  done: Boolean!
  id: ID!
}
type CustomerSegmentMembersQueryCreatePayload {
  customerSegmentMembersQuery: CustomerSegmentMembersQuery
  userErrors: [CustomerSegmentMembersQueryUserError!]!
}
input CustomerSegmentMembersQueryInput {
  segmentId: ID
  query: String
  reverse: Boolean
  sortKey: String
}
type CustomerSegmentMembersQueryUserError {
  code: CustomerSegmentMembersQueryUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerSegmentMembersQueryUserErrorCode {
  INVALID
}
type CustomerSendAccountInviteEmailPayload {
  customer: Customer
  userErrors: [CustomerSendAccountInviteEmailUserError!]!
}
type CustomerSendAccountInviteEmailUserError {
  code: CustomerSendAccountInviteEmailUserErrorCode
  field: [String!]
  message: String!
}
enum CustomerSendAccountInviteEmailUserErrorCode {
  INVALID
}
type CustomerShopPayAgreement {
  billingAddress: CustomerCreditCardBillingAddress
  expiresSoon: Boolean!
  expiryMonth: Int!
  expiryYear: Int!
  inactive: Boolean!
  isRevocable: Boolean!
  lastDigits: String!
  maskedNumber: String!
  name: String!
}
type CustomerSmsMarketingConsentError {
  code: CustomerSmsMarketingConsentErrorCode
  field: [String!]
  message: String!
}
enum CustomerSmsMarketingConsentErrorCode {
  INVALID
  INCLUSION
  INTERNAL_ERROR
  MISSING_ARGUMENT
}
input CustomerSmsMarketingConsentInput {
  marketingOptInLevel: CustomerMarketingOptInLevel
  marketingState: CustomerSmsMarketingState!
  consentUpdatedAt: DateTime
}
type CustomerSmsMarketingConsentState {
  consentCollectedFrom: CustomerConsentCollectedFrom
  consentUpdatedAt: DateTime
  marketingOptInLevel: CustomerMarketingOptInLevel!
  marketingState: CustomerSmsMarketingState!
}
input CustomerSmsMarketingConsentUpdateInput {
  customerId: ID!
  smsMarketingConsent: CustomerSmsMarketingConsentInput!
}
type CustomerSmsMarketingConsentUpdatePayload {
  customer: Customer
  userErrors: [CustomerSmsMarketingConsentError!]!
}
enum CustomerSmsMarketingState {
  NOT_SUBSCRIBED
  PENDING
  SUBSCRIBED
  UNSUBSCRIBED
  REDACTED
}
enum CustomerSortKeys {
  CREATED_AT
  ID
  LOCATION
  NAME
  RELEVANCE
  UPDATED_AT
}
enum CustomerState {
  DECLINED
  DISABLED
  ENABLED
  INVITED
}
type CustomerStatistics {
  predictedSpendTier: CustomerPredictedSpendTier
}
type CustomerUpdateDefaultAddressPayload {
  customer: Customer
  userErrors: [UserError!]!
}
type CustomerUpdatePayload {
  customer: Customer
  userErrors: [UserError!]!
}
type CustomerVisit {
  id: ID!
  landingPage: URL
  landingPageHtml: HTML
  marketingEvent: MarketingEvent
  occurredAt: DateTime!
  referralCode: String
  referralInfoHtml: FormattedString!
  referrerUrl: URL
  source: String!
  sourceDescription: String
  sourceType: MarketingTactic
  utmParameters: UTMParameters
}
type CustomerVisitProductInfo {
  product: Product
  quantity: Int!
  variant: ProductVariant
}
type CustomerVisitProductInfoConnection {
  edges: [CustomerVisitProductInfoEdge!]!
  nodes: [CustomerVisitProductInfo!]!
  pageInfo: PageInfo!
}
type CustomerVisitProductInfoEdge {
  cursor: String!
  node: CustomerVisitProductInfo!
}
type DataSaleOptOutPayload {
  customerId: ID
  userErrors: [DataSaleOptOutUserError!]!
}
type DataSaleOptOutUserError {
  code: DataSaleOptOutUserErrorCode
  field: [String!]
  message: String!
}
enum DataSaleOptOutUserErrorCode {
  FAILED
}
scalar Date
scalar DateTime
enum DayOfTheWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}
scalar Decimal
type DelegateAccessToken {
  accessScopes: [String!]!
  accessToken: String!
  createdAt: DateTime!
}
type DelegateAccessTokenCreatePayload {
  delegateAccessToken: DelegateAccessToken
  shop: Shop!
  userErrors: [DelegateAccessTokenCreateUserError!]!
}
type DelegateAccessTokenCreateUserError {
  code: DelegateAccessTokenCreateUserErrorCode
  field: [String!]
  message: String!
}
enum DelegateAccessTokenCreateUserErrorCode {
  EMPTY_ACCESS_SCOPE
  DELEGATE_ACCESS_TOKEN
  NEGATIVE_EXPIRES_IN
  EXPIRES_AFTER_PARENT
  REFRESH_TOKEN
  PERSISTENCE_FAILED
  UNKNOWN_SCOPES
}
type DelegateAccessTokenDestroyPayload {
  shop: Shop!
  status: Boolean
  userErrors: [DelegateAccessTokenDestroyUserError!]!
}
type DelegateAccessTokenDestroyUserError {
  code: DelegateAccessTokenDestroyUserErrorCode
  field: [String!]
  message: String!
}
enum DelegateAccessTokenDestroyUserErrorCode {
  PERSISTENCE_FAILED
  ACCESS_TOKEN_NOT_FOUND
  CAN_ONLY_DELETE_DELEGATE_TOKENS
  ACCESS_DENIED
}
input DelegateAccessTokenInput {
  delegateAccessScope: [String!]!
  expiresIn: Int
}
type DeletionEvent {
  occurredAt: DateTime!
  subjectId: ID!
  subjectType: DeletionEventSubjectType!
}
type DeletionEventConnection {
  edges: [DeletionEventEdge!]!
  nodes: [DeletionEvent!]!
  pageInfo: PageInfo!
}
type DeletionEventEdge {
  cursor: String!
  node: DeletionEvent!
}
enum DeletionEventSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
enum DeletionEventSubjectType {
  COLLECTION
  PRODUCT
}
type DeliveryAvailableService {
  countries: DeliveryCountryCodesOrRestOfWorld!
  name: String!
}
type DeliveryBrandedPromise {
  handle: String!
  name: String!
}
type DeliveryCarrierService {
  active: Boolean!
  availableServicesForCountries: [DeliveryAvailableService!]!
  callbackUrl: URL
  formattedName: String
  icon: Image!
  id: ID!
  name: String
  supportsServiceDiscovery: Boolean!
}
type DeliveryCarrierServiceAndLocations {
  carrierService: DeliveryCarrierService!
  locations: [Location!]!
}
type DeliveryCarrierServiceConnection {
  edges: [DeliveryCarrierServiceEdge!]!
  nodes: [DeliveryCarrierService!]!
  pageInfo: PageInfo!
}
input DeliveryCarrierServiceCreateInput {
  name: String!
  callbackUrl: URL!
  supportsServiceDiscovery: Boolean!
  active: Boolean!
}
type DeliveryCarrierServiceEdge {
  cursor: String!
  node: DeliveryCarrierService!
}
input DeliveryCarrierServiceUpdateInput {
  id: ID!
  name: String
  callbackUrl: URL
  supportsServiceDiscovery: Boolean
  active: Boolean
}
type DeliveryCondition {
  conditionCriteria: DeliveryConditionCriteria!
  field: DeliveryConditionField!
  id: ID!
  operator: DeliveryConditionOperator!
}
union DeliveryConditionCriteria = MoneyV2 | Weight
enum DeliveryConditionField {
  TOTAL_WEIGHT
  TOTAL_PRICE
}
enum DeliveryConditionOperator {
  GREATER_THAN_OR_EQUAL_TO
  LESS_THAN_OR_EQUAL_TO
}
type DeliveryCountry {
  code: DeliveryCountryCodeOrRestOfWorld!
  id: ID!
  name: String!
  provinces: [DeliveryProvince!]!
  translatedName: String!
}
type DeliveryCountryAndZone {
  country: DeliveryCountry!
  zone: String!
}
type DeliveryCountryCodeOrRestOfWorld {
  countryCode: CountryCode
  restOfWorld: Boolean!
}
type DeliveryCountryCodesOrRestOfWorld {
  countryCodes: [CountryCode!]!
  restOfWorld: Boolean!
}
input DeliveryCountryInput {
  code: CountryCode
  restOfWorld: Boolean
  provinces: [DeliveryProvinceInput!]
  includeAllProvinces: Boolean
}
type DeliveryCustomization {
  enabled: Boolean!
  errorHistory: FunctionsErrorHistory
  functionId: String!
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  shopifyFunction: ShopifyFunction!
  title: String!
}
type DeliveryCustomizationActivationPayload {
  ids: [String!]
  userErrors: [DeliveryCustomizationError!]!
}
type DeliveryCustomizationConnection {
  edges: [DeliveryCustomizationEdge!]!
  nodes: [DeliveryCustomization!]!
  pageInfo: PageInfo!
}
type DeliveryCustomizationCreatePayload {
  deliveryCustomization: DeliveryCustomization
  userErrors: [DeliveryCustomizationError!]!
}
type DeliveryCustomizationDeletePayload {
  deletedId: ID
  userErrors: [DeliveryCustomizationError!]!
}
type DeliveryCustomizationEdge {
  cursor: String!
  node: DeliveryCustomization!
}
type DeliveryCustomizationError {
  code: DeliveryCustomizationErrorCode
  field: [String!]
  message: String!
}
enum DeliveryCustomizationErrorCode {
  INVALID
  FUNCTION_NOT_FOUND
  DELIVERY_CUSTOMIZATION_NOT_FOUND
  DELIVERY_CUSTOMIZATION_FUNCTION_NOT_ELIGIBLE
  UNAUTHORIZED_APP_SCOPE
  MAXIMUM_ACTIVE_DELIVERY_CUSTOMIZATIONS
  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE
  FUNCTION_DOES_NOT_IMPLEMENT
  FUNCTION_PENDING_DELETION
  FUNCTION_ID_CANNOT_BE_CHANGED
  REQUIRED_INPUT_FIELD
  INVALID_METAFIELDS
}
input DeliveryCustomizationInput {
  functionId: String
  title: String
  enabled: Boolean
  metafields: [MetafieldInput!]
}
type DeliveryCustomizationUpdatePayload {
  deliveryCustomization: DeliveryCustomization
  userErrors: [DeliveryCustomizationError!]!
}
type DeliveryLegacyModeBlocked {
  blocked: Boolean!
  reasons: [DeliveryLegacyModeBlockedReason!]
}
enum DeliveryLegacyModeBlockedReason {
  MULTI_LOCATION_DISABLED
  NO_LOCATIONS_FULFILLING_ONLINE_ORDERS
}
type DeliveryLocalPickupSettings {
  instructions: String!
  pickupTime: DeliveryLocalPickupTime!
}
enum DeliveryLocalPickupTime {
  ONE_HOUR
  TWO_HOURS
  FOUR_HOURS
  TWENTY_FOUR_HOURS
  TWO_TO_FOUR_DAYS
  FIVE_OR_MORE_DAYS
  CUSTOM
}
type DeliveryLocationGroup {
  id: ID!
  locations: LocationConnection!
  locationsCount: Count
}
type DeliveryLocationGroupZone {
  methodDefinitionCounts: DeliveryMethodDefinitionCounts!
  methodDefinitions: DeliveryMethodDefinitionConnection!
  zone: DeliveryZone!
}
type DeliveryLocationGroupZoneConnection {
  edges: [DeliveryLocationGroupZoneEdge!]!
  nodes: [DeliveryLocationGroupZone!]!
  pageInfo: PageInfo!
}
type DeliveryLocationGroupZoneEdge {
  cursor: String!
  node: DeliveryLocationGroupZone!
}
input DeliveryLocationGroupZoneInput {
  id: ID
  name: String
  countries: [DeliveryCountryInput!]
  methodDefinitionsToCreate: [DeliveryMethodDefinitionInput!]
  methodDefinitionsToUpdate: [DeliveryMethodDefinitionInput!]
}
input DeliveryLocationLocalPickupEnableInput {
  locationId: ID!
  pickupTime: DeliveryLocalPickupTime!
  instructions: String
}
type DeliveryLocationLocalPickupSettingsError {
  code: DeliveryLocationLocalPickupSettingsErrorCode
  field: [String!]
  message: String!
}
enum DeliveryLocationLocalPickupSettingsErrorCode {
  ACTIVE_LOCATION_NOT_FOUND
  CUSTOM_PICKUP_TIME_NOT_ALLOWED
  GENERIC_ERROR
}
type DeliveryMethod {
  additionalInformation: DeliveryMethodAdditionalInformation
  brandedPromise: DeliveryBrandedPromise
  id: ID!
  maxDeliveryDateTime: DateTime
  methodType: DeliveryMethodType!
  minDeliveryDateTime: DateTime
  presentedName: String
  serviceCode: String
  sourceReference: String
}
type DeliveryMethodAdditionalInformation {
  instructions: String
  phone: String
}
type DeliveryMethodDefinition {
  active: Boolean!
  description: String
  id: ID!
  methodConditions: [DeliveryCondition!]!
  name: String!
  rateProvider: DeliveryRateProvider!
}
type DeliveryMethodDefinitionConnection {
  edges: [DeliveryMethodDefinitionEdge!]!
  nodes: [DeliveryMethodDefinition!]!
  pageInfo: PageInfo!
}
type DeliveryMethodDefinitionCounts {
  participantDefinitionsCount: Int!
  rateDefinitionsCount: Int!
}
type DeliveryMethodDefinitionEdge {
  cursor: String!
  node: DeliveryMethodDefinition!
}
input DeliveryMethodDefinitionInput {
  id: ID
  name: String
  description: String
  active: Boolean
  rateDefinition: DeliveryRateDefinitionInput
  participant: DeliveryParticipantInput
  weightConditionsToCreate: [DeliveryWeightConditionInput!]
  priceConditionsToCreate: [DeliveryPriceConditionInput!]
  conditionsToUpdate: [DeliveryUpdateConditionInput!]
}
enum DeliveryMethodDefinitionType {
  MERCHANT
  PARTICIPANT
}
enum DeliveryMethodType {
  SHIPPING
  PICK_UP
  NONE
  RETAIL
  LOCAL
  PICKUP_POINT
}
type DeliveryParticipant {
  adaptToNewServicesFlag: Boolean!
  carrierService: DeliveryCarrierService!
  fixedFee: MoneyV2
  id: ID!
  participantServices: [DeliveryParticipantService!]!
  percentageOfRateFee: Float!
}
input DeliveryParticipantInput {
  id: ID
  carrierServiceId: ID
  fixedFee: MoneyInput
  percentageOfRateFee: Float
  participantServices: [DeliveryParticipantServiceInput!]
  adaptToNewServices: Boolean
}
type DeliveryParticipantService {
  active: Boolean!
  name: String!
}
input DeliveryParticipantServiceInput {
  name: String!
  active: Boolean!
}
input DeliveryPriceConditionInput {
  criteria: MoneyInput
  operator: DeliveryConditionOperator
}
type DeliveryProductVariantsCount {
  capped: Boolean!
  count: Int!
}
type DeliveryProfile {
  activeMethodDefinitionsCount: Int!
  default: Boolean!
  id: ID!
  legacyMode: Boolean!
  locationsWithoutRatesCount: Int!
  name: String!
  originLocationCount: Int!
  productVariantsCount: Count
  productVariantsCountV2: DeliveryProductVariantsCount!
  profileItems: DeliveryProfileItemConnection!
  profileLocationGroups: [DeliveryProfileLocationGroup!]!
  sellingPlanGroups: SellingPlanGroupConnection!
  unassignedLocations: [Location!]!
  unassignedLocationsPaginated: LocationConnection!
  zoneCountryCount: Int!
}
type DeliveryProfileConnection {
  edges: [DeliveryProfileEdge!]!
  nodes: [DeliveryProfile!]!
  pageInfo: PageInfo!
}
type DeliveryProfileCreatePayload {
  profile: DeliveryProfile
  userErrors: [UserError!]!
}
type DeliveryProfileEdge {
  cursor: String!
  node: DeliveryProfile!
}
input DeliveryProfileInput {
  name: String
  profileLocationGroups: [DeliveryProfileLocationGroupInput!]
  locationGroupsToCreate: [DeliveryProfileLocationGroupInput!]
  locationGroupsToUpdate: [DeliveryProfileLocationGroupInput!]
  locationGroupsToDelete: [ID!]
  variantsToAssociate: [ID!]
  variantsToDissociate: [ID!]
  zonesToDelete: [ID!]
  methodDefinitionsToDelete: [ID!]
  conditionsToDelete: [ID!]
  sellingPlanGroupsToAssociate: [ID!]
  sellingPlanGroupsToDissociate: [ID!]
}
type DeliveryProfileItem {
  id: ID!
  product: Product!
  variants: ProductVariantConnection!
}
type DeliveryProfileItemConnection {
  edges: [DeliveryProfileItemEdge!]!
  nodes: [DeliveryProfileItem!]!
  pageInfo: PageInfo!
}
type DeliveryProfileItemEdge {
  cursor: String!
  node: DeliveryProfileItem!
}
type DeliveryProfileLocationGroup {
  countriesInAnyZone: [DeliveryCountryAndZone!]!
  locationGroup: DeliveryLocationGroup!
  locationGroupZones: DeliveryLocationGroupZoneConnection!
}
input DeliveryProfileLocationGroupInput {
  id: ID
  locations: [ID!]
  locationsToAdd: [ID!]
  locationsToRemove: [ID!]
  zonesToCreate: [DeliveryLocationGroupZoneInput!]
  zonesToUpdate: [DeliveryLocationGroupZoneInput!]
}
type DeliveryProfileRemovePayload {
  job: Job
  userErrors: [UserError!]!
}
type DeliveryProfileUpdatePayload {
  profile: DeliveryProfile
  userErrors: [UserError!]!
}
type DeliveryPromiseParticipant {
  id: ID!
  owner: DeliveryPromiseParticipantOwner
  ownerType: DeliveryPromiseParticipantOwnerType!
}
type DeliveryPromiseParticipantConnection {
  edges: [DeliveryPromiseParticipantEdge!]!
  nodes: [DeliveryPromiseParticipant!]!
  pageInfo: PageInfo!
}
type DeliveryPromiseParticipantEdge {
  cursor: String!
  node: DeliveryPromiseParticipant!
}
union DeliveryPromiseParticipantOwner = ProductVariant
enum DeliveryPromiseParticipantOwnerType {
  PRODUCTVARIANT
}
type DeliveryPromiseParticipantsUpdatePayload {
  promiseParticipants: [DeliveryPromiseParticipant!]
  userErrors: [UserError!]!
}
type DeliveryPromiseProvider {
  active: Boolean!
  fulfillmentDelay: Int
  id: ID!
  location: Location!
  timeZone: String!
}
type DeliveryPromiseProviderUpsertPayload {
  deliveryPromiseProvider: DeliveryPromiseProvider
  userErrors: [DeliveryPromiseProviderUpsertUserError!]!
}
type DeliveryPromiseProviderUpsertUserError {
  code: DeliveryPromiseProviderUpsertUserErrorCode
  field: [String!]
  message: String!
}
enum DeliveryPromiseProviderUpsertUserErrorCode {
  NOT_FOUND
  TOO_LONG
  MUST_BELONG_TO_APP
  INVALID_TIME_ZONE
}
type DeliveryPromiseSetting {
  deliveryDatesEnabled: Boolean!
  processingTime: String
}
type DeliveryProvince {
  code: String!
  id: ID!
  name: String!
  translatedName: String!
}
input DeliveryProvinceInput {
  code: String!
}
type DeliveryRateDefinition {
  id: ID!
  price: MoneyV2!
}
input DeliveryRateDefinitionInput {
  id: ID
  price: MoneyInput!
}
union DeliveryRateProvider = DeliveryParticipant | DeliveryRateDefinition
type DeliverySetting {
  legacyModeBlocked: DeliveryLegacyModeBlocked!
  legacyModeProfiles: Boolean!
}
input DeliverySettingInput {
  legacyModeProfiles: Boolean
}
type DeliverySettingUpdatePayload {
  setting: DeliverySetting
  userErrors: [UserError!]!
}
type DeliveryShippingOriginAssignPayload {
  userErrors: [UserError!]!
}
input DeliveryUpdateConditionInput {
  id: ID!
  criteria: Float
  criteriaUnit: String
  field: DeliveryConditionField
  operator: DeliveryConditionOperator
}
input DeliveryWeightConditionInput {
  criteria: WeightInput
  operator: DeliveryConditionOperator
}
type DeliveryZone {
  countries: [DeliveryCountry!]!
  id: ID!
  name: String!
}
union DepositConfiguration = DepositPercentage
input DepositInput {
  percentage: Float!
}
type DepositPercentage {
  percentage: Float!
}
enum DigitalWallet {
  APPLE_PAY
  ANDROID_PAY
  GOOGLE_PAY
  SHOPIFY_PAY
}
union Discount = DiscountAutomaticApp | DiscountAutomaticBasic | DiscountAutomaticBxgy | DiscountAutomaticFreeShipping | DiscountCodeApp | DiscountCodeBasic | DiscountCodeBxgy | DiscountCodeFreeShipping
type DiscountAllocation {
  allocatedAmount: MoneyV2!
  allocatedAmountSet: MoneyBag!
  discountApplication: DiscountApplication!
}
type DiscountAllocationConnection {
  edges: [DiscountAllocationEdge!]!
  nodes: [DiscountAllocation!]!
  pageInfo: PageInfo!
}
type DiscountAllocationEdge {
  cursor: String!
  node: DiscountAllocation!
}
type DiscountAmount {
  amount: MoneyV2!
  appliesOnEachItem: Boolean!
}
input DiscountAmountInput {
  amount: Decimal
  appliesOnEachItem: Boolean
}
interface DiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  index: Int!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  value: PricingValue!
}
enum DiscountApplicationAllocationMethod {
  ACROSS
  EACH
  ONE
}
type DiscountApplicationConnection {
  edges: [DiscountApplicationEdge!]!
  nodes: [DiscountApplication!]!
  pageInfo: PageInfo!
}
type DiscountApplicationEdge {
  cursor: String!
  node: DiscountApplication!
}
enum DiscountApplicationLevel {
  ORDER
  LINE
}
enum DiscountApplicationTargetSelection {
  ALL
  ENTITLED
  EXPLICIT
}
enum DiscountApplicationTargetType {
  LINE_ITEM
  SHIPPING_LINE
}
union DiscountAutomatic = DiscountAutomaticApp | DiscountAutomaticBasic | DiscountAutomaticBxgy | DiscountAutomaticFreeShipping
type DiscountAutomaticActivatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticApp {
  appDiscountType: AppDiscountType!
  appliesOnOneTimePurchase: Boolean!
  appliesOnSubscription: Boolean!
  asyncUsageCount: Int!
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  discountClass: DiscountClass!
  discountId: ID!
  endsAt: DateTime
  errorHistory: FunctionsErrorHistory
  recurringCycleLimit: Int!
  startsAt: DateTime!
  status: DiscountStatus!
  title: String!
  updatedAt: DateTime!
}
type DiscountAutomaticAppCreatePayload {
  automaticAppDiscount: DiscountAutomaticApp
  userErrors: [DiscountUserError!]!
}
input DiscountAutomaticAppInput {
  combinesWith: DiscountCombinesWithInput
  title: String
  startsAt: DateTime
  endsAt: DateTime
  functionId: String
  metafields: [MetafieldInput!]
  appliesOnSubscription: Boolean
  appliesOnOneTimePurchase: Boolean
  recurringCycleLimit: Int
}
type DiscountAutomaticAppUpdatePayload {
  automaticAppDiscount: DiscountAutomaticApp
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticBasic {
  asyncUsageCount: Int!
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  customerGets: DiscountCustomerGets!
  discountClass: MerchandiseDiscountClass!
  endsAt: DateTime
  minimumRequirement: DiscountMinimumRequirement
  recurringCycleLimit: Int!
  shortSummary: String!
  startsAt: DateTime!
  status: DiscountStatus!
  summary: String!
  title: String!
  updatedAt: DateTime!
  usageCount: Int!
}
type DiscountAutomaticBasicCreatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
input DiscountAutomaticBasicInput {
  combinesWith: DiscountCombinesWithInput
  title: String
  startsAt: DateTime
  endsAt: DateTime
  minimumRequirement: DiscountMinimumRequirementInput
  customerGets: DiscountCustomerGetsInput
  recurringCycleLimit: Int
}
type DiscountAutomaticBasicUpdatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticBulkDeletePayload {
  job: Job
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticBxgy {
  asyncUsageCount: Int!
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  customerBuys: DiscountCustomerBuys!
  customerGets: DiscountCustomerGets!
  discountClass: MerchandiseDiscountClass!
  endsAt: DateTime
  events: EventConnection!
  id: ID!
  startsAt: DateTime!
  status: DiscountStatus!
  summary: String!
  title: String!
  updatedAt: DateTime!
  usageCount: Int!
  usesPerOrderLimit: Int
}
type DiscountAutomaticBxgyCreatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
input DiscountAutomaticBxgyInput {
  combinesWith: DiscountCombinesWithInput
  title: String
  startsAt: DateTime
  endsAt: DateTime
  usesPerOrderLimit: UnsignedInt64
  customerBuys: DiscountCustomerBuysInput
  customerGets: DiscountCustomerGetsInput
}
type DiscountAutomaticBxgyUpdatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticConnection {
  edges: [DiscountAutomaticEdge!]!
  nodes: [DiscountAutomatic!]!
  pageInfo: PageInfo!
}
type DiscountAutomaticDeactivatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticDeletePayload {
  deletedAutomaticDiscountId: ID
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticEdge {
  cursor: String!
  node: DiscountAutomatic!
}
type DiscountAutomaticFreeShipping {
  appliesOnOneTimePurchase: Boolean!
  appliesOnSubscription: Boolean!
  asyncUsageCount: Int!
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  destinationSelection: DiscountShippingDestinationSelection!
  discountClass: ShippingDiscountClass!
  endsAt: DateTime
  hasTimelineComment: Boolean!
  maximumShippingPrice: MoneyV2
  minimumRequirement: DiscountMinimumRequirement
  recurringCycleLimit: Int!
  shortSummary: String!
  startsAt: DateTime!
  status: DiscountStatus!
  summary: String!
  title: String!
  totalSales: MoneyV2
  updatedAt: DateTime!
}
type DiscountAutomaticFreeShippingCreatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
input DiscountAutomaticFreeShippingInput {
  title: String
  startsAt: DateTime
  endsAt: DateTime
  combinesWith: DiscountCombinesWithInput
  minimumRequirement: DiscountMinimumRequirementInput
  destination: DiscountShippingDestinationSelectionInput
  maximumShippingPrice: Decimal
  appliesOnOneTimePurchase: Boolean
  appliesOnSubscription: Boolean
  recurringCycleLimit: Int
}
type DiscountAutomaticFreeShippingUpdatePayload {
  automaticDiscountNode: DiscountAutomaticNode
  userErrors: [DiscountUserError!]!
}
type DiscountAutomaticNode {
  automaticDiscount: DiscountAutomatic!
  events: EventConnection!
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
}
type DiscountAutomaticNodeConnection {
  edges: [DiscountAutomaticNodeEdge!]!
  nodes: [DiscountAutomaticNode!]!
  pageInfo: PageInfo!
}
type DiscountAutomaticNodeEdge {
  cursor: String!
  node: DiscountAutomaticNode!
}
enum DiscountClass {
  PRODUCT
  ORDER
  SHIPPING
}
union DiscountCode = DiscountCodeApp | DiscountCodeBasic | DiscountCodeBxgy | DiscountCodeFreeShipping
type DiscountCodeActivatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
type DiscountCodeApp {
  appDiscountType: AppDiscountType!
  appliesOnOneTimePurchase: Boolean!
  appliesOnSubscription: Boolean!
  appliesOncePerCustomer: Boolean!
  asyncUsageCount: Int!
  codes: DiscountRedeemCodeConnection!
  codesCount: Count
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  customerSelection: DiscountCustomerSelection!
  discountClass: DiscountClass!
  discountId: ID!
  endsAt: DateTime
  errorHistory: FunctionsErrorHistory
  hasTimelineComment: Boolean!
  recurringCycleLimit: Int
  shareableUrls: [DiscountShareableUrl!]!
  startsAt: DateTime!
  status: DiscountStatus!
  title: String!
  totalSales: MoneyV2
  updatedAt: DateTime!
  usageLimit: Int
}
type DiscountCodeAppCreatePayload {
  codeAppDiscount: DiscountCodeApp
  userErrors: [DiscountUserError!]!
}
input DiscountCodeAppInput {
  combinesWith: DiscountCombinesWithInput
  title: String
  startsAt: DateTime
  endsAt: DateTime
  appliesOncePerCustomer: Boolean
  code: String
  customerSelection: DiscountCustomerSelectionInput
  usageLimit: Int
  functionId: String
  appliesOnSubscription: Boolean
  appliesOnOneTimePurchase: Boolean
  recurringCycleLimit: Int
  metafields: [MetafieldInput!]
}
type DiscountCodeAppUpdatePayload {
  codeAppDiscount: DiscountCodeApp
  userErrors: [DiscountUserError!]!
}
type DiscountCodeApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  code: String!
  index: Int!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  value: PricingValue!
}
type DiscountCodeBasic {
  appliesOncePerCustomer: Boolean!
  asyncUsageCount: Int!
  codes: DiscountRedeemCodeConnection!
  codesCount: Count
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  customerGets: DiscountCustomerGets!
  customerSelection: DiscountCustomerSelection!
  discountClass: MerchandiseDiscountClass!
  endsAt: DateTime
  hasTimelineComment: Boolean!
  minimumRequirement: DiscountMinimumRequirement
  recurringCycleLimit: Int
  shareableUrls: [DiscountShareableUrl!]!
  shortSummary: String!
  startsAt: DateTime!
  status: DiscountStatus!
  summary: String!
  title: String!
  totalSales: MoneyV2
  updatedAt: DateTime!
  usageLimit: Int
}
type DiscountCodeBasicCreatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
input DiscountCodeBasicInput {
  combinesWith: DiscountCombinesWithInput
  title: String
  startsAt: DateTime
  endsAt: DateTime
  appliesOncePerCustomer: Boolean
  code: String
  customerSelection: DiscountCustomerSelectionInput
  usageLimit: Int
  minimumRequirement: DiscountMinimumRequirementInput
  customerGets: DiscountCustomerGetsInput
  recurringCycleLimit: Int
}
type DiscountCodeBasicUpdatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
type DiscountCodeBulkActivatePayload {
  job: Job
  userErrors: [DiscountUserError!]!
}
type DiscountCodeBulkDeactivatePayload {
  job: Job
  userErrors: [DiscountUserError!]!
}
type DiscountCodeBulkDeletePayload {
  job: Job
  userErrors: [DiscountUserError!]!
}
type DiscountCodeBxgy {
  appliesOncePerCustomer: Boolean!
  asyncUsageCount: Int!
  codes: DiscountRedeemCodeConnection!
  codesCount: Count
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  customerBuys: DiscountCustomerBuys!
  customerGets: DiscountCustomerGets!
  customerSelection: DiscountCustomerSelection!
  discountClass: MerchandiseDiscountClass!
  endsAt: DateTime
  hasTimelineComment: Boolean!
  shareableUrls: [DiscountShareableUrl!]!
  startsAt: DateTime!
  status: DiscountStatus!
  summary: String!
  title: String!
  totalSales: MoneyV2
  updatedAt: DateTime!
  usageLimit: Int
  usesPerOrderLimit: Int
}
type DiscountCodeBxgyCreatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
input DiscountCodeBxgyInput {
  combinesWith: DiscountCombinesWithInput
  title: String
  startsAt: DateTime
  endsAt: DateTime
  appliesOncePerCustomer: Boolean
  code: String
  customerSelection: DiscountCustomerSelectionInput
  usageLimit: Int
  customerBuys: DiscountCustomerBuysInput
  customerGets: DiscountCustomerGetsInput
  usesPerOrderLimit: Int
}
type DiscountCodeBxgyUpdatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
type DiscountCodeDeactivatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
type DiscountCodeDeletePayload {
  deletedCodeDiscountId: ID
  userErrors: [DiscountUserError!]!
}
type DiscountCodeFreeShipping {
  appliesOnOneTimePurchase: Boolean!
  appliesOnSubscription: Boolean!
  appliesOncePerCustomer: Boolean!
  asyncUsageCount: Int!
  codes: DiscountRedeemCodeConnection!
  codesCount: Count
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  customerSelection: DiscountCustomerSelection!
  destinationSelection: DiscountShippingDestinationSelection!
  discountClass: ShippingDiscountClass!
  endsAt: DateTime
  hasTimelineComment: Boolean!
  maximumShippingPrice: MoneyV2
  minimumRequirement: DiscountMinimumRequirement
  recurringCycleLimit: Int
  shareableUrls: [DiscountShareableUrl!]!
  shortSummary: String!
  startsAt: DateTime!
  status: DiscountStatus!
  summary: String!
  title: String!
  totalSales: MoneyV2
  updatedAt: DateTime!
  usageLimit: Int
}
type DiscountCodeFreeShippingCreatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
input DiscountCodeFreeShippingInput {
  combinesWith: DiscountCombinesWithInput
  title: String
  startsAt: DateTime
  endsAt: DateTime
  appliesOncePerCustomer: Boolean
  code: String
  customerSelection: DiscountCustomerSelectionInput
  usageLimit: Int
  minimumRequirement: DiscountMinimumRequirementInput
  destination: DiscountShippingDestinationSelectionInput
  maximumShippingPrice: Decimal
  recurringCycleLimit: Int
  appliesOnOneTimePurchase: Boolean
  appliesOnSubscription: Boolean
}
type DiscountCodeFreeShippingUpdatePayload {
  codeDiscountNode: DiscountCodeNode
  userErrors: [DiscountUserError!]!
}
type DiscountCodeNode {
  codeDiscount: DiscountCode!
  events: EventConnection!
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
}
type DiscountCodeNodeConnection {
  edges: [DiscountCodeNodeEdge!]!
  nodes: [DiscountCodeNode!]!
  pageInfo: PageInfo!
}
type DiscountCodeNodeEdge {
  cursor: String!
  node: DiscountCodeNode!
}
type DiscountCodeRedeemCodeBulkDeletePayload {
  job: Job
  userErrors: [DiscountUserError!]!
}
enum DiscountCodeSortKeys {
  CODE
  CREATED_AT
  ID
  RELEVANCE
}
type DiscountCollections {
  collections: CollectionConnection!
}
input DiscountCollectionsInput {
  add: [ID!]
  remove: [ID!]
}
type DiscountCombinesWith {
  orderDiscounts: Boolean!
  productDiscounts: Boolean!
  shippingDiscounts: Boolean!
}
input DiscountCombinesWithInput {
  productDiscounts: Boolean
  orderDiscounts: Boolean
  shippingDiscounts: Boolean
}
type DiscountCountries {
  countries: [CountryCode!]!
  includeRestOfWorld: Boolean!
}
input DiscountCountriesInput {
  add: [CountryCode!]
  remove: [CountryCode!]
  includeRestOfWorld: Boolean
}
type DiscountCountryAll {
  allCountries: Boolean!
}
type DiscountCustomerAll {
  allCustomers: Boolean!
}
type DiscountCustomerBuys {
  isOneTimePurchase: Boolean!
  isSubscription: Boolean!
  items: DiscountItems!
  value: DiscountCustomerBuysValue!
}
input DiscountCustomerBuysInput {
  value: DiscountCustomerBuysValueInput
  items: DiscountItemsInput
  isOneTimePurchase: Boolean
  isSubscription: Boolean
}
union DiscountCustomerBuysValue = DiscountPurchaseAmount | DiscountQuantity
input DiscountCustomerBuysValueInput {
  quantity: UnsignedInt64
  amount: Decimal
}
type DiscountCustomerGets {
  appliesOnOneTimePurchase: Boolean!
  appliesOnSubscription: Boolean!
  items: DiscountItems!
  value: DiscountCustomerGetsValue!
}
input DiscountCustomerGetsInput {
  value: DiscountCustomerGetsValueInput
  items: DiscountItemsInput
  appliesOnOneTimePurchase: Boolean
  appliesOnSubscription: Boolean
}
union DiscountCustomerGetsValue = DiscountAmount | DiscountOnQuantity | DiscountPercentage
input DiscountCustomerGetsValueInput {
  discountOnQuantity: DiscountOnQuantityInput
  percentage: Float
  discountAmount: DiscountAmountInput
}
type DiscountCustomerSegments {
  segments: [Segment!]!
}
input DiscountCustomerSegmentsInput {
  add: [ID!]
  remove: [ID!]
}
union DiscountCustomerSelection = DiscountCustomerAll | DiscountCustomerSegments | DiscountCustomers
input DiscountCustomerSelectionInput {
  all: Boolean
  customers: DiscountCustomersInput
  customerSegments: DiscountCustomerSegmentsInput
}
type DiscountCustomers {
  customers: [Customer!]!
}
input DiscountCustomersInput {
  add: [ID!]
  remove: [ID!]
}
union DiscountEffect = DiscountAmount | DiscountPercentage
input DiscountEffectInput {
  percentage: Float
  amount: Decimal
}
enum DiscountErrorCode {
  BLANK
  PRESENT
  EQUAL_TO
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  INVALID
  LESS_THAN_OR_EQUAL_TO
  LESS_THAN
  TAKEN
  TOO_LONG
  TOO_SHORT
  INTERNAL_ERROR
  TOO_MANY_ARGUMENTS
  MISSING_ARGUMENT
  ACTIVE_PERIOD_OVERLAP
  EXCEEDED_MAX
  MINIMUM_SUBTOTAL_AND_QUANTITY_RANGE_BOTH_PRESENT
  VALUE_OUTSIDE_RANGE
  CONFLICT
  IMPLICIT_DUPLICATE
  DUPLICATE
  INCLUSION
  INVALID_COMBINES_WITH_FOR_DISCOUNT_CLASS
  INVALID_DISCOUNT_CLASS_FOR_PRICE_RULE
  MAX_APP_DISCOUNTS
  APPLIES_ON_NOTHING
  RECURRING_CYCLE_LIMIT_NOT_A_VALID_INTEGER
  MULTIPLE_RECURRING_CYCLE_LIMIT_FOR_NON_SUBSCRIPTION_ITEMS
}
union DiscountItems = AllDiscountItems | DiscountCollections | DiscountProducts
input DiscountItemsInput {
  products: DiscountProductsInput
  collections: DiscountCollectionsInput
  all: Boolean
}
type DiscountMinimumQuantity {
  greaterThanOrEqualToQuantity: UnsignedInt64!
}
input DiscountMinimumQuantityInput {
  greaterThanOrEqualToQuantity: UnsignedInt64
}
union DiscountMinimumRequirement = DiscountMinimumQuantity | DiscountMinimumSubtotal
input DiscountMinimumRequirementInput {
  quantity: DiscountMinimumQuantityInput
  subtotal: DiscountMinimumSubtotalInput
}
type DiscountMinimumSubtotal {
  greaterThanOrEqualToSubtotal: MoneyV2!
}
input DiscountMinimumSubtotalInput {
  greaterThanOrEqualToSubtotal: Decimal
}
type DiscountNode {
  discount: Discount!
  events: EventConnection!
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
}
type DiscountNodeConnection {
  edges: [DiscountNodeEdge!]!
  nodes: [DiscountNode!]!
  pageInfo: PageInfo!
}
type DiscountNodeEdge {
  cursor: String!
  node: DiscountNode!
}
type DiscountOnQuantity {
  effect: DiscountEffect!
  quantity: DiscountQuantity!
}
input DiscountOnQuantityInput {
  quantity: UnsignedInt64
  effect: DiscountEffectInput
}
type DiscountPercentage {
  percentage: Float!
}
type DiscountProducts {
  productVariants: ProductVariantConnection!
  products: ProductConnection!
}
input DiscountProductsInput {
  productsToAdd: [ID!]
  productsToRemove: [ID!]
  productVariantsToAdd: [ID!]
  productVariantsToRemove: [ID!]
}
type DiscountPurchaseAmount {
  amount: Decimal!
}
type DiscountQuantity {
  quantity: UnsignedInt64!
}
type DiscountRedeemCode {
  asyncUsageCount: Int!
  code: String!
  createdBy: App
  id: ID!
}
type DiscountRedeemCodeBulkAddPayload {
  bulkCreation: DiscountRedeemCodeBulkCreation
  userErrors: [DiscountUserError!]!
}
type DiscountRedeemCodeBulkCreation {
  codes: DiscountRedeemCodeBulkCreationCodeConnection!
  codesCount: Int!
  createdAt: DateTime!
  discountCode: DiscountCodeNode
  done: Boolean!
  failedCount: Int!
  id: ID!
  importedCount: Int!
}
type DiscountRedeemCodeBulkCreationCode {
  code: String!
  discountRedeemCode: DiscountRedeemCode
  errors: [DiscountUserError!]!
}
type DiscountRedeemCodeBulkCreationCodeConnection {
  edges: [DiscountRedeemCodeBulkCreationCodeEdge!]!
  nodes: [DiscountRedeemCodeBulkCreationCode!]!
  pageInfo: PageInfo!
}
type DiscountRedeemCodeBulkCreationCodeEdge {
  cursor: String!
  node: DiscountRedeemCodeBulkCreationCode!
}
type DiscountRedeemCodeConnection {
  edges: [DiscountRedeemCodeEdge!]!
  nodes: [DiscountRedeemCode!]!
  pageInfo: PageInfo!
}
type DiscountRedeemCodeEdge {
  cursor: String!
  node: DiscountRedeemCode!
}
input DiscountRedeemCodeInput {
  code: String!
}
type DiscountShareableUrl {
  targetItemImage: Image
  targetType: DiscountShareableUrlTargetType!
  title: String!
  url: URL!
}
enum DiscountShareableUrlTargetType {
  HOME
  PRODUCT
  COLLECTION
}
union DiscountShippingDestinationSelection = DiscountCountries | DiscountCountryAll
input DiscountShippingDestinationSelectionInput {
  all: Boolean
  countries: DiscountCountriesInput
}
enum DiscountSortKeys {
  CREATED_AT
  ENDS_AT
  ID
  RELEVANCE
  STARTS_AT
  TITLE
  UPDATED_AT
}
enum DiscountStatus {
  ACTIVE
  EXPIRED
  SCHEDULED
}
enum DiscountTargetType {
  LINE_ITEM
  SHIPPING_LINE
}
enum DiscountType {
  MANUAL
  CODE_DISCOUNT
  AUTOMATIC_DISCOUNT
}
type DiscountUserError {
  code: DiscountErrorCode
  extraInfo: String
  field: [String!]
  message: String!
}
interface DisplayableError {
  field: [String!]
  message: String!
}
type DisputeEvidenceUpdatePayload {
  disputeEvidence: ShopifyPaymentsDisputeEvidence
  userErrors: [DisputeEvidenceUpdateUserError!]!
}
type DisputeEvidenceUpdateUserError {
  code: DisputeEvidenceUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum DisputeEvidenceUpdateUserErrorCode {
  DISPUTE_EVIDENCE_NOT_FOUND
  EVIDENCE_ALREADY_ACCEPTED
  EVIDENCE_PAST_DUE_DATE
  FILES_SIZE_EXCEEDED_LIMIT
  TOO_LARGE
  INVALID
}
enum DisputeStatus {
  ACCEPTED
  LOST
  NEEDS_RESPONSE
  UNDER_REVIEW
  WON
  CHARGE_REFUNDED
}
enum DisputeType {
  CHARGEBACK
  INQUIRY
}
type Domain {
  host: String!
  id: ID!
  localization: DomainLocalization
  marketWebPresence: MarketWebPresence
  sslEnabled: Boolean!
  url: URL!
}
type DomainLocalization {
  alternateLocales: [String!]!
  country: String
  defaultLocale: String!
}
type DraftOrder {
  acceptAutomaticDiscounts: Boolean
  allVariantPricesOverridden: Boolean!
  allowDiscountCodesInCheckout: Boolean!
  anyVariantPricesOverridden: Boolean!
  appliedDiscount: DraftOrderAppliedDiscount
  billingAddress: MailingAddress
  billingAddressMatchesShippingAddress: Boolean!
  completedAt: DateTime
  createdAt: DateTime!
  currencyCode: CurrencyCode!
  customAttributes: [Attribute!]!
  customer: Customer
  defaultCursor: String!
  discountCodes: [String!]!
  email: String
  events: EventConnection!
  hasTimelineComment: Boolean!
  id: ID!
  invoiceEmailTemplateSubject: String!
  invoiceSentAt: DateTime
  invoiceUrl: URL
  legacyResourceId: UnsignedInt64!
  lineItems: DraftOrderLineItemConnection!
  lineItemsSubtotalPrice: MoneyBag!
  localizationExtensions: LocalizationExtensionConnection!
  localizedFields: LocalizedFieldConnection!
  marketName: String!
  marketRegionCountryCode: CountryCode!
  metafield: Metafield
  metafields: MetafieldConnection!
  name: String!
  note2: String
  order: Order
  paymentTerms: PaymentTerms
  phone: String
  platformDiscounts: [DraftOrderPlatformDiscount!]!
  poNumber: String
  presentmentCurrencyCode: CurrencyCode!
  purchasingEntity: PurchasingEntity
  ready: Boolean!
  reserveInventoryUntil: DateTime
  shippingAddress: MailingAddress
  shippingLine: ShippingLine
  status: DraftOrderStatus!
  subtotalPrice: Money!
  subtotalPriceSet: MoneyBag!
  tags: [String!]!
  taxExempt: Boolean!
  taxLines: [TaxLine!]!
  taxesIncluded: Boolean!
  totalDiscountsSet: MoneyBag!
  totalLineItemsPriceSet: MoneyBag!
  totalPrice: Money!
  totalPriceSet: MoneyBag!
  totalQuantityOfLineItems: Int!
  totalShippingPrice: Money!
  totalShippingPriceSet: MoneyBag!
  totalTax: Money!
  totalTaxSet: MoneyBag!
  totalWeight: UnsignedInt64!
  transformerFingerprint: String
  updatedAt: DateTime!
  visibleToCustomer: Boolean!
  warnings: [DraftOrderWarning!]!
}
type DraftOrderAppliedDiscount {
  amount: Money!
  amountSet: MoneyBag!
  amountV2: MoneyV2!
  description: String!
  title: String
  value: Float!
  valueType: DraftOrderAppliedDiscountType!
}
input DraftOrderAppliedDiscountInput {
  amountWithCurrency: MoneyInput
  description: String
  title: String
  value: Float!
  valueType: DraftOrderAppliedDiscountType!
}
enum DraftOrderAppliedDiscountType {
  FIXED_AMOUNT
  PERCENTAGE
}
type DraftOrderBulkAddTagsPayload {
  job: Job
  userErrors: [UserError!]!
}
type DraftOrderBulkDeletePayload {
  job: Job
  userErrors: [UserError!]!
}
type DraftOrderBulkRemoveTagsPayload {
  job: Job
  userErrors: [UserError!]!
}
type DraftOrderBundleAddedWarning {
  errorCode: String!
  field: String!
  message: String!
}
type DraftOrderCalculatePayload {
  calculatedDraftOrder: CalculatedDraftOrder
  userErrors: [UserError!]!
}
type DraftOrderCompletePayload {
  draftOrder: DraftOrder
  userErrors: [UserError!]!
}
type DraftOrderConnection {
  edges: [DraftOrderEdge!]!
  nodes: [DraftOrder!]!
  pageInfo: PageInfo!
}
type DraftOrderCreateFromOrderPayload {
  draftOrder: DraftOrder
  userErrors: [UserError!]!
}
type DraftOrderCreateMerchantCheckoutPayload {
  userErrors: [UserError!]!
}
type DraftOrderCreatePayload {
  draftOrder: DraftOrder
  userErrors: [UserError!]!
}
input DraftOrderDeleteInput {
  id: ID!
}
type DraftOrderDeletePayload {
  deletedId: ID
  userErrors: [UserError!]!
}
type DraftOrderDiscountNotAppliedWarning {
  discountCode: String
  discountTitle: String
  errorCode: String!
  field: String!
  message: String!
  priceRule: PriceRule
}
type DraftOrderDuplicatePayload {
  draftOrder: DraftOrder
  userErrors: [UserError!]!
}
type DraftOrderEdge {
  cursor: String!
  node: DraftOrder!
}
input DraftOrderInput {
  appliedDiscount: DraftOrderAppliedDiscountInput
  discountCodes: [String!]
  acceptAutomaticDiscounts: Boolean
  billingAddress: MailingAddressInput
  customAttributes: [AttributeInput!]
  email: String
  lineItems: [DraftOrderLineItemInput!]
  metafields: [MetafieldInput!]
  localizedFields: [LocalizedFieldInput!]
  note: String
  shippingAddress: MailingAddressInput
  shippingLine: ShippingLineInput
  tags: [String!]
  taxExempt: Boolean
  useCustomerDefaultAddress: Boolean
  visibleToCustomer: Boolean
  reserveInventoryUntil: DateTime
  presentmentCurrencyCode: CurrencyCode
  phone: String
  paymentTerms: PaymentTermsInput
  purchasingEntity: PurchasingEntityInput
  sourceName: String
  allowDiscountCodesInCheckout: Boolean
  poNumber: String
  sessionToken: String
  transformerFingerprint: String
}
type DraftOrderInvoicePreviewPayload {
  previewHtml: HTML
  previewSubject: HTML
  userErrors: [UserError!]!
}
type DraftOrderInvoiceSendPayload {
  draftOrder: DraftOrder
  userErrors: [UserError!]!
}
type DraftOrderLineItem {
  appliedDiscount: DraftOrderAppliedDiscount
  approximateDiscountedUnitPriceSet: MoneyBag!
  bundleComponents: [DraftOrderLineItem!]!
  custom: Boolean!
  customAttributes: [Attribute!]!
  customAttributesV2: [TypedAttribute!]!
  discountedTotal: Money!
  discountedTotalSet: MoneyBag!
  discountedUnitPrice: Money!
  discountedUnitPriceSet: MoneyBag!
  fulfillmentService: FulfillmentService
  grams: Int
  id: ID!
  image: Image
  isGiftCard: Boolean!
  name: String!
  originalTotal: Money!
  originalTotalSet: MoneyBag!
  originalUnitPrice: Money!
  originalUnitPriceSet: MoneyBag!
  originalUnitPriceWithCurrency: MoneyV2
  priceOverride: MoneyV2
  product: Product
  quantity: Int!
  requiresShipping: Boolean!
  sku: String
  taxLines: [TaxLine!]!
  taxable: Boolean!
  title: String!
  totalDiscount: Money!
  totalDiscountSet: MoneyBag!
  uuid: String!
  variant: ProductVariant
  variantTitle: String
  vendor: String
  weight: Weight
}
type DraftOrderLineItemConnection {
  edges: [DraftOrderLineItemEdge!]!
  nodes: [DraftOrderLineItem!]!
  pageInfo: PageInfo!
}
type DraftOrderLineItemEdge {
  cursor: String!
  node: DraftOrderLineItem!
}
input DraftOrderLineItemInput {
  appliedDiscount: DraftOrderAppliedDiscountInput
  customAttributes: [AttributeInput!]
  originalUnitPriceWithCurrency: MoneyInput
  quantity: Int!
  requiresShipping: Boolean
  sku: String
  taxable: Boolean
  title: String
  variantId: ID
  weight: WeightInput
  uuid: String
  bundleComponents: [BundlesDraftOrderBundleLineItemComponentInput!]
  generatePriceOverride: Boolean
  priceOverride: MoneyInput
}
type DraftOrderPlatformDiscount {
  allocations: [DraftOrderPlatformDiscountAllocation!]!
  automaticDiscount: Boolean!
  bxgyDiscount: Boolean!
  code: String
  discountClass: DiscountClass!
  discountNode: DiscountNode
  id: ID
  presentationLevel: String!
  shortSummary: String!
  summary: String!
  title: String!
  totalAmount: MoneyV2!
  totalAmountPriceSet: MoneyBag!
}
type DraftOrderPlatformDiscountAllocation {
  id: ID
  quantity: Int
  reductionAmount: MoneyV2!
  reductionAmountSet: MoneyBag!
  target: DraftOrderPlatformDiscountAllocationTarget
}
union DraftOrderPlatformDiscountAllocationTarget = CalculatedDraftOrderLineItem | DraftOrderLineItem | ShippingLine
enum DraftOrderSortKeys {
  CUSTOMER_NAME
  ID
  NUMBER
  RELEVANCE
  STATUS
  TOTAL_PRICE
  UPDATED_AT
}
enum DraftOrderStatus {
  COMPLETED
  INVOICE_SENT
  OPEN
}
type DraftOrderTag {
  handle: String!
  id: ID!
  title: String!
}
type DraftOrderUpdatePayload {
  draftOrder: DraftOrder
  userErrors: [UserError!]!
}
interface DraftOrderWarning {
  errorCode: String!
  field: String!
  message: String!
}
type Duty {
  countryCodeOfOrigin: CountryCode
  harmonizedSystemCode: String
  id: ID!
  price: MoneyBag!
  taxLines: [TaxLine!]!
}
type DutySale {
  actionType: SaleActionType!
  duty: Duty!
  id: ID!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
type EditableProperty {
  locked: Boolean!
  reason: FormattedString
}
input EmailInput {
  subject: String
  to: String
  from: String
  body: String
  bcc: [String!]
  customMessage: String
}
type ErrorsServerPixelUserError {
  code: ErrorsServerPixelUserErrorCode
  field: [String!]
  message: String!
}
enum ErrorsServerPixelUserErrorCode {
  NOT_FOUND
  ALREADY_EXISTS
  PUB_SUB_ERROR
  NEEDS_CONFIGURATION_TO_CONNECT
}
type ErrorsWebPixelUserError {
  code: ErrorsWebPixelUserErrorCode
  field: [String!]
  message: String!
}
enum ErrorsWebPixelUserErrorCode {
  BLANK
  TAKEN
  NOT_FOUND
  INVALID_SETTINGS
  UNABLE_TO_DELETE
}
interface Event {
  action: String!
  appTitle: String
  attributeToApp: Boolean!
  attributeToUser: Boolean!
  createdAt: DateTime!
  criticalAlert: Boolean!
  id: ID!
  message: FormattedString!
}
type EventBridgeServerPixelUpdatePayload {
  serverPixel: ServerPixel
  userErrors: [ErrorsServerPixelUserError!]!
}
type EventBridgeWebhookSubscriptionCreatePayload {
  userErrors: [UserError!]!
  webhookSubscription: WebhookSubscription
}
input EventBridgeWebhookSubscriptionInput {
  arn: ARN
  format: WebhookSubscriptionFormat
  includeFields: [String!]
  filter: String
  metafieldNamespaces: [String!]
}
type EventBridgeWebhookSubscriptionUpdatePayload {
  userErrors: [UserError!]!
  webhookSubscription: WebhookSubscription
}
type EventConnection {
  edges: [EventEdge!]!
  nodes: [Event!]!
  pageInfo: PageInfo!
}
type EventEdge {
  cursor: String!
  node: Event!
}
enum EventSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
enum EventSubjectType {
  COMPANY_LOCATION
  COMPANY
  CUSTOMER
  DRAFT_ORDER
  COLLECTION
  PRODUCT
  PRODUCT_VARIANT
  ARTICLE
  BLOG
  COMMENT
  PAGE
  DISCOUNT_AUTOMATIC_BXGY
  DISCOUNT_AUTOMATIC_NODE
  DISCOUNT_CODE_NODE
  DISCOUNT_NODE
  PRICE_RULE
  ORDER
  UNKNOWN
}
type ExchangeLineItem {
  id: ID!
  lineItem: LineItem
}
input ExchangeLineItemAppliedDiscountInput {
  description: String
  value: ExchangeLineItemAppliedDiscountValueInput!
}
input ExchangeLineItemAppliedDiscountValueInput {
  amount: MoneyInput
  percentage: Float
}
type ExchangeLineItemConnection {
  edges: [ExchangeLineItemEdge!]!
  nodes: [ExchangeLineItem!]!
  pageInfo: PageInfo!
}
type ExchangeLineItemEdge {
  cursor: String!
  node: ExchangeLineItem!
}
input ExchangeLineItemInput {
  giftCardCodes: [String!]
  variantId: ID
  quantity: Int!
  appliedDiscount: ExchangeLineItemAppliedDiscountInput
}
type ExchangeV2 {
  additions: ExchangeV2Additions!
  completedAt: DateTime
  createdAt: DateTime!
  id: ID!
  location: Location
  note: String
  refunds: [Refund!]!
  returns: ExchangeV2Returns!
  staffMember: StaffMember
  totalAmountProcessedSet: MoneyBag!
  totalPriceSet: MoneyBag!
  transactions: [OrderTransaction!]!
}
type ExchangeV2Additions {
  lineItems: [ExchangeV2LineItem!]!
  subtotalPriceSet: MoneyBag!
  taxLines: [TaxLine!]!
  totalPriceSet: MoneyBag!
}
type ExchangeV2Connection {
  edges: [ExchangeV2Edge!]!
  nodes: [ExchangeV2!]!
  pageInfo: PageInfo!
}
type ExchangeV2Edge {
  cursor: String!
  node: ExchangeV2!
}
type ExchangeV2LineItem {
  customAttributes: [Attribute!]!
  discountedTotalSet: MoneyBag!
  discountedUnitPriceSet: MoneyBag!
  fulfillmentService: FulfillmentService
  giftCard: Boolean!
  giftCards: [GiftCard!]!
  isGiftCard: Boolean!
  lineItem: LineItem
  name: String!
  originalTotalSet: MoneyBag!
  originalUnitPriceSet: MoneyBag!
  quantity: Int!
  requiresShipping: Boolean!
  sku: String
  taxLines: [TaxLine!]!
  taxable: Boolean!
  title: String!
  variant: ProductVariant
  variantTitle: String
  vendor: String
}
type ExchangeV2Returns {
  lineItems: [ExchangeV2LineItem!]!
  orderDiscountAmountSet: MoneyBag!
  shippingRefundAmountSet: MoneyBag!
  subtotalPriceSet: MoneyBag!
  taxLines: [TaxLine!]!
  tipRefundAmountSet: MoneyBag!
  totalPriceSet: MoneyBag!
}
type ExternalVideo {
  alt: String
  createdAt: DateTime!
  embedUrl: URL!
  embeddedUrl: URL!
  fileErrors: [FileError!]!
  fileStatus: FileStatus!
  host: MediaHost!
  id: ID!
  mediaContentType: MediaContentType!
  mediaErrors: [MediaError!]!
  mediaWarnings: [MediaWarning!]!
  originUrl: URL!
  preview: MediaPreviewImage
  status: MediaStatus!
  updatedAt: DateTime!
}
type FailedRequirement {
  action: NavigationItem
  message: String!
}
interface Fee {
  id: ID!
}
type FeeSale {
  actionType: SaleActionType!
  fee: Fee!
  id: ID!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
interface File {
  alt: String
  createdAt: DateTime!
  fileErrors: [FileError!]!
  fileStatus: FileStatus!
  id: ID!
  preview: MediaPreviewImage
  updatedAt: DateTime!
}
type FileAcknowledgeUpdateFailedPayload {
  files: [File!]
  userErrors: [FilesUserError!]!
}
type FileConnection {
  edges: [FileEdge!]!
  nodes: [File!]!
  pageInfo: PageInfo!
}
enum FileContentType {
  IMAGE
  FILE
  VIDEO
  EXTERNAL_VIDEO
  MODEL_3D
}
input FileCreateInput {
  filename: String
  contentType: FileContentType
  alt: String
  duplicateResolutionMode: FileCreateInputDuplicateResolutionMode
  originalSource: String!
}
enum FileCreateInputDuplicateResolutionMode {
  APPEND_UUID
  RAISE_ERROR
  REPLACE
}
type FileCreatePayload {
  files: [File!]
  userErrors: [FilesUserError!]!
}
type FileDeletePayload {
  deletedFileIds: [ID!]
  userErrors: [FilesUserError!]!
}
type FileEdge {
  cursor: String!
  node: File!
}
type FileError {
  code: FileErrorCode!
  details: String
  message: String!
}
enum FileErrorCode {
  UNKNOWN
  INVALID_SIGNED_URL
  IMAGE_DOWNLOAD_FAILURE
  IMAGE_PROCESSING_FAILURE
  MEDIA_TIMEOUT_ERROR
  EXTERNAL_VIDEO_NOT_FOUND
  EXTERNAL_VIDEO_UNLISTED
  EXTERNAL_VIDEO_INVALID_ASPECT_RATIO
  EXTERNAL_VIDEO_EMBED_DISABLED
  EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING
  GENERIC_FILE_DOWNLOAD_FAILURE
  GENERIC_FILE_INVALID_SIZE
  VIDEO_METADATA_READ_ERROR
  VIDEO_INVALID_FILETYPE_ERROR
  VIDEO_MIN_WIDTH_ERROR
  VIDEO_MAX_WIDTH_ERROR
  VIDEO_MIN_HEIGHT_ERROR
  VIDEO_MAX_HEIGHT_ERROR
  VIDEO_MIN_DURATION_ERROR
  VIDEO_MAX_DURATION_ERROR
  VIDEO_VALIDATION_ERROR
  MODEL3D_VALIDATION_ERROR
  MODEL3D_THUMBNAIL_GENERATION_ERROR
  MODEL3D_THUMBNAIL_REGENERATION_ERROR
  MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR
  MODEL3D_GLB_OUTPUT_CREATION_ERROR
  MODEL3D_PROCESSING_FAILURE
  UNSUPPORTED_IMAGE_FILE_TYPE
  INVALID_IMAGE_FILE_SIZE
  INVALID_IMAGE_ASPECT_RATIO
  INVALID_IMAGE_RESOLUTION
  FILE_STORAGE_LIMIT_EXCEEDED
  DUPLICATE_FILENAME_ERROR
}
input FileSetInput {
  filename: String
  contentType: FileContentType
  alt: String
  duplicateResolutionMode: FileCreateInputDuplicateResolutionMode
  id: ID
  originalSource: String
}
enum FileSortKeys {
  CREATED_AT
  FILENAME
  ID
  ORIGINAL_UPLOAD_SIZE
  RELEVANCE
  UPDATED_AT
}
enum FileStatus {
  UPLOADED
  PROCESSING
  READY
  FAILED
}
input FileUpdateInput {
  id: ID!
  alt: String
  originalSource: String
  previewImageSource: String
  filename: String
  referencesToAdd: [ID!]
  referencesToRemove: [ID!]
}
type FileUpdatePayload {
  files: [File!]
  userErrors: [FilesUserError!]!
}
enum FilesErrorCode {
  INVALID
  FILE_DOES_NOT_EXIST
  FILE_LOCKED
  UNSUPPORTED_MEDIA_TYPE_FOR_FILENAME_UPDATE
  TOO_MANY_ARGUMENTS
  BLANK_SEARCH
  MISSING_ARGUMENTS
  INVALID_QUERY
  PRODUCT_SUSPENDED
  INVALID_FILENAME_EXTENSION
  INVALID_FILENAME
  FILENAME_ALREADY_EXISTS
  UNACCEPTABLE_UNVERIFIED_TRIAL_ASSET
  UNACCEPTABLE_ASSET
  UNACCEPTABLE_TRIAL_ASSET
  ALT_VALUE_LIMIT_EXCEEDED
  NON_READY_STATE
  NON_IMAGE_MEDIA_PER_SHOP_LIMIT_EXCEEDED
  MISMATCHED_FILENAME_AND_ORIGINAL_SOURCE
  INVALID_DUPLICATE_MODE_FOR_TYPE
  INVALID_IMAGE_SOURCE_URL
  MISSING_FILENAME_FOR_DUPLICATE_MODE_REPLACE
  PRODUCT_MEDIA_LIMIT_EXCEEDED
  UNSUPPORTED_FILE_REFERENCE
  REFERENCE_TARGET_DOES_NOT_EXIST
  TOO_MANY_FILE_REFERENCE
}
type FilesUserError {
  code: FilesErrorCode
  field: [String!]
  message: String!
}
type FilterOption {
  label: String!
  value: String!
}
type FinancialSummaryDiscountAllocation {
  approximateAllocatedAmountPerItem: MoneyBag!
  discountApplication: FinancialSummaryDiscountApplication!
}
type FinancialSummaryDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
}
scalar Float
type FlowGenerateSignaturePayload {
  payload: String
  signature: String
  userErrors: [UserError!]!
}
type FlowTriggerReceivePayload {
  userErrors: [UserError!]!
}
scalar FormattedString
type Fulfillment {
  createdAt: DateTime!
  deliveredAt: DateTime
  displayStatus: FulfillmentDisplayStatus
  estimatedDeliveryAt: DateTime
  events: FulfillmentEventConnection!
  fulfillmentLineItems: FulfillmentLineItemConnection!
  fulfillmentOrders: FulfillmentOrderConnection!
  id: ID!
  inTransitAt: DateTime
  legacyResourceId: UnsignedInt64!
  location: Location
  name: String!
  order: Order!
  originAddress: FulfillmentOriginAddress
  requiresShipping: Boolean!
  service: FulfillmentService
  status: FulfillmentStatus!
  totalQuantity: Int!
  trackingInfo: [FulfillmentTrackingInfo!]!
  updatedAt: DateTime!
}
type FulfillmentCancelPayload {
  fulfillment: Fulfillment
  userErrors: [UserError!]!
}
type FulfillmentConnection {
  edges: [FulfillmentEdge!]!
  nodes: [Fulfillment!]!
  pageInfo: PageInfo!
}
type FulfillmentConstraintRule {
  deliveryMethodTypes: [DeliveryMethodType!]!
  function: ShopifyFunction!
  id: ID!
  metafield: Metafield
  metafields: MetafieldConnection!
}
type FulfillmentConstraintRuleCreatePayload {
  fulfillmentConstraintRule: FulfillmentConstraintRule
  userErrors: [FulfillmentConstraintRuleCreateUserError!]!
}
type FulfillmentConstraintRuleCreateUserError {
  code: FulfillmentConstraintRuleCreateUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentConstraintRuleCreateUserErrorCode {
  INPUT_INVALID
  FUNCTION_NOT_FOUND
  FUNCTION_ALREADY_REGISTERED
  FUNCTION_DOES_NOT_IMPLEMENT
  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE
  FUNCTION_PENDING_DELETION
  MAXIMUM_FULFILLMENT_CONSTRAINT_RULES_REACHED
}
type FulfillmentConstraintRuleDeletePayload {
  success: Boolean
  userErrors: [FulfillmentConstraintRuleDeleteUserError!]!
}
type FulfillmentConstraintRuleDeleteUserError {
  code: FulfillmentConstraintRuleDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentConstraintRuleDeleteUserErrorCode {
  NOT_FOUND
  UNAUTHORIZED_APP_SCOPE
}
type FulfillmentConstraintRuleUpdatePayload {
  fulfillmentConstraintRule: FulfillmentConstraintRule
  userErrors: [FulfillmentConstraintRuleUpdateUserError!]!
}
type FulfillmentConstraintRuleUpdateUserError {
  code: FulfillmentConstraintRuleUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentConstraintRuleUpdateUserErrorCode {
  NOT_FOUND
  UNAUTHORIZED_APP_SCOPE
}
type FulfillmentCreatePayload {
  fulfillment: Fulfillment
  userErrors: [UserError!]!
}
type FulfillmentCreateV2Payload {
  fulfillment: Fulfillment
  userErrors: [UserError!]!
}
enum FulfillmentDisplayStatus {
  ATTEMPTED_DELIVERY
  CANCELED
  CONFIRMED
  DELAYED
  DELIVERED
  FAILURE
  FULFILLED
  IN_TRANSIT
  LABEL_PRINTED
  LABEL_PURCHASED
  LABEL_VOIDED
  MARKED_AS_FULFILLED
  NOT_DELIVERED
  OUT_FOR_DELIVERY
  READY_FOR_PICKUP
  PICKED_UP
  SUBMITTED
}
type FulfillmentEdge {
  cursor: String!
  node: Fulfillment!
}
type FulfillmentEvent {
  address1: String
  city: String
  country: String
  createdAt: DateTime!
  estimatedDeliveryAt: DateTime
  happenedAt: DateTime!
  id: ID!
  latitude: Float
  longitude: Float
  message: String
  province: String
  status: FulfillmentEventStatus!
  zip: String
}
type FulfillmentEventConnection {
  edges: [FulfillmentEventEdge!]!
  nodes: [FulfillmentEvent!]!
  pageInfo: PageInfo!
}
type FulfillmentEventCreatePayload {
  fulfillmentEvent: FulfillmentEvent
  userErrors: [UserError!]!
}
type FulfillmentEventEdge {
  cursor: String!
  node: FulfillmentEvent!
}
input FulfillmentEventInput {
  address1: String
  city: String
  country: String
  estimatedDeliveryAt: DateTime
  happenedAt: DateTime
  fulfillmentId: ID!
  latitude: Float
  longitude: Float
  message: String
  province: String
  status: FulfillmentEventStatus!
  zip: String
}
enum FulfillmentEventSortKeys {
  HAPPENED_AT
  ID
  RELEVANCE
}
enum FulfillmentEventStatus {
  LABEL_PURCHASED
  LABEL_PRINTED
  READY_FOR_PICKUP
  CONFIRMED
  IN_TRANSIT
  OUT_FOR_DELIVERY
  ATTEMPTED_DELIVERY
  DELAYED
  DELIVERED
  FAILURE
}
type FulfillmentHold {
  displayReason: String!
  handle: String
  heldByApp: App
  heldByRequestingApp: Boolean!
  id: ID!
  reason: FulfillmentHoldReason!
  reasonNotes: String
}
enum FulfillmentHoldReason {
  AWAITING_PAYMENT
  HIGH_RISK_OF_FRAUD
  INCORRECT_ADDRESS
  INVENTORY_OUT_OF_STOCK
  UNKNOWN_DELIVERY_DATE
  ONLINE_STORE_POST_PURCHASE_CROSS_SELL
  AWAITING_RETURN_ITEMS
  OTHER
}
input FulfillmentInput {
  trackingInfo: FulfillmentTrackingInput
  notifyCustomer: Boolean
  lineItemsByFulfillmentOrder: [FulfillmentOrderLineItemsInput!]!
  originAddress: FulfillmentOriginAddressInput
}
type FulfillmentLineItem {
  discountedTotal: Money!
  discountedTotalSet: MoneyBag!
  id: ID!
  lineItem: LineItem!
  originalTotal: Money!
  originalTotalSet: MoneyBag!
  quantity: Int
}
type FulfillmentLineItemConnection {
  edges: [FulfillmentLineItemEdge!]!
  nodes: [FulfillmentLineItem!]!
  pageInfo: PageInfo!
}
type FulfillmentLineItemEdge {
  cursor: String!
  node: FulfillmentLineItem!
}
type FulfillmentOrder {
  assignedLocation: FulfillmentOrderAssignedLocation!
  channelId: ID
  createdAt: DateTime!
  deliveryMethod: DeliveryMethod
  destination: FulfillmentOrderDestination
  fulfillAt: DateTime
  fulfillBy: DateTime
  fulfillmentHolds: [FulfillmentHold!]!
  fulfillmentOrdersForMerge: FulfillmentOrderConnection!
  fulfillments: FulfillmentConnection!
  id: ID!
  internationalDuties: FulfillmentOrderInternationalDuties
  lineItems: FulfillmentOrderLineItemConnection!
  locationsForMove: FulfillmentOrderLocationForMoveConnection!
  merchantRequests: FulfillmentOrderMerchantRequestConnection!
  order: Order!
  orderId: ID!
  orderName: String!
  orderProcessedAt: DateTime!
  requestStatus: FulfillmentOrderRequestStatus!
  status: FulfillmentOrderStatus!
  supportedActions: [FulfillmentOrderSupportedAction!]!
  updatedAt: DateTime!
}
type FulfillmentOrderAcceptCancellationRequestPayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderAcceptFulfillmentRequestPayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
enum FulfillmentOrderAction {
  CREATE_FULFILLMENT
  REQUEST_FULFILLMENT
  CANCEL_FULFILLMENT_ORDER
  MOVE
  REQUEST_CANCELLATION
  MARK_AS_OPEN
  RELEASE_HOLD
  HOLD
  EXTERNAL
  SPLIT
  MERGE
}
type FulfillmentOrderAssignedLocation {
  address1: String
  address2: String
  city: String
  countryCode: CountryCode!
  location: Location
  name: String!
  phone: String
  province: String
  zip: String
}
enum FulfillmentOrderAssignmentStatus {
  CANCELLATION_REQUESTED
  FULFILLMENT_REQUESTED
  FULFILLMENT_ACCEPTED
  FULFILLMENT_UNSUBMITTED
}
type FulfillmentOrderCancelPayload {
  fulfillmentOrder: FulfillmentOrder
  replacementFulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderClosePayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderConnection {
  edges: [FulfillmentOrderEdge!]!
  nodes: [FulfillmentOrder!]!
  pageInfo: PageInfo!
}
type FulfillmentOrderDestination {
  address1: String
  address2: String
  city: String
  company: String
  countryCode: CountryCode
  email: String
  firstName: String
  id: ID!
  lastName: String
  location: Location
  phone: String
  province: String
  zip: String
}
type FulfillmentOrderEdge {
  cursor: String!
  node: FulfillmentOrder!
}
input FulfillmentOrderHoldInput {
  reason: FulfillmentHoldReason!
  reasonNotes: String
  notifyMerchant: Boolean
  externalId: String
  handle: String
  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]
}
type FulfillmentOrderHoldPayload {
  fulfillmentHold: FulfillmentHold
  fulfillmentOrder: FulfillmentOrder
  remainingFulfillmentOrder: FulfillmentOrder
  userErrors: [FulfillmentOrderHoldUserError!]!
}
type FulfillmentOrderHoldUserError {
  code: FulfillmentOrderHoldUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentOrderHoldUserErrorCode {
  FULFILLMENT_ORDER_NOT_FOUND
  TAKEN
  GREATER_THAN_ZERO
  FULFILLMENT_ORDER_HOLD_LIMIT_REACHED
  DUPLICATE_FULFILLMENT_HOLD_HANDLE
  INVALID_LINE_ITEM_QUANTITY
  FULFILLMENT_ORDER_NOT_SPLITTABLE
}
type FulfillmentOrderInternationalDuties {
  incoterm: String!
}
type FulfillmentOrderLineItem {
  financialSummaries: [FulfillmentOrderLineItemFinancialSummary!]!
  id: ID!
  image: Image
  inventoryItemId: ID
  lineItem: LineItem!
  originalUnitPriceSet: MoneyBag!
  productTitle: String!
  remainingQuantity: Int!
  requiresShipping: Boolean!
  sku: String
  totalQuantity: Int!
  variant: ProductVariant
  variantTitle: String
  vendor: String
  warnings: [FulfillmentOrderLineItemWarning!]!
  weight: Weight
}
type FulfillmentOrderLineItemConnection {
  edges: [FulfillmentOrderLineItemEdge!]!
  nodes: [FulfillmentOrderLineItem!]!
  pageInfo: PageInfo!
}
type FulfillmentOrderLineItemEdge {
  cursor: String!
  node: FulfillmentOrderLineItem!
}
type FulfillmentOrderLineItemFinancialSummary {
  approximateDiscountedUnitPriceSet: MoneyBag!
  discountAllocations: [FinancialSummaryDiscountAllocation!]!
  originalUnitPriceSet: MoneyBag!
  quantity: Int!
}
input FulfillmentOrderLineItemInput {
  id: ID!
  quantity: Int!
}
type FulfillmentOrderLineItemWarning {
  description: String
  title: String
}
input FulfillmentOrderLineItemsInput {
  fulfillmentOrderId: ID!
  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]
}
input FulfillmentOrderLineItemsPreparedForPickupInput {
  lineItemsByFulfillmentOrder: [PreparedFulfillmentOrderLineItemsInput!]!
}
type FulfillmentOrderLineItemsPreparedForPickupPayload {
  userErrors: [FulfillmentOrderLineItemsPreparedForPickupUserError!]!
}
type FulfillmentOrderLineItemsPreparedForPickupUserError {
  code: FulfillmentOrderLineItemsPreparedForPickupUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentOrderLineItemsPreparedForPickupUserErrorCode {
  NO_LINE_ITEMS_TO_PREPARE_FOR_FULFILLMENT_ORDER
  FULFILLMENT_ORDER_INVALID
  UNABLE_TO_PREPARE_QUANTITY
}
type FulfillmentOrderLocationForMove {
  availableLineItems: FulfillmentOrderLineItemConnection!
  availableLineItemsCount: Count
  location: Location!
  message: String
  movable: Boolean!
  unavailableLineItems: FulfillmentOrderLineItemConnection!
  unavailableLineItemsCount: Count
}
type FulfillmentOrderLocationForMoveConnection {
  edges: [FulfillmentOrderLocationForMoveEdge!]!
  nodes: [FulfillmentOrderLocationForMove!]!
  pageInfo: PageInfo!
}
type FulfillmentOrderLocationForMoveEdge {
  cursor: String!
  node: FulfillmentOrderLocationForMove!
}
type FulfillmentOrderMerchantRequest {
  fulfillmentOrder: FulfillmentOrder!
  id: ID!
  kind: FulfillmentOrderMerchantRequestKind!
  message: String
  requestOptions: JSON
  responseData: JSON
  sentAt: DateTime!
}
type FulfillmentOrderMerchantRequestConnection {
  edges: [FulfillmentOrderMerchantRequestEdge!]!
  nodes: [FulfillmentOrderMerchantRequest!]!
  pageInfo: PageInfo!
}
type FulfillmentOrderMerchantRequestEdge {
  cursor: String!
  node: FulfillmentOrderMerchantRequest!
}
enum FulfillmentOrderMerchantRequestKind {
  FULFILLMENT_REQUEST
  CANCELLATION_REQUEST
}
input FulfillmentOrderMergeInput {
  mergeIntents: [FulfillmentOrderMergeInputMergeIntent!]!
}
input FulfillmentOrderMergeInputMergeIntent {
  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]
  fulfillmentOrderId: ID!
}
type FulfillmentOrderMergePayload {
  fulfillmentOrderMerges: [FulfillmentOrderMergeResult!]
  userErrors: [FulfillmentOrderMergeUserError!]!
}
type FulfillmentOrderMergeResult {
  fulfillmentOrder: FulfillmentOrder!
}
type FulfillmentOrderMergeUserError {
  code: FulfillmentOrderMergeUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentOrderMergeUserErrorCode {
  FULFILLMENT_ORDER_NOT_FOUND
  GREATER_THAN
  INVALID_LINE_ITEM_QUANTITY
}
type FulfillmentOrderMovePayload {
  movedFulfillmentOrder: FulfillmentOrder
  originalFulfillmentOrder: FulfillmentOrder
  remainingFulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderOpenPayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderRejectCancellationRequestPayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderRejectFulfillmentRequestPayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
enum FulfillmentOrderRejectionReason {
  INCORRECT_ADDRESS
  INVENTORY_OUT_OF_STOCK
  INELIGIBLE_PRODUCT
  UNDELIVERABLE_DESTINATION
  OTHER
}
type FulfillmentOrderReleaseHoldPayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [FulfillmentOrderReleaseHoldUserError!]!
}
type FulfillmentOrderReleaseHoldUserError {
  code: FulfillmentOrderReleaseHoldUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentOrderReleaseHoldUserErrorCode {
  FULFILLMENT_ORDER_NOT_FOUND
  INVALID_ACCESS
}
enum FulfillmentOrderRequestStatus {
  UNSUBMITTED
  SUBMITTED
  ACCEPTED
  REJECTED
  CANCELLATION_REQUESTED
  CANCELLATION_ACCEPTED
  CANCELLATION_REJECTED
  CLOSED
}
type FulfillmentOrderReschedulePayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [FulfillmentOrderRescheduleUserError!]!
}
type FulfillmentOrderRescheduleUserError {
  code: FulfillmentOrderRescheduleUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentOrderRescheduleUserErrorCode {
  FULFILLMENT_ORDER_NOT_FOUND
}
enum FulfillmentOrderSortKeys {
  ID
  RELEVANCE
  UPDATED_AT
}
input FulfillmentOrderSplitInput {
  fulfillmentOrderLineItems: [FulfillmentOrderLineItemInput!]!
  fulfillmentOrderId: ID!
}
type FulfillmentOrderSplitPayload {
  fulfillmentOrderSplits: [FulfillmentOrderSplitResult!]
  userErrors: [FulfillmentOrderSplitUserError!]!
}
type FulfillmentOrderSplitResult {
  fulfillmentOrder: FulfillmentOrder!
  remainingFulfillmentOrder: FulfillmentOrder!
  replacementFulfillmentOrder: FulfillmentOrder
}
type FulfillmentOrderSplitUserError {
  code: FulfillmentOrderSplitUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentOrderSplitUserErrorCode {
  FULFILLMENT_ORDER_NOT_FOUND
  GREATER_THAN
  INVALID_LINE_ITEM_QUANTITY
  NO_LINE_ITEMS_PROVIDED_TO_SPLIT
}
enum FulfillmentOrderStatus {
  OPEN
  IN_PROGRESS
  CANCELLED
  INCOMPLETE
  CLOSED
  SCHEDULED
  ON_HOLD
}
type FulfillmentOrderSubmitCancellationRequestPayload {
  fulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderSubmitFulfillmentRequestPayload {
  originalFulfillmentOrder: FulfillmentOrder
  submittedFulfillmentOrder: FulfillmentOrder
  unsubmittedFulfillmentOrder: FulfillmentOrder
  userErrors: [UserError!]!
}
type FulfillmentOrderSupportedAction {
  action: FulfillmentOrderAction!
  externalUrl: URL
}
type FulfillmentOrdersSetFulfillmentDeadlinePayload {
  success: Boolean
  userErrors: [FulfillmentOrdersSetFulfillmentDeadlineUserError!]!
}
type FulfillmentOrdersSetFulfillmentDeadlineUserError {
  code: FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode
  field: [String!]
  message: String!
}
enum FulfillmentOrdersSetFulfillmentDeadlineUserErrorCode {
  FULFILLMENT_ORDERS_NOT_FOUND
}
type FulfillmentOriginAddress {
  address1: String
  address2: String
  city: String
  countryCode: String!
  provinceCode: String
  zip: String
}
input FulfillmentOriginAddressInput {
  address1: String
  address2: String
  city: String
  zip: String
  provinceCode: String
  countryCode: String!
}
type FulfillmentService {
  callbackUrl: URL
  fulfillmentOrdersOptIn: Boolean!
  handle: String!
  id: ID!
  inventoryManagement: Boolean!
  location: Location
  permitsSkuSharing: Boolean!
  serviceName: String!
  trackingSupport: Boolean!
  type: FulfillmentServiceType!
}
type FulfillmentServiceCreatePayload {
  fulfillmentService: FulfillmentService
  userErrors: [UserError!]!
}
enum FulfillmentServiceDeleteInventoryAction {
  DELETE
  KEEP
  TRANSFER
}
type FulfillmentServiceDeletePayload {
  deletedId: ID
  userErrors: [UserError!]!
}
enum FulfillmentServiceType {
  GIFT_CARD
  MANUAL
  THIRD_PARTY
}
type FulfillmentServiceUpdatePayload {
  fulfillmentService: FulfillmentService
  userErrors: [UserError!]!
}
enum FulfillmentStatus {
  PENDING
  OPEN
  SUCCESS
  CANCELLED
  ERROR
  FAILURE
}
type FulfillmentTrackingInfo {
  company: String
  number: String
  url: URL
}
type FulfillmentTrackingInfoUpdatePayload {
  fulfillment: Fulfillment
  userErrors: [UserError!]!
}
type FulfillmentTrackingInfoUpdateV2Payload {
  fulfillment: Fulfillment
  userErrors: [UserError!]!
}
input FulfillmentTrackingInput {
  number: String
  url: URL
  company: String
  numbers: [String!]
  urls: [URL!]
}
input FulfillmentV2Input {
  trackingInfo: FulfillmentTrackingInput
  notifyCustomer: Boolean
  lineItemsByFulfillmentOrder: [FulfillmentOrderLineItemsInput!]!
  originAddress: FulfillmentOriginAddressInput
}
type FunctionsAppBridge {
  createPath: String!
  detailsPath: String!
}
type FunctionsErrorHistory {
  errorsFirstOccurredAt: DateTime!
  firstOccurredAt: DateTime!
  hasBeenSharedSinceLastError: Boolean!
  hasSharedRecentErrors: Boolean!
}
type GenericFile {
  alt: String
  createdAt: DateTime!
  fileErrors: [FileError!]!
  fileStatus: FileStatus!
  id: ID!
  mimeType: String
  originalFileSize: Int
  preview: MediaPreviewImage
  updatedAt: DateTime!
  url: URL
}
type GiftCard {
  balance: MoneyV2!
  createdAt: DateTime!
  customer: Customer
  deactivatedAt: DateTime
  enabled: Boolean!
  expiresOn: Date
  id: ID!
  initialValue: MoneyV2!
  lastCharacters: String!
  maskedCode: String!
  note: String
  order: Order
  recipientAttributes: GiftCardRecipient
  templateSuffix: String
  transactions: GiftCardTransactionConnection
  updatedAt: DateTime!
}
type GiftCardConnection {
  edges: [GiftCardEdge!]!
  nodes: [GiftCard!]!
  pageInfo: PageInfo!
}
input GiftCardCreateInput {
  initialValue: Decimal!
  code: String
  customerId: ID
  expiresOn: Date
  note: String
  recipientAttributes: GiftCardRecipientInput
  templateSuffix: String
}
type GiftCardCreatePayload {
  giftCard: GiftCard
  giftCardCode: String
  userErrors: [GiftCardUserError!]!
}
input GiftCardCreditInput {
  creditAmount: MoneyInput!
  note: String
  processedAt: DateTime
}
type GiftCardCreditPayload {
  giftCardCreditTransaction: GiftCardCreditTransaction
  userErrors: [GiftCardTransactionUserError!]!
}
type GiftCardCreditTransaction {
  amount: MoneyV2!
  giftCard: GiftCard!
  id: ID!
  metafield: Metafield
  metafields: MetafieldConnection!
  note: String
  processedAt: DateTime!
}
type GiftCardDeactivatePayload {
  giftCard: GiftCard
  userErrors: [GiftCardDeactivateUserError!]!
}
type GiftCardDeactivateUserError {
  code: GiftCardDeactivateUserErrorCode
  field: [String!]
  message: String!
}
enum GiftCardDeactivateUserErrorCode {
  GIFT_CARD_NOT_FOUND
}
input GiftCardDebitInput {
  debitAmount: MoneyInput!
  note: String
  processedAt: DateTime
}
type GiftCardDebitPayload {
  giftCardDebitTransaction: GiftCardDebitTransaction
  userErrors: [GiftCardTransactionUserError!]!
}
type GiftCardDebitTransaction {
  amount: MoneyV2!
  giftCard: GiftCard!
  id: ID!
  metafield: Metafield
  metafields: MetafieldConnection!
  note: String
  processedAt: DateTime!
}
type GiftCardEdge {
  cursor: String!
  node: GiftCard!
}
enum GiftCardErrorCode {
  TOO_LONG
  TOO_SHORT
  TAKEN
  INVALID
  INTERNAL_ERROR
  MISSING_ARGUMENT
  GREATER_THAN
  GIFT_CARD_LIMIT_EXCEEDED
  CUSTOMER_NOT_FOUND
  RECIPIENT_NOT_FOUND
}
type GiftCardRecipient {
  message: String
  preferredName: String
  recipient: Customer!
  sendNotificationAt: DateTime
}
input GiftCardRecipientInput {
  id: ID!
  preferredName: String
  message: String
  sendNotificationAt: DateTime
}
type GiftCardSale {
  actionType: SaleActionType!
  id: ID!
  lineItem: LineItem!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
type GiftCardSendNotificationToCustomerPayload {
  giftCard: GiftCard
  userErrors: [GiftCardSendNotificationToCustomerUserError!]!
}
type GiftCardSendNotificationToCustomerUserError {
  code: GiftCardSendNotificationToCustomerUserErrorCode
  field: [String!]
  message: String!
}
enum GiftCardSendNotificationToCustomerUserErrorCode {
  INVALID
  CUSTOMER_NOT_FOUND
  GIFT_CARD_NOT_FOUND
}
type GiftCardSendNotificationToRecipientPayload {
  giftCard: GiftCard
  userErrors: [GiftCardSendNotificationToRecipientUserError!]!
}
type GiftCardSendNotificationToRecipientUserError {
  code: GiftCardSendNotificationToRecipientUserErrorCode
  field: [String!]
  message: String!
}
enum GiftCardSendNotificationToRecipientUserErrorCode {
  INVALID
  RECIPIENT_NOT_FOUND
  GIFT_CARD_NOT_FOUND
}
enum GiftCardSortKeys {
  AMOUNT_SPENT
  BALANCE
  CODE
  CREATED_AT
  CUSTOMER_NAME
  DISABLED_AT
  EXPIRES_ON
  ID
  INITIAL_VALUE
  RELEVANCE
  UPDATED_AT
}
interface GiftCardTransaction {
  amount: MoneyV2!
  giftCard: GiftCard!
  id: ID!
  metafield: Metafield
  metafields: MetafieldConnection!
  note: String
  processedAt: DateTime!
}
type GiftCardTransactionConnection {
  edges: [GiftCardTransactionEdge!]!
  nodes: [GiftCardTransaction!]!
  pageInfo: PageInfo!
}
type GiftCardTransactionEdge {
  cursor: String!
  node: GiftCardTransaction!
}
type GiftCardTransactionUserError {
  code: GiftCardTransactionUserErrorCode
  field: [String!]
  message: String!
}
enum GiftCardTransactionUserErrorCode {
  INVALID
  INTERNAL_ERROR
  GIFT_CARD_LIMIT_EXCEEDED
  GIFT_CARD_NOT_FOUND
  NEGATIVE_OR_ZERO_AMOUNT
  INSUFFICIENT_FUNDS
  MISMATCHING_CURRENCY
}
input GiftCardUpdateInput {
  note: String
  expiresOn: Date
  customerId: ID
  recipientAttributes: GiftCardRecipientInput
  templateSuffix: String
}
type GiftCardUpdatePayload {
  giftCard: GiftCard
  userErrors: [UserError!]!
}
type GiftCardUserError {
  code: GiftCardErrorCode
  field: [String!]
  message: String!
}
scalar HTML
interface HasCompareDigest {
  compareDigest: String!
}
interface HasEvents {
  events: EventConnection!
}
interface HasLocalizationExtensions {
  localizationExtensions: LocalizationExtensionConnection!
}
interface HasLocalizedFields {
  localizedFields: LocalizedFieldConnection!
}
interface HasMetafieldDefinitions {
  metafieldDefinitions: MetafieldDefinitionConnection!
}
interface HasMetafields {
  metafield: Metafield
  metafields: MetafieldConnection!
}
interface HasPublishedTranslations {
  translations: [Translation!]!
}
interface HasStoreCreditAccounts {
  storeCreditAccounts: StoreCreditAccountConnection!
}
scalar ID
type Image {
  altText: String
  height: Int
  id: ID
  metafield: Metafield
  metafields: MetafieldConnection!
  originalSrc: URL!
  src: URL!
  transformedSrc: URL!
  url: URL!
  width: Int
}
type ImageConnection {
  edges: [ImageEdge!]!
  nodes: [Image!]!
  pageInfo: PageInfo!
}
enum ImageContentType {
  PNG
  JPG
  WEBP
}
type ImageEdge {
  cursor: String!
  node: Image!
}
input ImageInput {
  id: ID
  altText: String
  src: String
}
input ImageTransformInput {
  crop: CropRegion
  maxWidth: Int
  maxHeight: Int
  scale: Int
  preferredContentType: ImageContentType
}
type ImageUploadParameter {
  name: String!
  value: String!
}
input IncomingRequestLineItemInput {
  fulfillmentOrderLineItemId: ID!
  message: String
}
scalar Int
type InventoryActivatePayload {
  inventoryLevel: InventoryLevel
  userErrors: [UserError!]!
}
input InventoryAdjustQuantitiesInput {
  reason: String!
  name: String!
  referenceDocumentUri: String
  changes: [InventoryChangeInput!]!
}
type InventoryAdjustQuantitiesPayload {
  inventoryAdjustmentGroup: InventoryAdjustmentGroup
  userErrors: [InventoryAdjustQuantitiesUserError!]!
}
type InventoryAdjustQuantitiesUserError {
  code: InventoryAdjustQuantitiesUserErrorCode
  field: [String!]
  message: String!
}
enum InventoryAdjustQuantitiesUserErrorCode {
  INTERNAL_LEDGER_DOCUMENT
  INVALID_AVAILABLE_DOCUMENT
  INVALID_INVENTORY_ITEM
  INVALID_LEDGER_DOCUMENT
  INVALID_LOCATION
  INVALID_QUANTITY_DOCUMENT
  INVALID_QUANTITY_NAME
  INVALID_QUANTITY_TOO_LOW
  INVALID_QUANTITY_TOO_HIGH
  INVALID_REASON
  INVALID_REFERENCE_DOCUMENT
  ADJUST_QUANTITIES_FAILED
  MAX_ONE_LEDGER_DOCUMENT
  ITEM_NOT_STOCKED_AT_LOCATION
  NON_MUTABLE_INVENTORY_ITEM
}
type InventoryAdjustmentGroup {
  app: App
  changes: [InventoryChange!]!
  createdAt: DateTime!
  id: ID!
  reason: String!
  referenceDocumentUri: String
  staffMember: StaffMember
}
input InventoryBulkToggleActivationInput {
  locationId: ID!
  activate: Boolean!
}
type InventoryBulkToggleActivationPayload {
  inventoryItem: InventoryItem
  inventoryLevels: [InventoryLevel!]
  userErrors: [InventoryBulkToggleActivationUserError!]!
}
type InventoryBulkToggleActivationUserError {
  code: InventoryBulkToggleActivationUserErrorCode
  field: [String!]
  message: String!
}
enum InventoryBulkToggleActivationUserErrorCode {
  GENERIC_ERROR
  CANNOT_DEACTIVATE_FROM_ONLY_LOCATION
  COMMITTED_AND_INCOMING_INVENTORY_AT_LOCATION
  INCOMING_INVENTORY_AT_LOCATION
  COMMITTED_INVENTORY_AT_LOCATION
  RESERVED_INVENTORY_AT_LOCATION
  FAILED_TO_UNSTOCK_FROM_LOCATION
  INVENTORY_MANAGED_BY_3RD_PARTY
  INVENTORY_MANAGED_BY_SHOPIFY
  FAILED_TO_STOCK_AT_LOCATION
  MISSING_SKU
  LOCATION_NOT_FOUND
  INVENTORY_ITEM_NOT_FOUND
}
type InventoryChange {
  delta: Int!
  item: InventoryItem
  ledgerDocumentUri: String
  location: Location
  name: String!
  quantityAfterChange: Int
}
input InventoryChangeInput {
  delta: Int!
  inventoryItemId: ID!
  locationId: ID!
  ledgerDocumentUri: String
}
type InventoryDeactivatePayload {
  userErrors: [UserError!]!
}
type InventoryItem {
  countryCodeOfOrigin: CountryCode
  countryHarmonizedSystemCodes: CountryHarmonizedSystemCodeConnection!
  createdAt: DateTime!
  duplicateSkuCount: Int!
  harmonizedSystemCode: String
  id: ID!
  inventoryHistoryUrl: URL
  inventoryLevel: InventoryLevel
  inventoryLevels: InventoryLevelConnection!
  legacyResourceId: UnsignedInt64!
  locationsCount: Count
  measurement: InventoryItemMeasurement!
  provinceCodeOfOrigin: String
  requiresShipping: Boolean!
  sku: String
  tracked: Boolean!
  trackedEditable: EditableProperty!
  unitCost: MoneyV2
  updatedAt: DateTime!
  variant: ProductVariant!
}
type InventoryItemConnection {
  edges: [InventoryItemEdge!]!
  nodes: [InventoryItem!]!
  pageInfo: PageInfo!
}
type InventoryItemEdge {
  cursor: String!
  node: InventoryItem!
}
input InventoryItemInput {
  sku: String
  cost: Decimal
  tracked: Boolean
  countryCodeOfOrigin: CountryCode
  harmonizedSystemCode: String
  countryHarmonizedSystemCodes: [CountryHarmonizedSystemCodeInput!]
  provinceCodeOfOrigin: String
  measurement: InventoryItemMeasurementInput
  requiresShipping: Boolean
}
type InventoryItemMeasurement {
  id: ID!
  weight: Weight
}
input InventoryItemMeasurementInput {
  weight: WeightInput
}
type InventoryItemUpdatePayload {
  inventoryItem: InventoryItem
  userErrors: [UserError!]!
}
type InventoryLevel {
  canDeactivate: Boolean!
  createdAt: DateTime!
  deactivationAlert: String
  id: ID!
  item: InventoryItem!
  location: Location!
  quantities: [InventoryQuantity!]!
  scheduledChanges: InventoryScheduledChangeConnection!
  updatedAt: DateTime!
}
type InventoryLevelConnection {
  edges: [InventoryLevelEdge!]!
  nodes: [InventoryLevel!]!
  pageInfo: PageInfo!
}
type InventoryLevelEdge {
  cursor: String!
  node: InventoryLevel!
}
input InventoryLevelInput {
  availableQuantity: Int!
  locationId: ID!
}
input InventoryMoveQuantitiesInput {
  reason: String!
  referenceDocumentUri: String!
  changes: [InventoryMoveQuantityChange!]!
}
type InventoryMoveQuantitiesPayload {
  inventoryAdjustmentGroup: InventoryAdjustmentGroup
  userErrors: [InventoryMoveQuantitiesUserError!]!
}
type InventoryMoveQuantitiesUserError {
  code: InventoryMoveQuantitiesUserErrorCode
  field: [String!]
  message: String!
}
enum InventoryMoveQuantitiesUserErrorCode {
  INTERNAL_LEDGER_DOCUMENT
  INVALID_AVAILABLE_DOCUMENT
  INVALID_INVENTORY_ITEM
  INVALID_LEDGER_DOCUMENT
  INVALID_LOCATION
  INVALID_QUANTITY_DOCUMENT
  INVALID_QUANTITY_NAME
  INVALID_QUANTITY_NEGATIVE
  INVALID_QUANTITY_TOO_HIGH
  INVALID_REASON
  INVALID_REFERENCE_DOCUMENT
  MOVE_QUANTITIES_FAILED
  DIFFERENT_LOCATIONS
  SAME_QUANTITY_NAME
  MAXIMUM_LEDGER_DOCUMENT_URIS
  ITEM_NOT_STOCKED_AT_LOCATION
  NON_MUTABLE_INVENTORY_ITEM
}
input InventoryMoveQuantityChange {
  inventoryItemId: ID!
  quantity: Int!
  from: InventoryMoveQuantityTerminalInput!
  to: InventoryMoveQuantityTerminalInput!
}
input InventoryMoveQuantityTerminalInput {
  locationId: ID!
  name: String!
  ledgerDocumentUri: String
}
type InventoryProperties {
  quantityNames: [InventoryQuantityName!]!
}
type InventoryQuantity {
  id: ID!
  name: String!
  quantity: Int!
  updatedAt: DateTime
}
input InventoryQuantityInput {
  inventoryItemId: ID!
  locationId: ID!
  quantity: Int!
  compareQuantity: Int
}
type InventoryQuantityName {
  belongsTo: [String!]!
  comprises: [String!]!
  displayName: String
  isInUse: Boolean!
  name: String!
}
type InventoryScheduledChange {
  expectedAt: DateTime!
  fromName: String!
  inventoryLevel: InventoryLevel!
  ledgerDocumentUri: URL!
  quantity: Int!
  toName: String!
}
type InventoryScheduledChangeConnection {
  edges: [InventoryScheduledChangeEdge!]!
  nodes: [InventoryScheduledChange!]!
  pageInfo: PageInfo!
}
type InventoryScheduledChangeEdge {
  cursor: String!
  node: InventoryScheduledChange!
}
input InventoryScheduledChangeInput {
  expectedAt: DateTime!
  fromName: String!
  toName: String!
}
input InventoryScheduledChangeItemInput {
  inventoryItemId: ID!
  locationId: ID!
  ledgerDocumentUri: URL!
  scheduledChanges: [InventoryScheduledChangeInput!]!
}
input InventorySetOnHandQuantitiesInput {
  reason: String!
  referenceDocumentUri: String
  setQuantities: [InventorySetQuantityInput!]!
}
type InventorySetOnHandQuantitiesPayload {
  inventoryAdjustmentGroup: InventoryAdjustmentGroup
  userErrors: [InventorySetOnHandQuantitiesUserError!]!
}
type InventorySetOnHandQuantitiesUserError {
  code: InventorySetOnHandQuantitiesUserErrorCode
  field: [String!]
  message: String!
}
enum InventorySetOnHandQuantitiesUserErrorCode {
  INVALID_INVENTORY_ITEM
  INVALID_LOCATION
  INVALID_QUANTITY_NEGATIVE
  INVALID_REASON
  INVALID_REFERENCE_DOCUMENT
  SET_ON_HAND_QUANTITIES_FAILED
  ITEM_NOT_STOCKED_AT_LOCATION
  NON_MUTABLE_INVENTORY_ITEM
  INVALID_QUANTITY_TOO_HIGH
}
input InventorySetQuantitiesInput {
  reason: String!
  name: String!
  referenceDocumentUri: String
  quantities: [InventoryQuantityInput!]!
  ignoreCompareQuantity: Boolean
}
type InventorySetQuantitiesPayload {
  inventoryAdjustmentGroup: InventoryAdjustmentGroup
  userErrors: [InventorySetQuantitiesUserError!]!
}
type InventorySetQuantitiesUserError {
  code: InventorySetQuantitiesUserErrorCode
  field: [String!]
  message: String!
}
enum InventorySetQuantitiesUserErrorCode {
  INVALID_INVENTORY_ITEM
  INVALID_LOCATION
  INVALID_QUANTITY_NEGATIVE
  INVALID_REASON
  INVALID_REFERENCE_DOCUMENT
  ITEM_NOT_STOCKED_AT_LOCATION
  INVALID_QUANTITY_TOO_HIGH
  INVALID_QUANTITY_TOO_LOW
  COMPARE_QUANTITY_REQUIRED
  COMPARE_QUANTITY_STALE
  INVALID_NAME
  NO_DUPLICATE_INVENTORY_ITEM_ID_GROUP_ID_PAIR
  NON_MUTABLE_INVENTORY_ITEM
}
input InventorySetQuantityInput {
  inventoryItemId: ID!
  locationId: ID!
  quantity: Int!
}
input InventorySetScheduledChangesInput {
  reason: String!
  items: [InventoryScheduledChangeItemInput!]!
  referenceDocumentUri: URL!
}
type InventorySetScheduledChangesPayload {
  scheduledChanges: [InventoryScheduledChange!]
  userErrors: [InventorySetScheduledChangesUserError!]!
}
type InventorySetScheduledChangesUserError {
  code: InventorySetScheduledChangesUserErrorCode
  field: [String!]
  message: String!
}
enum InventorySetScheduledChangesUserErrorCode {
  ERROR_UPDATING_SCHEDULED
  SAME_FROM_TO_NAMES
  INVALID_FROM_NAME
  INVALID_TO_NAME
  DUPLICATE_TO_NAME
  INVALID_REASON
  DUPLICATE_FROM_NAME
  LOCATION_NOT_FOUND
  INVENTORY_STATE_NOT_FOUND
  ITEMS_EMPTY
  INVENTORY_ITEM_NOT_FOUND
  INCLUSION
  LEDGER_DOCUMENT_INVALID
}
scalar JSON
type Job {
  done: Boolean!
  id: ID!
  query: QueryRoot
}
interface JobResult {
  done: Boolean!
  id: ID!
}
enum LanguageCode {
  AF
  AK
  AM
  AR
  AS
  AZ
  BE
  BG
  BM
  BN
  BO
  BR
  BS
  CA
  CE
  CKB
  CS
  CY
  DA
  DE
  DZ
  EE
  EL
  EN
  EO
  ES
  ET
  EU
  FA
  FF
  FI
  FIL
  FO
  FR
  FY
  GA
  GD
  GL
  GU
  GV
  HA
  HE
  HI
  HR
  HU
  HY
  IA
  ID
  IG
  II
  IS
  IT
  JA
  JV
  KA
  KI
  KK
  KL
  KM
  KN
  KO
  KS
  KU
  KW
  KY
  LB
  LG
  LN
  LO
  LT
  LU
  LV
  MG
  MI
  MK
  ML
  MN
  MR
  MS
  MT
  MY
  NB
  ND
  NE
  NL
  NN
  NO
  OM
  OR
  OS
  PA
  PL
  PS
  PT_BR
  PT_PT
  QU
  RM
  RN
  RO
  RU
  RW
  SA
  SC
  SD
  SE
  SG
  SI
  SK
  SL
  SN
  SO
  SQ
  SR
  SU
  SV
  SW
  TA
  TE
  TG
  TH
  TI
  TK
  TO
  TR
  TT
  UG
  UK
  UR
  UZ
  VI
  WO
  XH
  YI
  YO
  ZH_CN
  ZH_TW
  ZU
  ZH
  PT
  CU
  VO
}
interface LegacyInteroperability {
  legacyResourceId: UnsignedInt64!
}
enum LengthUnit {
  MILLIMETERS
  CENTIMETERS
  METERS
  INCHES
  FEET
  YARDS
}
type LimitedPendingOrderCount {
  atMax: Boolean!
  count: Int!
}
type LineItem {
  canRestock: Boolean!
  contract: SubscriptionContract
  currentQuantity: Int!
  customAttributes: [Attribute!]!
  discountAllocations: [DiscountAllocation!]!
  discountedTotal: Money!
  discountedTotalSet: MoneyBag!
  discountedUnitPrice: Money!
  discountedUnitPriceAfterAllDiscountsSet: MoneyBag!
  discountedUnitPriceSet: MoneyBag!
  duties: [Duty!]!
  fulfillableQuantity: Int!
  fulfillmentService: FulfillmentService
  fulfillmentStatus: String!
  id: ID!
  image: Image
  isGiftCard: Boolean!
  lineItemGroup: LineItemGroup
  merchantEditable: Boolean!
  name: String!
  nonFulfillableQuantity: Int!
  originalTotal: Money!
  originalTotalSet: MoneyBag!
  originalUnitPrice: Money!
  originalUnitPriceSet: MoneyBag!
  product: Product
  quantity: Int!
  refundableQuantity: Int!
  requiresShipping: Boolean!
  restockable: Boolean!
  sellingPlan: LineItemSellingPlan
  sku: String
  staffMember: StaffMember
  taxLines: [TaxLine!]!
  taxable: Boolean!
  title: String!
  totalDiscount: Money!
  totalDiscountSet: MoneyBag!
  unfulfilledDiscountedTotal: Money!
  unfulfilledDiscountedTotalSet: MoneyBag!
  unfulfilledOriginalTotal: Money!
  unfulfilledOriginalTotalSet: MoneyBag!
  unfulfilledQuantity: Int!
  variant: ProductVariant
  variantTitle: String
  vendor: String
}
type LineItemConnection {
  edges: [LineItemEdge!]!
  nodes: [LineItem!]!
  pageInfo: PageInfo!
}
type LineItemEdge {
  cursor: String!
  node: LineItem!
}
type LineItemGroup {
  customAttributes: [Attribute!]!
  id: ID!
  quantity: Int!
  title: String!
  variantId: ID
  variantSku: String
}
type LineItemSellingPlan {
  name: String!
  sellingPlanId: ID
}
type Link {
  label: String!
  translations: [Translation!]!
  url: URL!
}
type LinkedMetafield {
  key: String
  namespace: String
}
input LinkedMetafieldCreateInput {
  namespace: String!
  key: String!
  values: [String!]
}
input LinkedMetafieldInput {
  namespace: String!
  key: String!
  values: [String!]!
}
input LinkedMetafieldUpdateInput {
  namespace: String!
  key: String!
}
type LocalPaymentMethodsPaymentDetails {
  paymentDescriptor: String
  paymentMethodName: String
}
type Locale {
  isoCode: String!
  name: String!
}
enum LocalizableContentType {
  JSON_STRING
  JSON
  LIST_MULTI_LINE_TEXT_FIELD
  LIST_SINGLE_LINE_TEXT_FIELD
  LIST_URL
  MULTI_LINE_TEXT_FIELD
  RICH_TEXT_FIELD
  SINGLE_LINE_TEXT_FIELD
  STRING
  URL
  LINK
  LIST_LINK
  FILE_REFERENCE
  LIST_FILE_REFERENCE
  HTML
  URI
  INLINE_RICH_TEXT
}
type LocalizationExtension {
  countryCode: CountryCode!
  key: LocalizationExtensionKey!
  purpose: LocalizationExtensionPurpose!
  title: String!
  value: String!
}
type LocalizationExtensionConnection {
  edges: [LocalizationExtensionEdge!]!
  nodes: [LocalizationExtension!]!
  pageInfo: PageInfo!
}
type LocalizationExtensionEdge {
  cursor: String!
  node: LocalizationExtension!
}
input LocalizationExtensionInput {
  key: LocalizationExtensionKey!
  value: String!
}
enum LocalizationExtensionKey {
  TAX_CREDENTIAL_BR
  SHIPPING_CREDENTIAL_BR
  TAX_CREDENTIAL_CL
  SHIPPING_CREDENTIAL_CL
  SHIPPING_CREDENTIAL_CN
  TAX_CREDENTIAL_CO
  TAX_CREDENTIAL_TYPE_CO
  SHIPPING_CREDENTIAL_CO
  SHIPPING_CREDENTIAL_TYPE_CO
  TAX_CREDENTIAL_CR
  SHIPPING_CREDENTIAL_CR
  TAX_CREDENTIAL_EC
  SHIPPING_CREDENTIAL_EC
  TAX_CREDENTIAL_GT
  SHIPPING_CREDENTIAL_GT
  TAX_CREDENTIAL_ID
  SHIPPING_CREDENTIAL_ID
  TAX_CREDENTIAL_IT
  TAX_EMAIL_IT
  TAX_CREDENTIAL_MY
  SHIPPING_CREDENTIAL_MY
  SHIPPING_CREDENTIAL_MX
  TAX_CREDENTIAL_MX
  TAX_CREDENTIAL_TYPE_MX
  TAX_CREDENTIAL_USE_MX
  TAX_CREDENTIAL_PY
  SHIPPING_CREDENTIAL_PY
  TAX_CREDENTIAL_PE
  SHIPPING_CREDENTIAL_PE
  TAX_CREDENTIAL_PT
  SHIPPING_CREDENTIAL_PT
  SHIPPING_CREDENTIAL_KR
  TAX_CREDENTIAL_ES
  SHIPPING_CREDENTIAL_ES
  SHIPPING_CREDENTIAL_TW
  TAX_CREDENTIAL_TR
  SHIPPING_CREDENTIAL_TR
}
enum LocalizationExtensionPurpose {
  SHIPPING
  TAX
}
type LocalizedField {
  countryCode: CountryCode!
  key: LocalizedFieldKey!
  purpose: LocalizedFieldPurpose!
  title: String!
  value: String!
}
type LocalizedFieldConnection {
  edges: [LocalizedFieldEdge!]!
  nodes: [LocalizedField!]!
  pageInfo: PageInfo!
}
type LocalizedFieldEdge {
  cursor: String!
  node: LocalizedField!
}
input LocalizedFieldInput {
  key: LocalizedFieldKey!
  value: String!
}
enum LocalizedFieldKey {
  TAX_CREDENTIAL_BR
  SHIPPING_CREDENTIAL_BR
  TAX_CREDENTIAL_CL
  SHIPPING_CREDENTIAL_CL
  SHIPPING_CREDENTIAL_CN
  TAX_CREDENTIAL_CO
  TAX_CREDENTIAL_TYPE_CO
  SHIPPING_CREDENTIAL_CO
  SHIPPING_CREDENTIAL_TYPE_CO
  TAX_CREDENTIAL_CR
  SHIPPING_CREDENTIAL_CR
  TAX_CREDENTIAL_EC
  SHIPPING_CREDENTIAL_EC
  TAX_CREDENTIAL_GT
  SHIPPING_CREDENTIAL_GT
  TAX_CREDENTIAL_ID
  SHIPPING_CREDENTIAL_ID
  TAX_CREDENTIAL_IT
  TAX_EMAIL_IT
  TAX_CREDENTIAL_MY
  SHIPPING_CREDENTIAL_MY
  SHIPPING_CREDENTIAL_MX
  TAX_CREDENTIAL_MX
  TAX_CREDENTIAL_TYPE_MX
  TAX_CREDENTIAL_USE_MX
  TAX_CREDENTIAL_PY
  SHIPPING_CREDENTIAL_PY
  TAX_CREDENTIAL_PE
  SHIPPING_CREDENTIAL_PE
  TAX_CREDENTIAL_PT
  SHIPPING_CREDENTIAL_PT
  SHIPPING_CREDENTIAL_KR
  TAX_CREDENTIAL_ES
  SHIPPING_CREDENTIAL_ES
  SHIPPING_CREDENTIAL_TW
  TAX_CREDENTIAL_TR
  SHIPPING_CREDENTIAL_TR
}
enum LocalizedFieldPurpose {
  SHIPPING
  TAX
}
type Location {
  activatable: Boolean!
  address: LocationAddress!
  addressVerified: Boolean!
  createdAt: DateTime!
  deactivatable: Boolean!
  deactivatedAt: String
  deletable: Boolean!
  fulfillmentService: FulfillmentService
  fulfillsOnlineOrders: Boolean!
  hasActiveInventory: Boolean!
  hasUnfulfilledOrders: Boolean!
  id: ID!
  inventoryLevel: InventoryLevel
  inventoryLevels: InventoryLevelConnection!
  isActive: Boolean!
  isFulfillmentService: Boolean!
  isPrimary: Boolean!
  legacyResourceId: UnsignedInt64!
  localPickupSettingsV2: DeliveryLocalPickupSettings
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  name: String!
  shipsInventory: Boolean!
  suggestedAddresses: [LocationSuggestedAddress!]!
  updatedAt: DateTime!
}
type LocationActivatePayload {
  location: Location
  locationActivateUserErrors: [LocationActivateUserError!]!
}
type LocationActivateUserError {
  code: LocationActivateUserErrorCode
  field: [String!]
  message: String!
}
enum LocationActivateUserErrorCode {
  GENERIC_ERROR
  LOCATION_LIMIT
  HAS_ONGOING_RELOCATION
  LOCATION_NOT_FOUND
  HAS_NON_UNIQUE_NAME
}
input LocationAddAddressInput {
  address1: String
  address2: String
  city: String
  phone: String
  zip: String
  countryCode: CountryCode!
  provinceCode: String
}
input LocationAddInput {
  name: String!
  address: LocationAddAddressInput!
  fulfillsOnlineOrders: Boolean
  metafields: [MetafieldInput!]
}
type LocationAddPayload {
  location: Location
  userErrors: [LocationAddUserError!]!
}
type LocationAddUserError {
  code: LocationAddUserErrorCode
  field: [String!]
  message: String!
}
enum LocationAddUserErrorCode {
  INVALID
  TOO_LONG
  TAKEN
  BLANK
  INVALID_US_ZIPCODE
  GENERIC_ERROR
  INVALID_TYPE
  INVALID_VALUE
  APP_NOT_AUTHORIZED
  UNSTRUCTURED_RESERVED_NAMESPACE
  DISALLOWED_OWNER_TYPE
  INCLUSION
  PRESENT
  TOO_SHORT
  CAPABILITY_VIOLATION
  INTERNAL_ERROR
}
type LocationAddress {
  address1: String
  address2: String
  city: String
  country: String
  countryCode: String
  formatted: [String!]!
  latitude: Float
  longitude: Float
  phone: String
  province: String
  provinceCode: String
  zip: String
}
type LocationConnection {
  edges: [LocationEdge!]!
  nodes: [Location!]!
  pageInfo: PageInfo!
}
type LocationDeactivatePayload {
  location: Location
  locationDeactivateUserErrors: [LocationDeactivateUserError!]!
}
type LocationDeactivateUserError {
  code: LocationDeactivateUserErrorCode
  field: [String!]
  message: String!
}
enum LocationDeactivateUserErrorCode {
  LOCATION_NOT_FOUND
  PERMANENTLY_BLOCKED_FROM_DEACTIVATION_ERROR
  TEMPORARILY_BLOCKED_FROM_DEACTIVATION_ERROR
  HAS_ACTIVE_RETAIL_SUBSCRIPTIONS
  DESTINATION_LOCATION_IS_THE_SAME_LOCATION
  DESTINATION_LOCATION_NOT_FOUND_OR_INACTIVE
  HAS_ACTIVE_INVENTORY_ERROR
  HAS_FULFILLMENT_ORDERS_ERROR
  HAS_INCOMING_MOVEMENTS_ERROR
  HAS_OPEN_PURCHASE_ORDERS_ERROR
  FAILED_TO_RELOCATE_ACTIVE_INVENTORIES
  FAILED_TO_RELOCATE_OPEN_PURCHASE_ORDERS
  FAILED_TO_RELOCATE_INCOMING_MOVEMENTS
  CANNOT_DISABLE_ONLINE_ORDER_FULFILLMENT
}
type LocationDeletePayload {
  deletedLocationId: ID
  locationDeleteUserErrors: [LocationDeleteUserError!]!
}
type LocationDeleteUserError {
  code: LocationDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum LocationDeleteUserErrorCode {
  LOCATION_NOT_FOUND
  LOCATION_IS_ACTIVE
  GENERIC_ERROR
  LOCATION_HAS_INVENTORY
  LOCATION_HAS_PENDING_ORDERS
  LOCATION_HAS_ACTIVE_RETAIL_SUBSCRIPTION
}
type LocationEdge {
  cursor: String!
  node: Location!
}
input LocationEditAddressInput {
  address1: String
  address2: String
  city: String
  phone: String
  zip: String
  countryCode: CountryCode
  provinceCode: String
}
input LocationEditInput {
  name: String
  address: LocationEditAddressInput
  fulfillsOnlineOrders: Boolean
  metafields: [MetafieldInput!]
}
type LocationEditPayload {
  location: Location
  userErrors: [LocationEditUserError!]!
}
type LocationEditUserError {
  code: LocationEditUserErrorCode
  field: [String!]
  message: String!
}
enum LocationEditUserErrorCode {
  TOO_LONG
  BLANK
  NOT_FOUND
  INVALID
  TAKEN
  INVALID_US_ZIPCODE
  GENERIC_ERROR
  CANNOT_DISABLE_ONLINE_ORDER_FULFILLMENT
  CANNOT_MODIFY_ONLINE_ORDER_FULFILLMENT_FOR_FS_LOCATION
  INVALID_TYPE
  INVALID_VALUE
  APP_NOT_AUTHORIZED
  UNSTRUCTURED_RESERVED_NAMESPACE
  DISALLOWED_OWNER_TYPE
  INCLUSION
  PRESENT
  TOO_SHORT
  CAPABILITY_VIOLATION
  INTERNAL_ERROR
}
type LocationLocalPickupDisablePayload {
  locationId: ID
  userErrors: [DeliveryLocationLocalPickupSettingsError!]!
}
type LocationLocalPickupEnablePayload {
  localPickupSettings: DeliveryLocalPickupSettings
  userErrors: [DeliveryLocationLocalPickupSettingsError!]!
}
enum LocationSortKeys {
  ID
  NAME
  RELEVANCE
}
type LocationSuggestedAddress {
  address1: String
  address2: String
  city: String
  country: String
  countryCode: CountryCode
  formatted: [String!]!
  province: String
  provinceCode: String
  zip: String
}
type MailingAddress {
  address1: String
  address2: String
  city: String
  company: String
  coordinatesValidated: Boolean!
  country: String
  countryCode: String
  countryCodeV2: CountryCode
  firstName: String
  formatted: [String!]!
  formattedArea: String
  id: ID!
  lastName: String
  latitude: Float
  longitude: Float
  name: String
  phone: String
  province: String
  provinceCode: String
  timeZone: String
  validationResultSummary: MailingAddressValidationResult
  zip: String
}
type MailingAddressConnection {
  edges: [MailingAddressEdge!]!
  nodes: [MailingAddress!]!
  pageInfo: PageInfo!
}
type MailingAddressEdge {
  cursor: String!
  node: MailingAddress!
}
input MailingAddressInput {
  address1: String
  address2: String
  city: String
  company: String
  countryCode: CountryCode
  firstName: String
  lastName: String
  phone: String
  provinceCode: String
  zip: String
}
enum MailingAddressValidationResult {
  NO_ISSUES
  ERROR
  WARNING
}
type ManualDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  description: String
  index: Int!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  title: String!
  value: PricingValue!
}
type Market {
  catalogs: MarketCatalogConnection!
  catalogsCount: Count
  currencySettings: MarketCurrencySettings!
  enabled: Boolean!
  handle: String!
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  name: String!
  priceList: PriceList
  primary: Boolean!
  regions: MarketRegionConnection!
  webPresence: MarketWebPresence
  webPresences: MarketWebPresenceConnection!
}
type MarketCatalog {
  id: ID!
  markets: MarketConnection!
  operations: [ResourceOperation!]!
  priceList: PriceList
  publication: Publication
  status: CatalogStatus!
  title: String!
}
type MarketCatalogConnection {
  edges: [MarketCatalogEdge!]!
  nodes: [MarketCatalog!]!
  pageInfo: PageInfo!
}
type MarketCatalogEdge {
  cursor: String!
  node: MarketCatalog!
}
type MarketConnection {
  edges: [MarketEdge!]!
  nodes: [Market!]!
  pageInfo: PageInfo!
}
input MarketCreateInput {
  name: String!
  handle: String
  enabled: Boolean
  regions: [MarketRegionCreateInput!]!
}
type MarketCreatePayload {
  market: Market
  userErrors: [MarketUserError!]!
}
type MarketCurrencySettings {
  baseCurrency: CurrencySetting!
  localCurrencies: Boolean!
}
input MarketCurrencySettingsUpdateInput {
  baseCurrency: CurrencyCode
  localCurrencies: Boolean
}
type MarketCurrencySettingsUpdatePayload {
  market: Market
  userErrors: [MarketCurrencySettingsUserError!]!
}
type MarketCurrencySettingsUserError {
  code: MarketCurrencySettingsUserErrorCode
  field: [String!]
  message: String!
}
enum MarketCurrencySettingsUserErrorCode {
  MARKET_NOT_FOUND
  MANAGED_MARKET
  MULTIPLE_CURRENCIES_NOT_SUPPORTED
  NO_LOCAL_CURRENCIES_ON_SINGLE_COUNTRY_MARKET
  UNSUPPORTED_CURRENCY
  PRIMARY_MARKET_USES_SHOP_CURRENCY
}
type MarketDeletePayload {
  deletedId: ID
  userErrors: [MarketUserError!]!
}
type MarketEdge {
  cursor: String!
  node: Market!
}
type MarketLocalizableContent {
  digest: String
  key: String!
  value: String
}
type MarketLocalizableResource {
  marketLocalizableContent: [MarketLocalizableContent!]!
  marketLocalizations: [MarketLocalization!]!
  resourceId: ID!
}
type MarketLocalizableResourceConnection {
  edges: [MarketLocalizableResourceEdge!]!
  nodes: [MarketLocalizableResource!]!
  pageInfo: PageInfo!
}
type MarketLocalizableResourceEdge {
  cursor: String!
  node: MarketLocalizableResource!
}
enum MarketLocalizableResourceType {
  METAFIELD
  METAOBJECT
}
type MarketLocalization {
  key: String!
  market: Market!
  outdated: Boolean!
  updatedAt: DateTime
  value: String
}
input MarketLocalizationRegisterInput {
  marketId: ID!
  key: String!
  value: String!
  marketLocalizableContentDigest: String!
}
type MarketLocalizationsRegisterPayload {
  marketLocalizations: [MarketLocalization!]
  userErrors: [TranslationUserError!]!
}
type MarketLocalizationsRemovePayload {
  marketLocalizations: [MarketLocalization!]
  userErrors: [TranslationUserError!]!
}
interface MarketRegion {
  id: ID!
  name: String!
}
type MarketRegionConnection {
  edges: [MarketRegionEdge!]!
  nodes: [MarketRegion!]!
  pageInfo: PageInfo!
}
type MarketRegionCountry {
  code: CountryCode!
  currency: CurrencySetting!
  id: ID!
  name: String!
}
input MarketRegionCreateInput {
  countryCode: CountryCode!
}
type MarketRegionDeletePayload {
  deletedId: ID
  market: Market
  userErrors: [MarketUserError!]!
}
type MarketRegionEdge {
  cursor: String!
  node: MarketRegion!
}
type MarketRegionsCreatePayload {
  market: Market
  userErrors: [MarketUserError!]!
}
type MarketRegionsDeletePayload {
  deletedIds: [ID!]
  userErrors: [MarketUserError!]!
}
input MarketUpdateInput {
  name: String
  handle: String
  enabled: Boolean
}
type MarketUpdatePayload {
  market: Market
  userErrors: [MarketUserError!]!
}
type MarketUserError {
  code: MarketUserErrorCode
  field: [String!]
  message: String!
}
enum MarketUserErrorCode {
  INVALID
  TAKEN
  TOO_LONG
  TOO_SHORT
  BLANK
  MARKET_NOT_FOUND
  REGION_NOT_FOUND
  WEB_PRESENCE_NOT_FOUND
  CANNOT_ADD_REGIONS_TO_PRIMARY_MARKET
  CANNOT_DELETE_ONLY_REGION
  REQUIRES_EXACTLY_ONE_OPTION
  CANNOT_DELETE_PRIMARY_MARKET
  DOMAIN_NOT_FOUND
  SUBFOLDER_SUFFIX_MUST_CONTAIN_ONLY_LETTERS
  SUBFOLDER_SUFFIX_CANNOT_BE_SCRIPT_CODE
  NO_LANGUAGES
  DUPLICATE_LANGUAGES
  REGION_SPECIFIC_LANGUAGE
  CANNOT_HAVE_SUBFOLDER_AND_DOMAIN
  CANNOT_ADD_WEB_PRESENCE_TO_PRIMARY_MARKET
  MARKET_REACHED_WEB_PRESENCE_LIMIT
  CANNOT_HAVE_MULTIPLE_SUBFOLDERS_PER_MARKET
  CANNOT_HAVE_BOTH_SUBFOLDER_AND_DOMAIN_WEB_PRESENCES
  REQUIRES_DOMAIN_OR_SUBFOLDER
  PRIMARY_MARKET_MUST_USE_PRIMARY_DOMAIN
  CANNOT_DELETE_PRIMARY_MARKET_WEB_PRESENCE
  SHOP_REACHED_MARKETS_LIMIT
  CANNOT_DISABLE_PRIMARY_MARKET
  UNPUBLISHED_LANGUAGE
  DISABLED_LANGUAGE
  CANNOT_SET_DEFAULT_LOCALE_TO_NULL
  UNSUPPORTED_COUNTRY_REGION
  CANNOT_ADD_CUSTOMER_DOMAIN
}
type MarketWebPresence {
  alternateLocales: [ShopLocale!]!
  defaultLocale: ShopLocale!
  domain: Domain
  id: ID!
  market: Market!
  rootUrls: [MarketWebPresenceRootUrl!]!
  subfolderSuffix: String
}
type MarketWebPresenceConnection {
  edges: [MarketWebPresenceEdge!]!
  nodes: [MarketWebPresence!]!
  pageInfo: PageInfo!
}
input MarketWebPresenceCreateInput {
  domainId: ID
  defaultLocale: String!
  alternateLocales: [String!]
  subfolderSuffix: String
}
type MarketWebPresenceCreatePayload {
  market: Market
  userErrors: [MarketUserError!]!
}
type MarketWebPresenceDeletePayload {
  deletedId: ID
  market: Market
  userErrors: [MarketUserError!]!
}
type MarketWebPresenceEdge {
  cursor: String!
  node: MarketWebPresence!
}
type MarketWebPresenceRootUrl {
  locale: String!
  url: URL!
}
input MarketWebPresenceUpdateInput {
  domainId: ID
  defaultLocale: String
  alternateLocales: [String!]
  subfolderSuffix: String
}
type MarketWebPresenceUpdatePayload {
  market: Market
  userErrors: [MarketUserError!]!
}
type MarketingActivitiesDeleteAllExternalPayload {
  job: Job
  userErrors: [MarketingActivityUserError!]!
}
type MarketingActivity {
  activityListUrl: URL
  adSpend: MoneyV2
  app: App!
  appErrors: MarketingActivityExtensionAppErrors
  budget: MarketingBudget
  createdAt: DateTime!
  formData: String
  hierarchyLevel: MarketingActivityHierarchyLevel
  id: ID!
  inMainWorkflowVersion: Boolean!
  isExternal: Boolean!
  marketingChannel: MarketingChannel!
  marketingChannelType: MarketingChannel!
  marketingEvent: MarketingEvent
  parentActivityId: ID
  parentRemoteId: String
  sourceAndMedium: String!
  status: MarketingActivityStatus!
  statusBadgeType: MarketingActivityStatusBadgeType
  statusBadgeTypeV2: BadgeType
  statusLabel: String!
  statusTransitionedAt: DateTime
  tactic: MarketingTactic!
  targetStatus: MarketingActivityStatus
  title: String!
  updatedAt: DateTime!
  urlParameterValue: String
  utmParameters: UTMParameters
}
input MarketingActivityBudgetInput {
  budgetType: MarketingBudgetBudgetType
  total: MoneyInput
}
type MarketingActivityConnection {
  edges: [MarketingActivityEdge!]!
  nodes: [MarketingActivity!]!
  pageInfo: PageInfo!
}
input MarketingActivityCreateExternalInput {
  title: String!
  utm: UTMInput
  urlParameterValue: String
  budget: MarketingActivityBudgetInput
  adSpend: MoneyInput
  remoteId: String
  status: MarketingActivityExternalStatus
  remoteUrl: URL!
  remotePreviewImageUrl: URL
  tactic: MarketingTactic!
  marketingChannelType: MarketingChannel!
  referringDomain: String
  channelHandle: String
  scheduledStart: DateTime
  scheduledEnd: DateTime
  start: DateTime
  end: DateTime
  parentActivityId: ID
  parentRemoteId: String
  hierarchyLevel: MarketingActivityHierarchyLevel
}
type MarketingActivityCreateExternalPayload {
  marketingActivity: MarketingActivity
  userErrors: [MarketingActivityUserError!]!
}
input MarketingActivityCreateInput {
  marketingActivityTitle: String
  formData: String
  marketingActivityExtensionId: ID!
  context: String
  utm: UTMInput
  urlParameterValue: String
  status: MarketingActivityStatus!
  budget: MarketingActivityBudgetInput
}
type MarketingActivityCreatePayload {
  marketingActivity: MarketingActivity
  redirectPath: String
  userErrors: [UserError!]!
}
type MarketingActivityDeleteExternalPayload {
  deletedMarketingActivityId: ID
  userErrors: [MarketingActivityUserError!]!
}
type MarketingActivityEdge {
  cursor: String!
  node: MarketingActivity!
}
enum MarketingActivityExtensionAppErrorCode {
  NOT_ONBOARDED_ERROR
  VALIDATION_ERROR
  API_ERROR
  PLATFORM_ERROR
  INSTALL_REQUIRED_ERROR
}
type MarketingActivityExtensionAppErrors {
  code: MarketingActivityExtensionAppErrorCode!
  userErrors: [UserError!]!
}
enum MarketingActivityExternalStatus {
  ACTIVE
  INACTIVE
  PAUSED
  SCHEDULED
  DELETED_EXTERNALLY
  UNDEFINED
}
enum MarketingActivityHierarchyLevel {
  AD
  AD_GROUP
  CAMPAIGN
}
enum MarketingActivitySortKeys {
  CREATED_AT
  ID
  RELEVANCE
  TITLE
}
enum MarketingActivityStatus {
  ACTIVE
  DELETED
  DELETED_EXTERNALLY
  DISCONNECTED
  DRAFT
  FAILED
  INACTIVE
  PAUSED
  PENDING
  SCHEDULED
  UNDEFINED
}
enum MarketingActivityStatusBadgeType {
  DEFAULT
  SUCCESS
  ATTENTION
  WARNING
  INFO
  CRITICAL
}
input MarketingActivityUpdateExternalInput {
  title: String
  budget: MarketingActivityBudgetInput
  adSpend: MoneyInput
  remoteUrl: URL
  remotePreviewImageUrl: URL
  tactic: MarketingTactic
  marketingChannelType: MarketingChannel
  referringDomain: String
  scheduledStart: DateTime
  scheduledEnd: DateTime
  start: DateTime
  end: DateTime
  status: MarketingActivityExternalStatus
}
type MarketingActivityUpdateExternalPayload {
  marketingActivity: MarketingActivity
  userErrors: [MarketingActivityUserError!]!
}
input MarketingActivityUpdateInput {
  id: ID!
  marketingRecommendationId: ID
  title: String
  budget: MarketingActivityBudgetInput
  status: MarketingActivityStatus
  targetStatus: MarketingActivityStatus
  formData: String
  utm: UTMInput
  urlParameterValue: String
  marketedResources: [ID!]
  errors: JSON
}
type MarketingActivityUpdatePayload {
  marketingActivity: MarketingActivity
  redirectPath: String
  userErrors: [UserError!]!
}
input MarketingActivityUpsertExternalInput {
  title: String!
  utm: UTMInput
  budget: MarketingActivityBudgetInput
  adSpend: MoneyInput
  remoteId: String!
  status: MarketingActivityExternalStatus!
  remoteUrl: URL!
  remotePreviewImageUrl: URL
  tactic: MarketingTactic!
  marketingChannelType: MarketingChannel!
  referringDomain: String
  channelHandle: String
  scheduledStart: DateTime
  scheduledEnd: DateTime
  start: DateTime
  end: DateTime
  urlParameterValue: String
  parentRemoteId: String
  hierarchyLevel: MarketingActivityHierarchyLevel
}
type MarketingActivityUpsertExternalPayload {
  marketingActivity: MarketingActivity
  userErrors: [MarketingActivityUserError!]!
}
type MarketingActivityUserError {
  code: MarketingActivityUserErrorCode
  field: [String!]
  message: String!
}
enum MarketingActivityUserErrorCode {
  INVALID
  TAKEN
  MARKETING_ACTIVITY_DOES_NOT_EXIST
  MARKETING_EVENT_DOES_NOT_EXIST
  CURRENCY_CODE_MISMATCH_INPUT
  MARKETING_ACTIVITY_CURRENCY_CODE_MISMATCH
  DELETE_JOB_FAILED_TO_ENQUEUE
  NON_HIERARCHIAL_REQUIRES_UTM_URL_PARAMETER
  DELETE_JOB_ENQUEUED
  ACTIVITY_NOT_EXTERNAL
  IMMUTABLE_CHANNEL_HANDLE
  IMMUTABLE_URL_PARAMETER
  IMMUTABLE_UTM_PARAMETERS
  IMMUTABLE_PARENT_ID
  IMMUTABLE_HIERARCHY_LEVEL
  INVALID_REMOTE_ID
  INVALID_CHANNEL_HANDLE
  INVALID_DELETE_ACTIVITY_EXTERNAL_ARGUMENTS
  INVALID_DELETE_ENGAGEMENTS_ARGUMENTS
  INVALID_MARKETING_ACTIVITY_EXTERNAL_ARGUMENTS
  INVALID_MARKETING_ENGAGEMENT_ARGUMENTS
  INVALID_MARKETING_ENGAGEMENT_ARGUMENT_MISSING
  CANNOT_DELETE_ACTIVITY_WITH_CHILD_EVENTS
  CANNOT_UPDATE_TACTIC_TO_STOREFRONT_APP
  CANNOT_UPDATE_TACTIC_IF_ORIGINALLY_STOREFRONT_APP
}
type MarketingBudget {
  budgetType: MarketingBudgetBudgetType!
  total: MoneyV2!
}
enum MarketingBudgetBudgetType {
  DAILY
  LIFETIME
}
enum MarketingChannel {
  SEARCH
  DISPLAY
  SOCIAL
  EMAIL
  REFERRAL
}
type MarketingEngagement {
  adSpend: MoneyV2
  channelHandle: String
  clicksCount: Int
  commentsCount: Int
  complaintsCount: Int
  failsCount: Int
  favoritesCount: Int
  firstTimeCustomers: Decimal
  impressionsCount: Int
  isCumulative: Boolean!
  marketingActivity: MarketingActivity
  occurredOn: Date!
  orders: Decimal
  returningCustomers: Decimal
  sales: MoneyV2
  sendsCount: Int
  sessionsCount: Int
  sharesCount: Int
  uniqueClicksCount: Int
  uniqueViewsCount: Int
  unsubscribesCount: Int
  utcOffset: UtcOffset!
  viewsCount: Int
}
type MarketingEngagementCreatePayload {
  marketingEngagement: MarketingEngagement
  userErrors: [MarketingActivityUserError!]!
}
input MarketingEngagementInput {
  occurredOn: Date!
  impressionsCount: Int
  viewsCount: Int
  clicksCount: Int
  sharesCount: Int
  favoritesCount: Int
  commentsCount: Int
  unsubscribesCount: Int
  complaintsCount: Int
  failsCount: Int
  sendsCount: Int
  uniqueViewsCount: Int
  uniqueClicksCount: Int
  adSpend: MoneyInput
  isCumulative: Boolean!
  utcOffset: UtcOffset!
  sales: MoneyInput
  sessionsCount: Int
  orders: Decimal
  firstTimeCustomers: Decimal
  returningCustomers: Decimal
}
type MarketingEngagementsDeletePayload {
  result: String
  userErrors: [MarketingActivityUserError!]!
}
type MarketingEvent {
  app: App!
  channel: MarketingChannel
  channelHandle: String
  description: String
  endedAt: DateTime
  id: ID!
  legacyResourceId: UnsignedInt64!
  manageUrl: URL
  marketingChannelType: MarketingChannel
  previewUrl: URL
  remoteId: String
  scheduledToEndAt: DateTime
  sourceAndMedium: String!
  startedAt: DateTime!
  targetTypeDisplayText: String!
  type: MarketingTactic!
  utmCampaign: String
  utmMedium: String
  utmSource: String
}
type MarketingEventConnection {
  edges: [MarketingEventEdge!]!
  nodes: [MarketingEvent!]!
  pageInfo: PageInfo!
}
type MarketingEventEdge {
  cursor: String!
  node: MarketingEvent!
}
enum MarketingEventSortKeys {
  ID
  RELEVANCE
  STARTED_AT
}
enum MarketingTactic {
  ABANDONED_CART
  AD
  AFFILIATE
  LINK
  LOYALTY
  MESSAGE
  NEWSLETTER
  NOTIFICATION
  POST
  RETARGETING
  TRANSACTIONAL
  STOREFRONT_APP
  SEO
}
interface Media {
  alt: String
  id: ID!
  mediaContentType: MediaContentType!
  mediaErrors: [MediaError!]!
  mediaWarnings: [MediaWarning!]!
  preview: MediaPreviewImage
  status: MediaStatus!
}
type MediaConnection {
  edges: [MediaEdge!]!
  nodes: [Media!]!
  pageInfo: PageInfo!
}
enum MediaContentType {
  VIDEO
  EXTERNAL_VIDEO
  MODEL_3D
  IMAGE
}
type MediaEdge {
  cursor: String!
  node: Media!
}
type MediaError {
  code: MediaErrorCode!
  details: String
  message: String!
}
enum MediaErrorCode {
  UNKNOWN
  INVALID_SIGNED_URL
  IMAGE_DOWNLOAD_FAILURE
  IMAGE_PROCESSING_FAILURE
  MEDIA_TIMEOUT_ERROR
  EXTERNAL_VIDEO_NOT_FOUND
  EXTERNAL_VIDEO_UNLISTED
  EXTERNAL_VIDEO_INVALID_ASPECT_RATIO
  EXTERNAL_VIDEO_EMBED_DISABLED
  EXTERNAL_VIDEO_EMBED_NOT_FOUND_OR_TRANSCODING
  GENERIC_FILE_DOWNLOAD_FAILURE
  GENERIC_FILE_INVALID_SIZE
  VIDEO_METADATA_READ_ERROR
  VIDEO_INVALID_FILETYPE_ERROR
  VIDEO_MIN_WIDTH_ERROR
  VIDEO_MAX_WIDTH_ERROR
  VIDEO_MIN_HEIGHT_ERROR
  VIDEO_MAX_HEIGHT_ERROR
  VIDEO_MIN_DURATION_ERROR
  VIDEO_MAX_DURATION_ERROR
  VIDEO_VALIDATION_ERROR
  MODEL3D_VALIDATION_ERROR
  MODEL3D_THUMBNAIL_GENERATION_ERROR
  MODEL3D_THUMBNAIL_REGENERATION_ERROR
  MODEL3D_GLB_TO_USDZ_CONVERSION_ERROR
  MODEL3D_GLB_OUTPUT_CREATION_ERROR
  MODEL3D_PROCESSING_FAILURE
  UNSUPPORTED_IMAGE_FILE_TYPE
  INVALID_IMAGE_FILE_SIZE
  INVALID_IMAGE_ASPECT_RATIO
  INVALID_IMAGE_RESOLUTION
  FILE_STORAGE_LIMIT_EXCEEDED
  DUPLICATE_FILENAME_ERROR
}
enum MediaHost {
  YOUTUBE
  VIMEO
}
type MediaImage {
  alt: String
  createdAt: DateTime!
  fileErrors: [FileError!]!
  fileStatus: FileStatus!
  id: ID!
  image: Image
  mediaContentType: MediaContentType!
  mediaErrors: [MediaError!]!
  mediaWarnings: [MediaWarning!]!
  metafield: Metafield
  metafields: MetafieldConnection!
  mimeType: String
  originalSource: MediaImageOriginalSource
  preview: MediaPreviewImage
  status: MediaStatus!
  updatedAt: DateTime!
}
type MediaImageOriginalSource {
  fileSize: Int
  url: URL
}
type MediaPreviewImage {
  image: Image
  status: MediaPreviewImageStatus!
}
enum MediaPreviewImageStatus {
  UPLOADED
  PROCESSING
  READY
  FAILED
}
enum MediaStatus {
  UPLOADED
  PROCESSING
  READY
  FAILED
}
type MediaUserError {
  code: MediaUserErrorCode
  field: [String!]
  message: String!
}
enum MediaUserErrorCode {
  INVALID
  BLANK
  VIDEO_VALIDATION_ERROR
  MODEL3D_VALIDATION_ERROR
  VIDEO_THROTTLE_EXCEEDED
  MODEL3D_THROTTLE_EXCEEDED
  PRODUCT_MEDIA_LIMIT_EXCEEDED
  SHOP_MEDIA_LIMIT_EXCEEDED
  PRODUCT_DOES_NOT_EXIST
  MEDIA_DOES_NOT_EXIST
  MEDIA_DOES_NOT_EXIST_ON_PRODUCT
  TOO_MANY_MEDIA_PER_INPUT_PAIR
  MAXIMUM_VARIANT_MEDIA_PAIRS_EXCEEDED
  INVALID_MEDIA_TYPE
  PRODUCT_VARIANT_SPECIFIED_MULTIPLE_TIMES
  PRODUCT_VARIANT_DOES_NOT_EXIST_ON_PRODUCT
  NON_READY_MEDIA
  PRODUCT_VARIANT_ALREADY_HAS_MEDIA
  MEDIA_IS_NOT_ATTACHED_TO_VARIANT
  MEDIA_CANNOT_BE_MODIFIED
  PRODUCT_SUSPENDED
  MISSING_ARGUMENTS
}
type MediaWarning {
  code: MediaWarningCode!
  message: String
}
enum MediaWarningCode {
  MODEL_SMALL_PHYSICAL_SIZE
  MODEL_LARGE_PHYSICAL_SIZE
}
type Menu {
  handle: String!
  id: ID!
  isDefault: Boolean!
  items: [MenuItem!]!
  title: String!
  translations: [Translation!]!
}
type MenuConnection {
  edges: [MenuEdge!]!
  nodes: [Menu!]!
  pageInfo: PageInfo!
}
type MenuCreatePayload {
  menu: Menu
  userErrors: [MenuCreateUserError!]!
}
type MenuCreateUserError {
  code: MenuCreateUserErrorCode
  field: [String!]
  message: String!
}
enum MenuCreateUserErrorCode {
  NOT_FOUND
  NESTING_TOO_DEEP
}
type MenuDeletePayload {
  deletedMenuId: ID
  userErrors: [MenuDeleteUserError!]!
}
type MenuDeleteUserError {
  code: MenuDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum MenuDeleteUserErrorCode {
  MENU_DOES_NOT_EXIST
  UNABLE_TO_DELETE_DEFAULT_MENU
}
type MenuEdge {
  cursor: String!
  node: Menu!
}
type MenuItem {
  id: ID!
  items: [MenuItem!]!
  resourceId: ID
  tags: [String!]!
  title: String!
  type: MenuItemType!
  url: String
}
input MenuItemCreateInput {
  title: String!
  type: MenuItemType!
  resourceId: ID
  url: String
  tags: [String!]
  items: [MenuItemCreateInput!]
}
enum MenuItemType {
  FRONTPAGE
  COLLECTION
  COLLECTIONS
  PRODUCT
  CATALOG
  PAGE
  BLOG
  ARTICLE
  SEARCH
  SHOP_POLICY
  HTTP
  METAOBJECT
  CUSTOMER_ACCOUNT_PAGE
}
input MenuItemUpdateInput {
  title: String!
  type: MenuItemType!
  resourceId: ID
  url: String
  tags: [String!]
  id: ID
  items: [MenuItemUpdateInput!]
}
enum MenuSortKeys {
  ID
  RELEVANCE
  TITLE
  UPDATED_AT
}
type MenuUpdatePayload {
  menu: Menu
  userErrors: [MenuUpdateUserError!]!
}
type MenuUpdateUserError {
  code: MenuUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum MenuUpdateUserErrorCode {
  NOT_FOUND
  NESTING_TOO_DEEP
}
enum MerchandiseDiscountClass {
  PRODUCT
  ORDER
}
type MerchantApprovalSignals {
  identityVerified: Boolean!
  verifiedByShopify: Boolean!
  verifiedByShopifyTier: String!
}
type Metafield {
  compareDigest: String!
  createdAt: DateTime!
  definition: MetafieldDefinition
  description: String
  id: ID!
  jsonValue: JSON!
  key: String!
  legacyResourceId: UnsignedInt64!
  namespace: String!
  owner: HasMetafields!
  ownerType: MetafieldOwnerType!
  reference: MetafieldReference
  references: MetafieldReferenceConnection
  type: String!
  updatedAt: DateTime!
  value: String!
}
type MetafieldAccess {
  admin: MetafieldAdminAccess
  customerAccount: MetafieldCustomerAccountAccess!
  grants: [MetafieldAccessGrant!]!
  storefront: MetafieldStorefrontAccess
}
type MetafieldAccessGrant {
  access: MetafieldGrantAccessLevel!
  grantee: String!
}
input MetafieldAccessInput {
  admin: MetafieldAdminAccessInput
  storefront: MetafieldStorefrontAccessInput
  customerAccount: MetafieldCustomerAccountAccessInput
}
input MetafieldAccessUpdateInput {
  admin: MetafieldAdminAccessInput
  storefront: MetafieldStorefrontAccessInput
  customerAccount: MetafieldCustomerAccountAccessInput
}
enum MetafieldAdminAccess {
  PRIVATE
  PUBLIC_READ
  PUBLIC_READ_WRITE
  MERCHANT_READ
  MERCHANT_READ_WRITE
}
enum MetafieldAdminAccessInput {
  MERCHANT_READ
  MERCHANT_READ_WRITE
}
type MetafieldCapabilities {
  adminFilterable: MetafieldCapabilityAdminFilterable!
  smartCollectionCondition: MetafieldCapabilitySmartCollectionCondition!
  uniqueValues: MetafieldCapabilityUniqueValues!
}
type MetafieldCapabilityAdminFilterable {
  eligible: Boolean!
  enabled: Boolean!
  status: MetafieldDefinitionAdminFilterStatus!
}
input MetafieldCapabilityAdminFilterableInput {
  enabled: Boolean!
}
input MetafieldCapabilityCreateInput {
  smartCollectionCondition: MetafieldCapabilitySmartCollectionConditionInput
  adminFilterable: MetafieldCapabilityAdminFilterableInput
  uniqueValues: MetafieldCapabilityUniqueValuesInput
}
type MetafieldCapabilitySmartCollectionCondition {
  eligible: Boolean!
  enabled: Boolean!
}
input MetafieldCapabilitySmartCollectionConditionInput {
  enabled: Boolean!
}
type MetafieldCapabilityUniqueValues {
  eligible: Boolean!
  enabled: Boolean!
}
input MetafieldCapabilityUniqueValuesInput {
  enabled: Boolean!
}
input MetafieldCapabilityUpdateInput {
  smartCollectionCondition: MetafieldCapabilitySmartCollectionConditionInput
  adminFilterable: MetafieldCapabilityAdminFilterableInput
  uniqueValues: MetafieldCapabilityUniqueValuesInput
}
type MetafieldConnection {
  edges: [MetafieldEdge!]!
  nodes: [Metafield!]!
  pageInfo: PageInfo!
}
enum MetafieldCustomerAccountAccess {
  READ_WRITE
  READ
  NONE
}
enum MetafieldCustomerAccountAccessInput {
  READ_WRITE
  READ
  NONE
}
type MetafieldDefinition {
  access: MetafieldAccess!
  capabilities: MetafieldCapabilities!
  constraints: MetafieldDefinitionConstraints
  description: String
  id: ID!
  key: String!
  metafields: MetafieldConnection!
  metafieldsCount: Int!
  name: String!
  namespace: String!
  ownerType: MetafieldOwnerType!
  pinnedPosition: Int
  standardTemplate: StandardMetafieldDefinitionTemplate
  type: MetafieldDefinitionType!
  useAsCollectionCondition: Boolean!
  validationStatus: MetafieldDefinitionValidationStatus!
  validations: [MetafieldDefinitionValidation!]!
}
enum MetafieldDefinitionAdminFilterStatus {
  NOT_FILTERABLE
  IN_PROGRESS
  FILTERABLE
  FAILED
}
type MetafieldDefinitionConnection {
  edges: [MetafieldDefinitionEdge!]!
  nodes: [MetafieldDefinition!]!
  pageInfo: PageInfo!
}
enum MetafieldDefinitionConstraintStatus {
  CONSTRAINED_AND_UNCONSTRAINED
  CONSTRAINED_ONLY
  UNCONSTRAINED_ONLY
}
input MetafieldDefinitionConstraintSubtypeIdentifier {
  key: String!
  value: String!
}
type MetafieldDefinitionConstraintValue {
  value: String!
}
type MetafieldDefinitionConstraintValueConnection {
  edges: [MetafieldDefinitionConstraintValueEdge!]!
  nodes: [MetafieldDefinitionConstraintValue!]!
  pageInfo: PageInfo!
}
type MetafieldDefinitionConstraintValueEdge {
  cursor: String!
  node: MetafieldDefinitionConstraintValue!
}
input MetafieldDefinitionConstraintValueUpdateInput {
  create: String
  delete: String
}
type MetafieldDefinitionConstraints {
  key: String
  values: MetafieldDefinitionConstraintValueConnection!
}
input MetafieldDefinitionConstraintsInput {
  key: String!
  values: [String!]!
}
input MetafieldDefinitionConstraintsUpdatesInput {
  key: String
  values: [MetafieldDefinitionConstraintValueUpdateInput!]
}
type MetafieldDefinitionCreatePayload {
  createdDefinition: MetafieldDefinition
  userErrors: [MetafieldDefinitionCreateUserError!]!
}
type MetafieldDefinitionCreateUserError {
  code: MetafieldDefinitionCreateUserErrorCode
  elementIndex: Int
  field: [String!]
  message: String!
}
enum MetafieldDefinitionCreateUserErrorCode {
  INVALID
  INCLUSION
  PRESENT
  TAKEN
  TOO_LONG
  TOO_SHORT
  CAPABILITY_REQUIRED_BUT_DISABLED
  RESOURCE_TYPE_LIMIT_EXCEEDED
  LIMIT_EXCEEDED
  INVALID_OPTION
  DUPLICATE_OPTION
  RESERVED_NAMESPACE_KEY
  PINNED_LIMIT_REACHED
  UNSTRUCTURED_ALREADY_EXISTS
  UNSUPPORTED_PINNING
  INVALID_CHARACTER
  TYPE_NOT_ALLOWED_FOR_CONDITIONS
  OWNER_TYPE_LIMIT_EXCEEDED_FOR_AUTOMATED_COLLECTIONS
  INVALID_CONSTRAINTS
  GRANT_LIMIT_EXCEEDED
  INVALID_INPUT_COMBINATION
  INVALID_CAPABILITY
  ADMIN_ACCESS_INPUT_NOT_ALLOWED
}
type MetafieldDefinitionDeletePayload {
  deletedDefinitionId: ID
  userErrors: [MetafieldDefinitionDeleteUserError!]!
}
type MetafieldDefinitionDeleteUserError {
  code: MetafieldDefinitionDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum MetafieldDefinitionDeleteUserErrorCode {
  PRESENT
  NOT_FOUND
  INTERNAL_ERROR
  ID_TYPE_DELETION_ERROR
  REFERENCE_TYPE_DELETION_ERROR
  RESERVED_NAMESPACE_ORPHANED_METAFIELDS
  METAFIELD_DEFINITION_IN_USE
  DISALLOWED_OWNER_TYPE
}
type MetafieldDefinitionEdge {
  cursor: String!
  node: MetafieldDefinition!
}
input MetafieldDefinitionInput {
  namespace: String
  key: String!
  name: String!
  description: String
  ownerType: MetafieldOwnerType!
  type: String!
  validations: [MetafieldDefinitionValidationInput!]
  pin: Boolean
  access: MetafieldAccessInput
  constraints: MetafieldDefinitionConstraintsInput
  capabilities: MetafieldCapabilityCreateInput
}
type MetafieldDefinitionPinPayload {
  pinnedDefinition: MetafieldDefinition
  userErrors: [MetafieldDefinitionPinUserError!]!
}
type MetafieldDefinitionPinUserError {
  code: MetafieldDefinitionPinUserErrorCode
  field: [String!]
  message: String!
}
enum MetafieldDefinitionPinUserErrorCode {
  NOT_FOUND
  PINNED_LIMIT_REACHED
  ALREADY_PINNED
  INTERNAL_ERROR
  UNSUPPORTED_PINNING
  DISALLOWED_OWNER_TYPE
}
enum MetafieldDefinitionPinnedStatus {
  ANY
  PINNED
  UNPINNED
}
enum MetafieldDefinitionSortKeys {
  ID
  NAME
  PINNED_POSITION
  RELEVANCE
}
type MetafieldDefinitionSupportedValidation {
  name: String!
  type: String!
}
type MetafieldDefinitionType {
  category: String!
  name: String!
  supportedValidations: [MetafieldDefinitionSupportedValidation!]!
  supportsDefinitionMigrations: Boolean!
  valueType: MetafieldValueType!
}
type MetafieldDefinitionUnpinPayload {
  unpinnedDefinition: MetafieldDefinition
  userErrors: [MetafieldDefinitionUnpinUserError!]!
}
type MetafieldDefinitionUnpinUserError {
  code: MetafieldDefinitionUnpinUserErrorCode
  field: [String!]
  message: String!
}
enum MetafieldDefinitionUnpinUserErrorCode {
  NOT_FOUND
  NOT_PINNED
  INTERNAL_ERROR
  DISALLOWED_OWNER_TYPE
}
input MetafieldDefinitionUpdateInput {
  namespace: String
  key: String!
  name: String
  description: String
  ownerType: MetafieldOwnerType!
  validations: [MetafieldDefinitionValidationInput!]
  pin: Boolean
  access: MetafieldAccessUpdateInput
  constraintsUpdates: MetafieldDefinitionConstraintsUpdatesInput
  capabilities: MetafieldCapabilityUpdateInput
}
type MetafieldDefinitionUpdatePayload {
  updatedDefinition: MetafieldDefinition
  userErrors: [MetafieldDefinitionUpdateUserError!]!
  validationJob: Job
}
type MetafieldDefinitionUpdateUserError {
  code: MetafieldDefinitionUpdateUserErrorCode
  elementIndex: Int
  field: [String!]
  message: String!
}
enum MetafieldDefinitionUpdateUserErrorCode {
  PRESENT
  TOO_LONG
  NOT_FOUND
  INVALID_INPUT
  CAPABILITY_REQUIRED_BUT_DISABLED
  PINNED_LIMIT_REACHED
  INTERNAL_ERROR
  UNSUPPORTED_PINNING
  TYPE_NOT_ALLOWED_FOR_CONDITIONS
  METAFIELD_DEFINITION_IN_USE
  OWNER_TYPE_LIMIT_EXCEEDED_FOR_AUTOMATED_COLLECTIONS
  METAOBJECT_DEFINITION_CHANGED
  GRANT_LIMIT_EXCEEDED
  INVALID_INPUT_COMBINATION
  INVALID_CONSTRAINTS
  INVALID_CAPABILITY
  CAPABILITY_CANNOT_BE_DISABLED
  ADMIN_ACCESS_INPUT_NOT_ALLOWED
}
type MetafieldDefinitionValidation {
  name: String!
  type: String!
  value: String
}
input MetafieldDefinitionValidationInput {
  name: String!
  value: String!
}
enum MetafieldDefinitionValidationStatus {
  ALL_VALID
  IN_PROGRESS
  SOME_INVALID
}
type MetafieldEdge {
  cursor: String!
  node: Metafield!
}
enum MetafieldGrantAccessLevel {
  READ
  READ_WRITE
}
type MetafieldIdentifier {
  key: String!
  namespace: String!
  ownerId: ID!
}
input MetafieldIdentifierInput {
  ownerId: ID!
  namespace: String!
  key: String!
}
input MetafieldInput {
  id: ID
  namespace: String
  key: String
  value: String
  type: String
}
enum MetafieldOwnerType {
  API_PERMISSION
  COMPANY
  COMPANY_LOCATION
  PAYMENT_CUSTOMIZATION
  VALIDATION
  CUSTOMER
  DELIVERY_CUSTOMIZATION
  DRAFTORDER
  GIFT_CARD_TRANSACTION
  MARKET
  CARTTRANSFORM
  COLLECTION
  MEDIA_IMAGE
  PRODUCT
  PRODUCTVARIANT
  SELLING_PLAN
  ARTICLE
  BLOG
  PAGE
  FULFILLMENT_CONSTRAINT_RULE
  ORDER_ROUTING_LOCATION_RULE
  DISCOUNT
  ORDER
  LOCATION
  SHOP
}
union MetafieldReference = Collection | Company | Customer | GenericFile | MediaImage | Metaobject | Model3d | Order | Page | Product | ProductVariant | TaxonomyValue | Video
type MetafieldReferenceConnection {
  edges: [MetafieldReferenceEdge!]!
  nodes: [MetafieldReference]!
  pageInfo: PageInfo!
}
type MetafieldReferenceEdge {
  cursor: String!
  node: MetafieldReference
}
union MetafieldReferencer = AppInstallation | Article | Blog | Collection | Company | CompanyLocation | Customer | DeliveryCustomization | DiscountAutomaticNode | DiscountCodeNode | DiscountNode | DraftOrder | FulfillmentOrder | Location | Market | Metaobject | Order | Page | PaymentCustomization | Product | ProductVariant | Shop
type MetafieldRelation {
  key: String!
  name: String!
  namespace: String!
  referencer: MetafieldReferencer!
  target: MetafieldReference!
}
type MetafieldRelationConnection {
  edges: [MetafieldRelationEdge!]!
  nodes: [MetafieldRelation!]!
  pageInfo: PageInfo!
}
type MetafieldRelationEdge {
  cursor: String!
  node: MetafieldRelation!
}
enum MetafieldStorefrontAccess {
  PUBLIC_READ
  NONE
}
enum MetafieldStorefrontAccessInput {
  PUBLIC_READ
  NONE
}
enum MetafieldValidationStatus {
  ANY
  VALID
  INVALID
}
enum MetafieldValueType {
  STRING
  INTEGER
  JSON_STRING
  BOOLEAN
}
type MetafieldsDeletePayload {
  deletedMetafields: [MetafieldIdentifier]
  userErrors: [UserError!]!
}
input MetafieldsSetInput {
  ownerId: ID!
  namespace: String
  key: String!
  value: String!
  compareDigest: String
  type: String
}
type MetafieldsSetPayload {
  metafields: [Metafield!]
  userErrors: [MetafieldsSetUserError!]!
}
type MetafieldsSetUserError {
  code: MetafieldsSetUserErrorCode
  elementIndex: Int
  field: [String!]
  message: String!
}
enum MetafieldsSetUserErrorCode {
  CAPABILITY_VIOLATION
  STALE_OBJECT
  INVALID_COMPARE_DIGEST
  INVALID_TYPE
  INVALID_VALUE
  APP_NOT_AUTHORIZED
  INCLUSION
  TAKEN
  PRESENT
  BLANK
  TOO_LONG
  TOO_SHORT
  LESS_THAN_OR_EQUAL_TO
  INTERNAL_ERROR
}
type Metaobject {
  capabilities: MetaobjectCapabilityData!
  createdBy: App!
  createdByApp: App!
  createdByStaff: StaffMember
  definition: MetaobjectDefinition!
  displayName: String!
  field: MetaobjectField
  fields: [MetaobjectField!]!
  handle: String!
  id: ID!
  referencedBy: MetafieldRelationConnection!
  staffMember: StaffMember
  thumbnailField: MetaobjectField
  type: String!
  updatedAt: DateTime!
}
type MetaobjectAccess {
  admin: MetaobjectAdminAccess!
  storefront: MetaobjectStorefrontAccess!
}
input MetaobjectAccessInput {
  admin: MetaobjectAdminAccessInput
  storefront: MetaobjectStorefrontAccess
}
enum MetaobjectAdminAccess {
  PRIVATE
  MERCHANT_READ
  MERCHANT_READ_WRITE
  PUBLIC_READ
  PUBLIC_READ_WRITE
}
enum MetaobjectAdminAccessInput {
  MERCHANT_READ
  MERCHANT_READ_WRITE
}
type MetaobjectBulkDeletePayload {
  job: Job
  userErrors: [MetaobjectUserError!]!
}
input MetaobjectBulkDeleteWhereCondition {
  type: String
  ids: [ID!]
}
type MetaobjectCapabilities {
  onlineStore: MetaobjectCapabilitiesOnlineStore
  publishable: MetaobjectCapabilitiesPublishable!
  renderable: MetaobjectCapabilitiesRenderable
  translatable: MetaobjectCapabilitiesTranslatable!
}
type MetaobjectCapabilitiesOnlineStore {
  data: MetaobjectCapabilityDefinitionDataOnlineStore
  enabled: Boolean!
}
type MetaobjectCapabilitiesPublishable {
  enabled: Boolean!
}
type MetaobjectCapabilitiesRenderable {
  data: MetaobjectCapabilityDefinitionDataRenderable
  enabled: Boolean!
}
type MetaobjectCapabilitiesTranslatable {
  enabled: Boolean!
}
input MetaobjectCapabilityCreateInput {
  publishable: MetaobjectCapabilityPublishableInput
  translatable: MetaobjectCapabilityTranslatableInput
  renderable: MetaobjectCapabilityRenderableInput
  onlineStore: MetaobjectCapabilityOnlineStoreInput
}
type MetaobjectCapabilityData {
  onlineStore: MetaobjectCapabilityDataOnlineStore
  publishable: MetaobjectCapabilityDataPublishable
}
input MetaobjectCapabilityDataInput {
  publishable: MetaobjectCapabilityDataPublishableInput
  onlineStore: MetaobjectCapabilityDataOnlineStoreInput
}
type MetaobjectCapabilityDataOnlineStore {
  templateSuffix: String
}
input MetaobjectCapabilityDataOnlineStoreInput {
  templateSuffix: String
}
type MetaobjectCapabilityDataPublishable {
  status: MetaobjectStatus!
}
input MetaobjectCapabilityDataPublishableInput {
  status: MetaobjectStatus!
}
type MetaobjectCapabilityDefinitionDataOnlineStore {
  canCreateRedirects: Boolean!
  urlHandle: String!
}
input MetaobjectCapabilityDefinitionDataOnlineStoreInput {
  urlHandle: String!
  createRedirects: Boolean
}
type MetaobjectCapabilityDefinitionDataRenderable {
  metaDescriptionKey: String
  metaTitleKey: String
}
input MetaobjectCapabilityDefinitionDataRenderableInput {
  metaTitleKey: String
  metaDescriptionKey: String
}
input MetaobjectCapabilityOnlineStoreInput {
  enabled: Boolean!
  data: MetaobjectCapabilityDefinitionDataOnlineStoreInput
}
input MetaobjectCapabilityPublishableInput {
  enabled: Boolean!
}
input MetaobjectCapabilityRenderableInput {
  enabled: Boolean!
  data: MetaobjectCapabilityDefinitionDataRenderableInput
}
input MetaobjectCapabilityTranslatableInput {
  enabled: Boolean!
}
input MetaobjectCapabilityUpdateInput {
  publishable: MetaobjectCapabilityPublishableInput
  translatable: MetaobjectCapabilityTranslatableInput
  renderable: MetaobjectCapabilityRenderableInput
  onlineStore: MetaobjectCapabilityOnlineStoreInput
}
type MetaobjectConnection {
  edges: [MetaobjectEdge!]!
  nodes: [Metaobject!]!
  pageInfo: PageInfo!
}
input MetaobjectCreateInput {
  type: String!
  handle: String
  fields: [MetaobjectFieldInput!]
  capabilities: MetaobjectCapabilityDataInput
}
type MetaobjectCreatePayload {
  metaobject: Metaobject
  userErrors: [MetaobjectUserError!]!
}
type MetaobjectDefinition {
  access: MetaobjectAccess!
  capabilities: MetaobjectCapabilities!
  createdByApp: App!
  createdByStaff: StaffMember
  description: String
  displayNameKey: String
  fieldDefinitions: [MetaobjectFieldDefinition!]!
  hasThumbnailField: Boolean!
  id: ID!
  metaobjects: MetaobjectConnection!
  metaobjectsCount: Int!
  name: String!
  type: String!
}
type MetaobjectDefinitionConnection {
  edges: [MetaobjectDefinitionEdge!]!
  nodes: [MetaobjectDefinition!]!
  pageInfo: PageInfo!
}
input MetaobjectDefinitionCreateInput {
  name: String
  description: String
  type: String!
  fieldDefinitions: [MetaobjectFieldDefinitionCreateInput!]!
  access: MetaobjectAccessInput
  displayNameKey: String
  capabilities: MetaobjectCapabilityCreateInput
}
type MetaobjectDefinitionCreatePayload {
  metaobjectDefinition: MetaobjectDefinition
  userErrors: [MetaobjectUserError!]!
}
type MetaobjectDefinitionDeletePayload {
  deletedId: ID
  userErrors: [MetaobjectUserError!]!
}
type MetaobjectDefinitionEdge {
  cursor: String!
  node: MetaobjectDefinition!
}
input MetaobjectDefinitionUpdateInput {
  name: String
  description: String
  fieldDefinitions: [MetaobjectFieldDefinitionOperationInput!]
  access: MetaobjectAccessInput
  displayNameKey: String
  resetFieldOrder: Boolean
  capabilities: MetaobjectCapabilityUpdateInput
}
type MetaobjectDefinitionUpdatePayload {
  metaobjectDefinition: MetaobjectDefinition
  userErrors: [MetaobjectUserError!]!
}
type MetaobjectDeletePayload {
  deletedId: ID
  userErrors: [MetaobjectUserError!]!
}
type MetaobjectEdge {
  cursor: String!
  node: Metaobject!
}
type MetaobjectField {
  definition: MetaobjectFieldDefinition!
  jsonValue: JSON
  key: String!
  reference: MetafieldReference
  references: MetafieldReferenceConnection
  thumbnail: MetaobjectThumbnail
  type: String!
  value: String
}
type MetaobjectFieldDefinition {
  description: String
  key: String!
  name: String!
  required: Boolean!
  type: MetafieldDefinitionType!
  validations: [MetafieldDefinitionValidation!]!
}
input MetaobjectFieldDefinitionCreateInput {
  key: String!
  type: String!
  name: String
  description: String
  required: Boolean
  validations: [MetafieldDefinitionValidationInput!]
}
input MetaobjectFieldDefinitionDeleteInput {
  key: String!
}
input MetaobjectFieldDefinitionOperationInput {
  create: MetaobjectFieldDefinitionCreateInput
  update: MetaobjectFieldDefinitionUpdateInput
  delete: MetaobjectFieldDefinitionDeleteInput
}
input MetaobjectFieldDefinitionUpdateInput {
  key: String!
  name: String
  description: String
  required: Boolean
  validations: [MetafieldDefinitionValidationInput!]
}
input MetaobjectFieldInput {
  key: String!
  value: String!
}
input MetaobjectHandleInput {
  type: String!
  handle: String!
}
enum MetaobjectStatus {
  DRAFT
  ACTIVE
}
enum MetaobjectStorefrontAccess {
  NONE
  PUBLIC_READ
}
type MetaobjectThumbnail {
  file: File
  hex: String
}
input MetaobjectUpdateInput {
  handle: String
  fields: [MetaobjectFieldInput!]
  capabilities: MetaobjectCapabilityDataInput
  redirectNewHandle: Boolean
}
type MetaobjectUpdatePayload {
  metaobject: Metaobject
  userErrors: [MetaobjectUserError!]!
}
input MetaobjectUpsertInput {
  handle: String
  fields: [MetaobjectFieldInput!]
  capabilities: MetaobjectCapabilityDataInput
}
type MetaobjectUpsertPayload {
  metaobject: Metaobject
  userErrors: [MetaobjectUserError!]!
}
type MetaobjectUserError {
  code: MetaobjectUserErrorCode
  elementIndex: Int
  elementKey: String
  field: [String!]
  message: String!
}
enum MetaobjectUserErrorCode {
  INVALID
  INCLUSION
  TAKEN
  TOO_LONG
  TOO_SHORT
  PRESENT
  BLANK
  INVALID_TYPE
  INVALID_VALUE
  INVALID_OPTION
  DUPLICATE_FIELD_INPUT
  UNDEFINED_OBJECT_TYPE
  UNDEFINED_OBJECT_FIELD
  OBJECT_FIELD_TAKEN
  OBJECT_FIELD_REQUIRED
  RECORD_NOT_FOUND
  INTERNAL_ERROR
  MAX_DEFINITIONS_EXCEEDED
  MAX_OBJECTS_EXCEEDED
  IMMUTABLE
  NOT_AUTHORIZED
  RESERVED_NAME
  DISPLAY_NAME_CONFLICT
  ADMIN_ACCESS_INPUT_NOT_ALLOWED
  CAPABILITY_NOT_ENABLED
  URL_HANDLE_TAKEN
  URL_HANDLE_INVALID
  URL_HANDLE_BLANK
  FIELD_TYPE_INVALID
  MISSING_REQUIRED_KEYS
  REFERENCE_EXISTS_ERROR
}
enum MethodDefinitionSortKeys {
  ID
  RATE_PROVIDER_TYPE
  RELEVANCE
}
union MobilePlatformApplication = AndroidApplication | AppleApplication
type MobilePlatformApplicationConnection {
  edges: [MobilePlatformApplicationEdge!]!
  nodes: [MobilePlatformApplication!]!
  pageInfo: PageInfo!
}
input MobilePlatformApplicationCreateAndroidInput {
  applicationId: String
  sha256CertFingerprints: [String!]!
  appLinksEnabled: Boolean!
}
input MobilePlatformApplicationCreateAppleInput {
  appId: String
  universalLinksEnabled: Boolean!
  sharedWebCredentialsEnabled: Boolean!
  appClipsEnabled: Boolean
  appClipApplicationId: String
}
input MobilePlatformApplicationCreateInput {
  android: MobilePlatformApplicationCreateAndroidInput
  apple: MobilePlatformApplicationCreateAppleInput
}
type MobilePlatformApplicationCreatePayload {
  mobilePlatformApplication: MobilePlatformApplication
  userErrors: [MobilePlatformApplicationUserError!]!
}
type MobilePlatformApplicationDeletePayload {
  deletedMobilePlatformApplicationId: ID
  userErrors: [MobilePlatformApplicationUserError!]!
}
type MobilePlatformApplicationEdge {
  cursor: String!
  node: MobilePlatformApplication!
}
input MobilePlatformApplicationUpdateAndroidInput {
  applicationId: String
  sha256CertFingerprints: [String!]
  appLinksEnabled: Boolean
}
input MobilePlatformApplicationUpdateAppleInput {
  appId: String
  universalLinksEnabled: Boolean
  sharedWebCredentialsEnabled: Boolean
  appClipsEnabled: Boolean
  appClipApplicationId: String
}
input MobilePlatformApplicationUpdateInput {
  android: MobilePlatformApplicationUpdateAndroidInput
  apple: MobilePlatformApplicationUpdateAppleInput
}
type MobilePlatformApplicationUpdatePayload {
  mobilePlatformApplication: MobilePlatformApplication
  userErrors: [MobilePlatformApplicationUserError!]!
}
type MobilePlatformApplicationUserError {
  code: MobilePlatformApplicationUserErrorCode
  field: [String!]
  message: String!
}
enum MobilePlatformApplicationUserErrorCode {
  INVALID
  NOT_FOUND
  TOO_LONG
}
type Model3d {
  alt: String
  boundingBox: Model3dBoundingBox
  createdAt: DateTime!
  fileErrors: [FileError!]!
  fileStatus: FileStatus!
  filename: String!
  id: ID!
  mediaContentType: MediaContentType!
  mediaErrors: [MediaError!]!
  mediaWarnings: [MediaWarning!]!
  originalSource: Model3dSource
  preview: MediaPreviewImage
  sources: [Model3dSource!]!
  status: MediaStatus!
  updatedAt: DateTime!
}
type Model3dBoundingBox {
  size: Vector3!
}
type Model3dSource {
  filesize: Int!
  format: String!
  mimeType: String!
  url: String!
}
scalar Money
type MoneyBag {
  presentmentMoney: MoneyV2!
  shopMoney: MoneyV2!
}
input MoneyBagInput {
  shopMoney: MoneyInput!
  presentmentMoney: MoneyInput
}
input MoneyInput {
  amount: Decimal!
  currencyCode: CurrencyCode!
}
type MoneyV2 {
  amount: Decimal!
  currencyCode: CurrencyCode!
}
input MoveInput {
  id: ID!
  newPosition: UnsignedInt64!
}
type Mutation {
  abandonmentEmailStateUpdate: AbandonmentEmailStateUpdatePayload
  abandonmentUpdateActivitiesDeliveryStatuses: AbandonmentUpdateActivitiesDeliveryStatusesPayload
  appPurchaseOneTimeCreate: AppPurchaseOneTimeCreatePayload
  appRevokeAccessScopes: AppRevokeAccessScopesPayload
  appSubscriptionCancel: AppSubscriptionCancelPayload
  appSubscriptionCreate: AppSubscriptionCreatePayload
  appSubscriptionLineItemUpdate: AppSubscriptionLineItemUpdatePayload
  appSubscriptionTrialExtend: AppSubscriptionTrialExtendPayload
  appUsageRecordCreate: AppUsageRecordCreatePayload
  articleCreate: ArticleCreatePayload
  articleDelete: ArticleDeletePayload
  articleUpdate: ArticleUpdatePayload
  blogCreate: BlogCreatePayload
  blogDelete: BlogDeletePayload
  blogUpdate: BlogUpdatePayload
  bulkOperationCancel: BulkOperationCancelPayload
  bulkOperationRunMutation: BulkOperationRunMutationPayload
  bulkOperationRunQuery: BulkOperationRunQueryPayload
  bulkProductResourceFeedbackCreate: BulkProductResourceFeedbackCreatePayload
  carrierServiceCreate: CarrierServiceCreatePayload
  carrierServiceDelete: CarrierServiceDeletePayload
  carrierServiceUpdate: CarrierServiceUpdatePayload
  cartTransformCreate: CartTransformCreatePayload
  cartTransformDelete: CartTransformDeletePayload
  catalogContextUpdate: CatalogContextUpdatePayload
  catalogCreate: CatalogCreatePayload
  catalogDelete: CatalogDeletePayload
  catalogUpdate: CatalogUpdatePayload
  checkoutBrandingUpsert: CheckoutBrandingUpsertPayload
  collectionAddProducts: CollectionAddProductsPayload
  collectionAddProductsV2: CollectionAddProductsV2Payload
  collectionCreate: CollectionCreatePayload
  collectionDelete: CollectionDeletePayload
  collectionPublish: CollectionPublishPayload
  collectionRemoveProducts: CollectionRemoveProductsPayload
  collectionReorderProducts: CollectionReorderProductsPayload
  collectionUnpublish: CollectionUnpublishPayload
  collectionUpdate: CollectionUpdatePayload
  combinedListingUpdate: CombinedListingUpdatePayload
  commentApprove: CommentApprovePayload
  commentDelete: CommentDeletePayload
  commentNotSpam: CommentNotSpamPayload
  commentSpam: CommentSpamPayload
  companiesDelete: CompaniesDeletePayload
  companyAddressDelete: CompanyAddressDeletePayload
  companyAssignCustomerAsContact: CompanyAssignCustomerAsContactPayload
  companyAssignMainContact: CompanyAssignMainContactPayload
  companyContactAssignRole: CompanyContactAssignRolePayload
  companyContactAssignRoles: CompanyContactAssignRolesPayload
  companyContactCreate: CompanyContactCreatePayload
  companyContactDelete: CompanyContactDeletePayload
  companyContactRemoveFromCompany: CompanyContactRemoveFromCompanyPayload
  companyContactRevokeRole: CompanyContactRevokeRolePayload
  companyContactRevokeRoles: CompanyContactRevokeRolesPayload
  companyContactSendWelcomeEmail: CompanyContactSendWelcomeEmailPayload
  companyContactUpdate: CompanyContactUpdatePayload
  companyContactsDelete: CompanyContactsDeletePayload
  companyCreate: CompanyCreatePayload
  companyDelete: CompanyDeletePayload
  companyLocationAssignAddress: CompanyLocationAssignAddressPayload
  companyLocationAssignRoles: CompanyLocationAssignRolesPayload
  companyLocationAssignStaffMembers: CompanyLocationAssignStaffMembersPayload
  companyLocationAssignTaxExemptions: CompanyLocationAssignTaxExemptionsPayload
  companyLocationCreate: CompanyLocationCreatePayload
  companyLocationCreateTaxRegistration: CompanyLocationCreateTaxRegistrationPayload
  companyLocationDelete: CompanyLocationDeletePayload
  companyLocationRemoveStaffMembers: CompanyLocationRemoveStaffMembersPayload
  companyLocationRevokeRoles: CompanyLocationRevokeRolesPayload
  companyLocationRevokeTaxExemptions: CompanyLocationRevokeTaxExemptionsPayload
  companyLocationRevokeTaxRegistration: CompanyLocationRevokeTaxRegistrationPayload
  companyLocationTaxSettingsUpdate: CompanyLocationTaxSettingsUpdatePayload
  companyLocationUpdate: CompanyLocationUpdatePayload
  companyLocationsDelete: CompanyLocationsDeletePayload
  companyRevokeMainContact: CompanyRevokeMainContactPayload
  companyUpdate: CompanyUpdatePayload
  customerAddTaxExemptions: CustomerAddTaxExemptionsPayload
  customerCancelDataErasure: CustomerCancelDataErasurePayload
  customerCreate: CustomerCreatePayload
  customerDelete: CustomerDeletePayload
  customerEmailMarketingConsentUpdate: CustomerEmailMarketingConsentUpdatePayload
  customerGenerateAccountActivationUrl: CustomerGenerateAccountActivationUrlPayload
  customerMerge: CustomerMergePayload
  customerPaymentMethodCreateFromDuplicationData: CustomerPaymentMethodCreateFromDuplicationDataPayload
  customerPaymentMethodCreditCardCreate: CustomerPaymentMethodCreditCardCreatePayload
  customerPaymentMethodCreditCardUpdate: CustomerPaymentMethodCreditCardUpdatePayload
  customerPaymentMethodGetDuplicationData: CustomerPaymentMethodGetDuplicationDataPayload
  customerPaymentMethodGetUpdateUrl: CustomerPaymentMethodGetUpdateUrlPayload
  customerPaymentMethodPaypalBillingAgreementCreate: CustomerPaymentMethodPaypalBillingAgreementCreatePayload
  customerPaymentMethodPaypalBillingAgreementUpdate: CustomerPaymentMethodPaypalBillingAgreementUpdatePayload
  customerPaymentMethodRemoteCreate: CustomerPaymentMethodRemoteCreatePayload
  customerPaymentMethodRevoke: CustomerPaymentMethodRevokePayload
  customerPaymentMethodSendUpdateEmail: CustomerPaymentMethodSendUpdateEmailPayload
  customerRemoveTaxExemptions: CustomerRemoveTaxExemptionsPayload
  customerReplaceTaxExemptions: CustomerReplaceTaxExemptionsPayload
  customerRequestDataErasure: CustomerRequestDataErasurePayload
  customerSegmentMembersQueryCreate: CustomerSegmentMembersQueryCreatePayload
  customerSendAccountInviteEmail: CustomerSendAccountInviteEmailPayload
  customerSmsMarketingConsentUpdate: CustomerSmsMarketingConsentUpdatePayload
  customerUpdate: CustomerUpdatePayload
  customerUpdateDefaultAddress: CustomerUpdateDefaultAddressPayload
  dataSaleOptOut: DataSaleOptOutPayload
  delegateAccessTokenCreate: DelegateAccessTokenCreatePayload
  delegateAccessTokenDestroy: DelegateAccessTokenDestroyPayload
  deliveryCustomizationActivation: DeliveryCustomizationActivationPayload
  deliveryCustomizationCreate: DeliveryCustomizationCreatePayload
  deliveryCustomizationDelete: DeliveryCustomizationDeletePayload
  deliveryCustomizationUpdate: DeliveryCustomizationUpdatePayload
  deliveryProfileCreate: DeliveryProfileCreatePayload
  deliveryProfileRemove: DeliveryProfileRemovePayload
  deliveryProfileUpdate: DeliveryProfileUpdatePayload
  deliveryPromiseParticipantsUpdate: DeliveryPromiseParticipantsUpdatePayload
  deliveryPromiseProviderUpsert: DeliveryPromiseProviderUpsertPayload
  deliverySettingUpdate: DeliverySettingUpdatePayload
  deliveryShippingOriginAssign: DeliveryShippingOriginAssignPayload
  discountAutomaticActivate: DiscountAutomaticActivatePayload
  discountAutomaticAppCreate: DiscountAutomaticAppCreatePayload
  discountAutomaticAppUpdate: DiscountAutomaticAppUpdatePayload
  discountAutomaticBasicCreate: DiscountAutomaticBasicCreatePayload
  discountAutomaticBasicUpdate: DiscountAutomaticBasicUpdatePayload
  discountAutomaticBulkDelete: DiscountAutomaticBulkDeletePayload
  discountAutomaticBxgyCreate: DiscountAutomaticBxgyCreatePayload
  discountAutomaticBxgyUpdate: DiscountAutomaticBxgyUpdatePayload
  discountAutomaticDeactivate: DiscountAutomaticDeactivatePayload
  discountAutomaticDelete: DiscountAutomaticDeletePayload
  discountAutomaticFreeShippingCreate: DiscountAutomaticFreeShippingCreatePayload
  discountAutomaticFreeShippingUpdate: DiscountAutomaticFreeShippingUpdatePayload
  discountCodeActivate: DiscountCodeActivatePayload
  discountCodeAppCreate: DiscountCodeAppCreatePayload
  discountCodeAppUpdate: DiscountCodeAppUpdatePayload
  discountCodeBasicCreate: DiscountCodeBasicCreatePayload
  discountCodeBasicUpdate: DiscountCodeBasicUpdatePayload
  discountCodeBulkActivate: DiscountCodeBulkActivatePayload
  discountCodeBulkDeactivate: DiscountCodeBulkDeactivatePayload
  discountCodeBulkDelete: DiscountCodeBulkDeletePayload
  discountCodeBxgyCreate: DiscountCodeBxgyCreatePayload
  discountCodeBxgyUpdate: DiscountCodeBxgyUpdatePayload
  discountCodeDeactivate: DiscountCodeDeactivatePayload
  discountCodeDelete: DiscountCodeDeletePayload
  discountCodeFreeShippingCreate: DiscountCodeFreeShippingCreatePayload
  discountCodeFreeShippingUpdate: DiscountCodeFreeShippingUpdatePayload
  discountCodeRedeemCodeBulkDelete: DiscountCodeRedeemCodeBulkDeletePayload
  discountRedeemCodeBulkAdd: DiscountRedeemCodeBulkAddPayload
  disputeEvidenceUpdate: DisputeEvidenceUpdatePayload
  draftOrderBulkAddTags: DraftOrderBulkAddTagsPayload
  draftOrderBulkDelete: DraftOrderBulkDeletePayload
  draftOrderBulkRemoveTags: DraftOrderBulkRemoveTagsPayload
  draftOrderCalculate: DraftOrderCalculatePayload
  draftOrderComplete: DraftOrderCompletePayload
  draftOrderCreate: DraftOrderCreatePayload
  draftOrderCreateFromOrder: DraftOrderCreateFromOrderPayload
  draftOrderCreateMerchantCheckout: DraftOrderCreateMerchantCheckoutPayload
  draftOrderDelete: DraftOrderDeletePayload
  draftOrderDuplicate: DraftOrderDuplicatePayload
  draftOrderInvoicePreview: DraftOrderInvoicePreviewPayload
  draftOrderInvoiceSend: DraftOrderInvoiceSendPayload
  draftOrderUpdate: DraftOrderUpdatePayload
  eventBridgeServerPixelUpdate: EventBridgeServerPixelUpdatePayload
  eventBridgeWebhookSubscriptionCreate: EventBridgeWebhookSubscriptionCreatePayload
  eventBridgeWebhookSubscriptionUpdate: EventBridgeWebhookSubscriptionUpdatePayload
  fileAcknowledgeUpdateFailed: FileAcknowledgeUpdateFailedPayload
  fileCreate: FileCreatePayload
  fileDelete: FileDeletePayload
  fileUpdate: FileUpdatePayload
  flowGenerateSignature: FlowGenerateSignaturePayload
  flowTriggerReceive: FlowTriggerReceivePayload
  fulfillmentCancel: FulfillmentCancelPayload
  fulfillmentConstraintRuleCreate: FulfillmentConstraintRuleCreatePayload
  fulfillmentConstraintRuleDelete: FulfillmentConstraintRuleDeletePayload
  fulfillmentConstraintRuleUpdate: FulfillmentConstraintRuleUpdatePayload
  fulfillmentCreate: FulfillmentCreatePayload
  fulfillmentCreateV2: FulfillmentCreateV2Payload
  fulfillmentEventCreate: FulfillmentEventCreatePayload
  fulfillmentOrderAcceptCancellationRequest: FulfillmentOrderAcceptCancellationRequestPayload
  fulfillmentOrderAcceptFulfillmentRequest: FulfillmentOrderAcceptFulfillmentRequestPayload
  fulfillmentOrderCancel: FulfillmentOrderCancelPayload
  fulfillmentOrderClose: FulfillmentOrderClosePayload
  fulfillmentOrderHold: FulfillmentOrderHoldPayload
  fulfillmentOrderLineItemsPreparedForPickup: FulfillmentOrderLineItemsPreparedForPickupPayload
  fulfillmentOrderMerge: FulfillmentOrderMergePayload
  fulfillmentOrderMove: FulfillmentOrderMovePayload
  fulfillmentOrderOpen: FulfillmentOrderOpenPayload
  fulfillmentOrderRejectCancellationRequest: FulfillmentOrderRejectCancellationRequestPayload
  fulfillmentOrderRejectFulfillmentRequest: FulfillmentOrderRejectFulfillmentRequestPayload
  fulfillmentOrderReleaseHold: FulfillmentOrderReleaseHoldPayload
  fulfillmentOrderReschedule: FulfillmentOrderReschedulePayload
  fulfillmentOrderSplit: FulfillmentOrderSplitPayload
  fulfillmentOrderSubmitCancellationRequest: FulfillmentOrderSubmitCancellationRequestPayload
  fulfillmentOrderSubmitFulfillmentRequest: FulfillmentOrderSubmitFulfillmentRequestPayload
  fulfillmentOrdersSetFulfillmentDeadline: FulfillmentOrdersSetFulfillmentDeadlinePayload
  fulfillmentServiceCreate: FulfillmentServiceCreatePayload
  fulfillmentServiceDelete: FulfillmentServiceDeletePayload
  fulfillmentServiceUpdate: FulfillmentServiceUpdatePayload
  fulfillmentTrackingInfoUpdate: FulfillmentTrackingInfoUpdatePayload
  fulfillmentTrackingInfoUpdateV2: FulfillmentTrackingInfoUpdateV2Payload
  giftCardCreate: GiftCardCreatePayload
  giftCardCredit: GiftCardCreditPayload
  giftCardDeactivate: GiftCardDeactivatePayload
  giftCardDebit: GiftCardDebitPayload
  giftCardSendNotificationToCustomer: GiftCardSendNotificationToCustomerPayload
  giftCardSendNotificationToRecipient: GiftCardSendNotificationToRecipientPayload
  giftCardUpdate: GiftCardUpdatePayload
  inventoryActivate: InventoryActivatePayload
  inventoryAdjustQuantities: InventoryAdjustQuantitiesPayload
  inventoryBulkToggleActivation: InventoryBulkToggleActivationPayload
  inventoryDeactivate: InventoryDeactivatePayload
  inventoryItemUpdate: InventoryItemUpdatePayload
  inventoryMoveQuantities: InventoryMoveQuantitiesPayload
  inventorySetOnHandQuantities: InventorySetOnHandQuantitiesPayload
  inventorySetQuantities: InventorySetQuantitiesPayload
  inventorySetScheduledChanges: InventorySetScheduledChangesPayload
  locationActivate: LocationActivatePayload
  locationAdd: LocationAddPayload
  locationDeactivate: LocationDeactivatePayload
  locationDelete: LocationDeletePayload
  locationEdit: LocationEditPayload
  locationLocalPickupDisable: LocationLocalPickupDisablePayload
  locationLocalPickupEnable: LocationLocalPickupEnablePayload
  marketCreate: MarketCreatePayload
  marketCurrencySettingsUpdate: MarketCurrencySettingsUpdatePayload
  marketDelete: MarketDeletePayload
  marketLocalizationsRegister: MarketLocalizationsRegisterPayload
  marketLocalizationsRemove: MarketLocalizationsRemovePayload
  marketRegionDelete: MarketRegionDeletePayload
  marketRegionsCreate: MarketRegionsCreatePayload
  marketRegionsDelete: MarketRegionsDeletePayload
  marketUpdate: MarketUpdatePayload
  marketWebPresenceCreate: MarketWebPresenceCreatePayload
  marketWebPresenceDelete: MarketWebPresenceDeletePayload
  marketWebPresenceUpdate: MarketWebPresenceUpdatePayload
  marketingActivitiesDeleteAllExternal: MarketingActivitiesDeleteAllExternalPayload
  marketingActivityCreate: MarketingActivityCreatePayload
  marketingActivityCreateExternal: MarketingActivityCreateExternalPayload
  marketingActivityDeleteExternal: MarketingActivityDeleteExternalPayload
  marketingActivityUpdate: MarketingActivityUpdatePayload
  marketingActivityUpdateExternal: MarketingActivityUpdateExternalPayload
  marketingActivityUpsertExternal: MarketingActivityUpsertExternalPayload
  marketingEngagementCreate: MarketingEngagementCreatePayload
  marketingEngagementsDelete: MarketingEngagementsDeletePayload
  menuCreate: MenuCreatePayload
  menuDelete: MenuDeletePayload
  menuUpdate: MenuUpdatePayload
  metafieldDefinitionCreate: MetafieldDefinitionCreatePayload
  metafieldDefinitionDelete: MetafieldDefinitionDeletePayload
  metafieldDefinitionPin: MetafieldDefinitionPinPayload
  metafieldDefinitionUnpin: MetafieldDefinitionUnpinPayload
  metafieldDefinitionUpdate: MetafieldDefinitionUpdatePayload
  metafieldsDelete: MetafieldsDeletePayload
  metafieldsSet: MetafieldsSetPayload
  metaobjectBulkDelete: MetaobjectBulkDeletePayload
  metaobjectCreate: MetaobjectCreatePayload
  metaobjectDefinitionCreate: MetaobjectDefinitionCreatePayload
  metaobjectDefinitionDelete: MetaobjectDefinitionDeletePayload
  metaobjectDefinitionUpdate: MetaobjectDefinitionUpdatePayload
  metaobjectDelete: MetaobjectDeletePayload
  metaobjectUpdate: MetaobjectUpdatePayload
  metaobjectUpsert: MetaobjectUpsertPayload
  mobilePlatformApplicationCreate: MobilePlatformApplicationCreatePayload
  mobilePlatformApplicationDelete: MobilePlatformApplicationDeletePayload
  mobilePlatformApplicationUpdate: MobilePlatformApplicationUpdatePayload
  orderCancel: OrderCancelPayload
  orderCapture: OrderCapturePayload
  orderClose: OrderClosePayload
  orderCreate: OrderCreatePayload
  orderCreateMandatePayment: OrderCreateMandatePaymentPayload
  orderDelete: OrderDeletePayload
  orderEditAddCustomItem: OrderEditAddCustomItemPayload
  orderEditAddLineItemDiscount: OrderEditAddLineItemDiscountPayload
  orderEditAddShippingLine: OrderEditAddShippingLinePayload
  orderEditAddVariant: OrderEditAddVariantPayload
  orderEditBegin: OrderEditBeginPayload
  orderEditCommit: OrderEditCommitPayload
  orderEditRemoveDiscount: OrderEditRemoveDiscountPayload
  orderEditRemoveLineItemDiscount: OrderEditRemoveLineItemDiscountPayload
  orderEditRemoveShippingLine: OrderEditRemoveShippingLinePayload
  orderEditSetQuantity: OrderEditSetQuantityPayload
  orderEditUpdateDiscount: OrderEditUpdateDiscountPayload
  orderEditUpdateShippingLine: OrderEditUpdateShippingLinePayload
  orderInvoiceSend: OrderInvoiceSendPayload
  orderMarkAsPaid: OrderMarkAsPaidPayload
  orderOpen: OrderOpenPayload
  orderRiskAssessmentCreate: OrderRiskAssessmentCreatePayload
  orderUpdate: OrderUpdatePayload
  pageCreate: PageCreatePayload
  pageDelete: PageDeletePayload
  pageUpdate: PageUpdatePayload
  paymentCustomizationActivation: PaymentCustomizationActivationPayload
  paymentCustomizationCreate: PaymentCustomizationCreatePayload
  paymentCustomizationDelete: PaymentCustomizationDeletePayload
  paymentCustomizationUpdate: PaymentCustomizationUpdatePayload
  paymentReminderSend: PaymentReminderSendPayload
  paymentTermsCreate: PaymentTermsCreatePayload
  paymentTermsDelete: PaymentTermsDeletePayload
  paymentTermsUpdate: PaymentTermsUpdatePayload
  priceListCreate: PriceListCreatePayload
  priceListDelete: PriceListDeletePayload
  priceListFixedPricesAdd: PriceListFixedPricesAddPayload
  priceListFixedPricesByProductUpdate: PriceListFixedPricesByProductUpdatePayload
  priceListFixedPricesDelete: PriceListFixedPricesDeletePayload
  priceListFixedPricesUpdate: PriceListFixedPricesUpdatePayload
  priceListUpdate: PriceListUpdatePayload
  productBundleCreate: ProductBundleCreatePayload
  productBundleUpdate: ProductBundleUpdatePayload
  productChangeStatus: ProductChangeStatusPayload
  productCreate: ProductCreatePayload
  productCreateMedia: ProductCreateMediaPayload
  productDelete: ProductDeletePayload
  productDeleteMedia: ProductDeleteMediaPayload
  productDuplicate: ProductDuplicatePayload
  productFeedCreate: ProductFeedCreatePayload
  productFeedDelete: ProductFeedDeletePayload
  productFullSync: ProductFullSyncPayload
  productJoinSellingPlanGroups: ProductJoinSellingPlanGroupsPayload
  productLeaveSellingPlanGroups: ProductLeaveSellingPlanGroupsPayload
  productOptionUpdate: ProductOptionUpdatePayload
  productOptionsCreate: ProductOptionsCreatePayload
  productOptionsDelete: ProductOptionsDeletePayload
  productOptionsReorder: ProductOptionsReorderPayload
  productPublish: ProductPublishPayload
  productReorderMedia: ProductReorderMediaPayload
  productSet: ProductSetPayload
  productUnpublish: ProductUnpublishPayload
  productUpdate: ProductUpdatePayload
  productUpdateMedia: ProductUpdateMediaPayload
  productVariantAppendMedia: ProductVariantAppendMediaPayload
  productVariantDetachMedia: ProductVariantDetachMediaPayload
  productVariantJoinSellingPlanGroups: ProductVariantJoinSellingPlanGroupsPayload
  productVariantLeaveSellingPlanGroups: ProductVariantLeaveSellingPlanGroupsPayload
  productVariantRelationshipBulkUpdate: ProductVariantRelationshipBulkUpdatePayload
  productVariantsBulkCreate: ProductVariantsBulkCreatePayload
  productVariantsBulkDelete: ProductVariantsBulkDeletePayload
  productVariantsBulkReorder: ProductVariantsBulkReorderPayload
  productVariantsBulkUpdate: ProductVariantsBulkUpdatePayload
  pubSubServerPixelUpdate: PubSubServerPixelUpdatePayload
  pubSubWebhookSubscriptionCreate: PubSubWebhookSubscriptionCreatePayload
  pubSubWebhookSubscriptionUpdate: PubSubWebhookSubscriptionUpdatePayload
  publicationCreate: PublicationCreatePayload
  publicationDelete: PublicationDeletePayload
  publicationUpdate: PublicationUpdatePayload
  publishablePublish: PublishablePublishPayload
  publishablePublishToCurrentChannel: PublishablePublishToCurrentChannelPayload
  publishableUnpublish: PublishableUnpublishPayload
  publishableUnpublishToCurrentChannel: PublishableUnpublishToCurrentChannelPayload
  quantityPricingByVariantUpdate: QuantityPricingByVariantUpdatePayload
  quantityRulesAdd: QuantityRulesAddPayload
  quantityRulesDelete: QuantityRulesDeletePayload
  refundCreate: RefundCreatePayload
  returnApproveRequest: ReturnApproveRequestPayload
  returnCancel: ReturnCancelPayload
  returnClose: ReturnClosePayload
  returnCreate: ReturnCreatePayload
  returnDeclineRequest: ReturnDeclineRequestPayload
  returnLineItemRemoveFromReturn: ReturnLineItemRemoveFromReturnPayload
  returnRefund: ReturnRefundPayload
  returnReopen: ReturnReopenPayload
  returnRequest: ReturnRequestPayload
  reverseDeliveryCreateWithShipping: ReverseDeliveryCreateWithShippingPayload
  reverseDeliveryShippingUpdate: ReverseDeliveryShippingUpdatePayload
  reverseFulfillmentOrderDispose: ReverseFulfillmentOrderDisposePayload
  savedSearchCreate: SavedSearchCreatePayload
  savedSearchDelete: SavedSearchDeletePayload
  savedSearchUpdate: SavedSearchUpdatePayload
  scriptTagCreate: ScriptTagCreatePayload
  scriptTagDelete: ScriptTagDeletePayload
  scriptTagUpdate: ScriptTagUpdatePayload
  segmentCreate: SegmentCreatePayload
  segmentDelete: SegmentDeletePayload
  segmentUpdate: SegmentUpdatePayload
  sellingPlanGroupAddProductVariants: SellingPlanGroupAddProductVariantsPayload
  sellingPlanGroupAddProducts: SellingPlanGroupAddProductsPayload
  sellingPlanGroupCreate: SellingPlanGroupCreatePayload
  sellingPlanGroupDelete: SellingPlanGroupDeletePayload
  sellingPlanGroupRemoveProductVariants: SellingPlanGroupRemoveProductVariantsPayload
  sellingPlanGroupRemoveProducts: SellingPlanGroupRemoveProductsPayload
  sellingPlanGroupUpdate: SellingPlanGroupUpdatePayload
  serverPixelCreate: ServerPixelCreatePayload
  serverPixelDelete: ServerPixelDeletePayload
  shippingPackageDelete: ShippingPackageDeletePayload
  shippingPackageMakeDefault: ShippingPackageMakeDefaultPayload
  shippingPackageUpdate: ShippingPackageUpdatePayload
  shopLocaleDisable: ShopLocaleDisablePayload
  shopLocaleEnable: ShopLocaleEnablePayload
  shopLocaleUpdate: ShopLocaleUpdatePayload
  shopPolicyUpdate: ShopPolicyUpdatePayload
  shopResourceFeedbackCreate: ShopResourceFeedbackCreatePayload
  shopifyPaymentsPayoutAlternateCurrencyCreate: ShopifyPaymentsPayoutAlternateCurrencyCreatePayload
  stagedUploadTargetGenerate: StagedUploadTargetGeneratePayload
  stagedUploadTargetsGenerate: StagedUploadTargetsGeneratePayload
  stagedUploadsCreate: StagedUploadsCreatePayload
  standardMetafieldDefinitionEnable: StandardMetafieldDefinitionEnablePayload
  standardMetaobjectDefinitionEnable: StandardMetaobjectDefinitionEnablePayload
  storeCreditAccountCredit: StoreCreditAccountCreditPayload
  storeCreditAccountDebit: StoreCreditAccountDebitPayload
  storefrontAccessTokenCreate: StorefrontAccessTokenCreatePayload
  storefrontAccessTokenDelete: StorefrontAccessTokenDeletePayload
  subscriptionBillingAttemptCreate: SubscriptionBillingAttemptCreatePayload
  subscriptionBillingCycleBulkCharge: SubscriptionBillingCycleBulkChargePayload
  subscriptionBillingCycleBulkSearch: SubscriptionBillingCycleBulkSearchPayload
  subscriptionBillingCycleCharge: SubscriptionBillingCycleChargePayload
  subscriptionBillingCycleContractDraftCommit: SubscriptionBillingCycleContractDraftCommitPayload
  subscriptionBillingCycleContractDraftConcatenate: SubscriptionBillingCycleContractDraftConcatenatePayload
  subscriptionBillingCycleContractEdit: SubscriptionBillingCycleContractEditPayload
  subscriptionBillingCycleEditDelete: SubscriptionBillingCycleEditDeletePayload
  subscriptionBillingCycleEditsDelete: SubscriptionBillingCycleEditsDeletePayload
  subscriptionBillingCycleScheduleEdit: SubscriptionBillingCycleScheduleEditPayload
  subscriptionBillingCycleSkip: SubscriptionBillingCycleSkipPayload
  subscriptionBillingCycleUnskip: SubscriptionBillingCycleUnskipPayload
  subscriptionContractActivate: SubscriptionContractActivatePayload
  subscriptionContractAtomicCreate: SubscriptionContractAtomicCreatePayload
  subscriptionContractCancel: SubscriptionContractCancelPayload
  subscriptionContractCreate: SubscriptionContractCreatePayload
  subscriptionContractExpire: SubscriptionContractExpirePayload
  subscriptionContractFail: SubscriptionContractFailPayload
  subscriptionContractPause: SubscriptionContractPausePayload
  subscriptionContractProductChange: SubscriptionContractProductChangePayload
  subscriptionContractSetNextBillingDate: SubscriptionContractSetNextBillingDatePayload
  subscriptionContractUpdate: SubscriptionContractUpdatePayload
  subscriptionDraftCommit: SubscriptionDraftCommitPayload
  subscriptionDraftDiscountAdd: SubscriptionDraftDiscountAddPayload
  subscriptionDraftDiscountCodeApply: SubscriptionDraftDiscountCodeApplyPayload
  subscriptionDraftDiscountRemove: SubscriptionDraftDiscountRemovePayload
  subscriptionDraftDiscountUpdate: SubscriptionDraftDiscountUpdatePayload
  subscriptionDraftFreeShippingDiscountAdd: SubscriptionDraftFreeShippingDiscountAddPayload
  subscriptionDraftFreeShippingDiscountUpdate: SubscriptionDraftFreeShippingDiscountUpdatePayload
  subscriptionDraftLineAdd: SubscriptionDraftLineAddPayload
  subscriptionDraftLineRemove: SubscriptionDraftLineRemovePayload
  subscriptionDraftLineUpdate: SubscriptionDraftLineUpdatePayload
  subscriptionDraftUpdate: SubscriptionDraftUpdatePayload
  tagsAdd: TagsAddPayload
  tagsRemove: TagsRemovePayload
  taxAppConfigure: TaxAppConfigurePayload
  themeCreate: ThemeCreatePayload
  themeDelete: ThemeDeletePayload
  themeFilesCopy: ThemeFilesCopyPayload
  themeFilesDelete: ThemeFilesDeletePayload
  themeFilesUpsert: ThemeFilesUpsertPayload
  themePublish: ThemePublishPayload
  themeUpdate: ThemeUpdatePayload
  transactionVoid: TransactionVoidPayload
  translationsRegister: TranslationsRegisterPayload
  translationsRemove: TranslationsRemovePayload
  urlRedirectBulkDeleteAll: UrlRedirectBulkDeleteAllPayload
  urlRedirectBulkDeleteByIds: UrlRedirectBulkDeleteByIdsPayload
  urlRedirectBulkDeleteBySavedSearch: UrlRedirectBulkDeleteBySavedSearchPayload
  urlRedirectBulkDeleteBySearch: UrlRedirectBulkDeleteBySearchPayload
  urlRedirectCreate: UrlRedirectCreatePayload
  urlRedirectDelete: UrlRedirectDeletePayload
  urlRedirectImportCreate: UrlRedirectImportCreatePayload
  urlRedirectImportSubmit: UrlRedirectImportSubmitPayload
  urlRedirectUpdate: UrlRedirectUpdatePayload
  validationCreate: ValidationCreatePayload
  validationDelete: ValidationDeletePayload
  validationUpdate: ValidationUpdatePayload
  webPixelCreate: WebPixelCreatePayload
  webPixelDelete: WebPixelDeletePayload
  webPixelUpdate: WebPixelUpdatePayload
  webhookSubscriptionCreate: WebhookSubscriptionCreatePayload
  webhookSubscriptionDelete: WebhookSubscriptionDeletePayload
  webhookSubscriptionUpdate: WebhookSubscriptionUpdatePayload
}
type MutationsStagedUploadTargetGenerateUploadParameter {
  name: String!
  value: String!
}
interface Navigable {
  defaultCursor: String!
}
type NavigationItem {
  id: String!
  title: String!
  url: URL!
}
interface Node {
  id: ID!
}
input ObjectDimensionsInput {
  length: Float!
  width: Float!
  height: Float!
  unit: LengthUnit!
}
type OnlineStore {
  passwordProtection: OnlineStorePasswordProtection!
}
type OnlineStorePasswordProtection {
  enabled: Boolean!
}
interface OnlineStorePreviewable {
  onlineStorePreviewUrl: URL
}
type OnlineStoreTheme {
  createdAt: DateTime!
  files: OnlineStoreThemeFileConnection
  id: ID!
  name: String!
  prefix: String!
  processing: Boolean!
  processingFailed: Boolean!
  role: ThemeRole!
  themeStoreId: Int
  translations: [Translation!]!
  updatedAt: DateTime!
}
type OnlineStoreThemeConnection {
  edges: [OnlineStoreThemeEdge!]!
  nodes: [OnlineStoreTheme!]!
  pageInfo: PageInfo!
}
type OnlineStoreThemeEdge {
  cursor: String!
  node: OnlineStoreTheme!
}
type OnlineStoreThemeFile {
  body: OnlineStoreThemeFileBody!
  checksumMd5: String
  contentType: String!
  createdAt: DateTime!
  filename: String!
  size: UnsignedInt64!
  updatedAt: DateTime!
}
union OnlineStoreThemeFileBody = OnlineStoreThemeFileBodyBase64 | OnlineStoreThemeFileBodyText | OnlineStoreThemeFileBodyUrl
type OnlineStoreThemeFileBodyBase64 {
  contentBase64: String!
}
input OnlineStoreThemeFileBodyInput {
  type: OnlineStoreThemeFileBodyInputType!
  value: String!
}
enum OnlineStoreThemeFileBodyInputType {
  TEXT
  BASE64
  URL
}
type OnlineStoreThemeFileBodyText {
  content: String!
}
type OnlineStoreThemeFileBodyUrl {
  url: URL!
}
type OnlineStoreThemeFileConnection {
  edges: [OnlineStoreThemeFileEdge!]!
  nodes: [OnlineStoreThemeFile!]!
  pageInfo: PageInfo!
  userErrors: [OnlineStoreThemeFileReadResult!]!
}
type OnlineStoreThemeFileEdge {
  cursor: String!
  node: OnlineStoreThemeFile!
}
type OnlineStoreThemeFileOperationResult {
  filename: String!
}
type OnlineStoreThemeFileReadResult {
  code: OnlineStoreThemeFileResultType!
  filename: String!
}
enum OnlineStoreThemeFileResultType {
  SUCCESS
  ERROR
  CONFLICT
  UNPROCESSABLE_ENTITY
  BAD_REQUEST
  TIMEOUT
  NOT_FOUND
}
input OnlineStoreThemeFilesUpsertFileInput {
  filename: String!
  body: OnlineStoreThemeFileBodyInput!
}
type OnlineStoreThemeFilesUserErrors {
  code: OnlineStoreThemeFilesUserErrorsCode
  field: [String!]
  filename: String
  message: String!
}
enum OnlineStoreThemeFilesUserErrorsCode {
  NOT_FOUND
  LESS_THAN_OR_EQUAL_TO
  THEME_FILES_CONFLICT
  DUPLICATE_FILE_INPUT
  ACCESS_DENIED
  THEME_LIMITED_PLAN
  FILE_VALIDATION_ERROR
  ERROR
  THROTTLED
}
input OnlineStoreThemeInput {
  name: String
}
input OptionAndValueInput {
  name: String!
  values: [String!]!
  optionId: ID
  linkedMetafield: LinkedMetafieldInput
}
input OptionCreateInput {
  name: String
  position: Int
  values: [OptionValueCreateInput!]
  linkedMetafield: LinkedMetafieldCreateInput
}
input OptionReorderInput {
  id: ID
  name: String
  values: [OptionValueReorderInput!]
}
input OptionSetInput {
  id: ID
  name: String
  position: Int
  values: [OptionValueSetInput!]
  linkedMetafield: LinkedMetafieldCreateInput
}
input OptionUpdateInput {
  id: ID!
  name: String
  position: Int
  linkedMetafield: LinkedMetafieldUpdateInput
}
input OptionValueCreateInput {
  name: String
  linkedMetafieldValue: String
}
input OptionValueReorderInput {
  id: ID
  name: String
}
input OptionValueSetInput {
  id: ID
  name: String
}
input OptionValueUpdateInput {
  id: ID!
  name: String
  linkedMetafieldValue: String
}
type Order {
  additionalFees: [AdditionalFee!]!
  agreements: SalesAgreementConnection!
  alerts: [ResourceAlert!]!
  app: OrderApp
  billingAddress: MailingAddress
  billingAddressMatchesShippingAddress: Boolean!
  canMarkAsPaid: Boolean!
  canNotifyCustomer: Boolean!
  cancelReason: OrderCancelReason
  cancellation: OrderCancellation
  cancelledAt: DateTime
  capturable: Boolean!
  cartDiscountAmount: Money
  cartDiscountAmountSet: MoneyBag
  channel: Channel
  channelInformation: ChannelInformation
  clientIp: String
  closed: Boolean!
  closedAt: DateTime
  confirmationNumber: String
  confirmed: Boolean!
  createdAt: DateTime!
  currencyCode: CurrencyCode!
  currentCartDiscountAmountSet: MoneyBag!
  currentShippingPriceSet: MoneyBag!
  currentSubtotalLineItemsQuantity: Int!
  currentSubtotalPriceSet: MoneyBag!
  currentTaxLines: [TaxLine!]!
  currentTotalAdditionalFeesSet: MoneyBag
  currentTotalDiscountsSet: MoneyBag!
  currentTotalDutiesSet: MoneyBag
  currentTotalPriceSet: MoneyBag!
  currentTotalTaxSet: MoneyBag!
  currentTotalWeight: UnsignedInt64!
  customAttributes: [Attribute!]!
  customer: Customer
  customerAcceptsMarketing: Boolean!
  customerJourney: CustomerJourney
  customerJourneySummary: CustomerJourneySummary
  customerLocale: String
  discountApplications: DiscountApplicationConnection!
  discountCode: String
  discountCodes: [String!]!
  displayAddress: MailingAddress
  displayFinancialStatus: OrderDisplayFinancialStatus
  displayFulfillmentStatus: OrderDisplayFulfillmentStatus!
  disputes: [OrderDisputeSummary!]!
  dutiesIncluded: Boolean!
  edited: Boolean!
  email: String
  estimatedTaxes: Boolean!
  events: EventConnection!
  exchangeV2s: ExchangeV2Connection!
  fulfillable: Boolean!
  fulfillmentOrders: FulfillmentOrderConnection!
  fulfillments: [Fulfillment!]!
  fulfillmentsCount: Count
  fullyPaid: Boolean!
  hasTimelineComment: Boolean!
  id: ID!
  landingPageDisplayText: String
  landingPageUrl: URL
  legacyResourceId: UnsignedInt64!
  lineItems: LineItemConnection!
  localizationExtensions: LocalizationExtensionConnection!
  localizedFields: LocalizedFieldConnection!
  merchantBusinessEntity: BusinessEntity!
  merchantEditable: Boolean!
  merchantEditableErrors: [String!]!
  merchantOfRecordApp: OrderApp
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  name: String!
  netPayment: Money!
  netPaymentSet: MoneyBag!
  nonFulfillableLineItems: LineItemConnection!
  note: String
  originalTotalAdditionalFeesSet: MoneyBag
  originalTotalDutiesSet: MoneyBag
  originalTotalPriceSet: MoneyBag!
  paymentCollectionDetails: OrderPaymentCollectionDetails!
  paymentGatewayNames: [String!]!
  paymentTerms: PaymentTerms
  phone: String
  physicalLocation: Location
  poNumber: String
  presentmentCurrencyCode: CurrencyCode!
  processedAt: DateTime!
  publication: Publication
  purchasingEntity: PurchasingEntity
  referralCode: String
  referrerDisplayText: String
  referrerUrl: URL
  refundDiscrepancySet: MoneyBag!
  refundable: Boolean!
  refunds: [Refund!]!
  registeredSourceUrl: URL
  requiresShipping: Boolean!
  restockable: Boolean!
  retailLocation: Location
  returnStatus: OrderReturnStatus!
  returns: ReturnConnection!
  risk: OrderRiskSummary!
  riskLevel: OrderRiskLevel!
  risks: [OrderRisk!]!
  shippingAddress: MailingAddress
  shippingLine: ShippingLine
  shippingLines: ShippingLineConnection!
  shopifyProtect: ShopifyProtectOrderSummary
  sourceIdentifier: String
  sourceName: String
  staffMember: StaffMember
  statusPageUrl: URL!
  subtotalLineItemsQuantity: Int!
  subtotalPrice: Money
  subtotalPriceSet: MoneyBag
  suggestedRefund: SuggestedRefund
  tags: [String!]!
  taxExempt: Boolean!
  taxLines: [TaxLine!]!
  taxesIncluded: Boolean!
  test: Boolean!
  totalCapturable: Money!
  totalCapturableSet: MoneyBag!
  totalCashRoundingAdjustment: CashRoundingAdjustment!
  totalDiscounts: Money
  totalDiscountsSet: MoneyBag
  totalOutstandingSet: MoneyBag!
  totalPrice: Money!
  totalPriceSet: MoneyBag!
  totalReceived: Money!
  totalReceivedSet: MoneyBag!
  totalRefunded: Money!
  totalRefundedSet: MoneyBag!
  totalRefundedShippingSet: MoneyBag!
  totalShippingPrice: Money!
  totalShippingPriceSet: MoneyBag!
  totalTax: Money
  totalTaxSet: MoneyBag
  totalTipReceived: MoneyV2!
  totalTipReceivedSet: MoneyBag!
  totalWeight: UnsignedInt64
  transactions: [OrderTransaction!]!
  transactionsCount: Count
  unpaid: Boolean!
  updatedAt: DateTime!
}
enum OrderActionType {
  ORDER
  ORDER_EDIT
  REFUND
  RETURN
  UNKNOWN
}
type OrderAdjustment {
  amountSet: MoneyBag!
  id: ID!
  reason: OrderAdjustmentDiscrepancyReason
  taxAmountSet: MoneyBag!
}
type OrderAdjustmentConnection {
  edges: [OrderAdjustmentEdge!]!
  nodes: [OrderAdjustment!]!
  pageInfo: PageInfo!
}
enum OrderAdjustmentDiscrepancyReason {
  RESTOCK
  DAMAGE
  CUSTOMER
  REFUND_DISCREPANCY
  FULL_RETURN_BALANCING_ADJUSTMENT
  PENDING_REFUND_DISCREPANCY
}
type OrderAdjustmentEdge {
  cursor: String!
  node: OrderAdjustment!
}
enum OrderAdjustmentInputDiscrepancyReason {
  RESTOCK
  DAMAGE
  CUSTOMER
  OTHER
}
type OrderAgreement {
  app: App
  happenedAt: DateTime!
  id: ID!
  order: Order!
  reason: OrderActionType!
  sales: SaleConnection!
  user: StaffMember
}
type OrderApp {
  icon: Image!
  id: ID!
  name: String!
}
type OrderCancelPayload {
  job: Job
  orderCancelUserErrors: [OrderCancelUserError!]!
  userErrors: [UserError!]!
}
enum OrderCancelReason {
  CUSTOMER
  DECLINED
  FRAUD
  INVENTORY
  STAFF
  OTHER
}
type OrderCancelUserError {
  code: OrderCancelUserErrorCode
  field: [String!]
  message: String!
}
enum OrderCancelUserErrorCode {
  NO_REFUND_PERMISSION
  NOT_FOUND
  INVALID
}
type OrderCancellation {
  staffNote: String
}
input OrderCaptureInput {
  id: ID!
  parentTransactionId: ID!
  amount: Money!
  currency: CurrencyCode
  finalCapture: Boolean
}
type OrderCapturePayload {
  transaction: OrderTransaction
  userErrors: [UserError!]!
}
input OrderCloseInput {
  id: ID!
}
type OrderClosePayload {
  order: Order
  userErrors: [UserError!]!
}
type OrderConnection {
  edges: [OrderEdge!]!
  nodes: [Order!]!
  pageInfo: PageInfo!
}
input OrderCreateAssociateCustomerAttributesInput {
  id: ID
  email: String
}
input OrderCreateCustomAttributeInput {
  key: String!
  value: String!
}
input OrderCreateCustomerAddressInput {
  address1: String
  address2: String
  city: String
  company: String
  country: String
  firstName: String
  lastName: String
  phone: String
  province: String
  zip: String
}
input OrderCreateCustomerInput {
  toAssociate: OrderCreateAssociateCustomerAttributesInput
  toUpsert: OrderCreateUpsertCustomerAttributesInput
}
input OrderCreateDiscountCodeInput {
  itemPercentageDiscountCode: OrderCreatePercentageDiscountCodeAttributesInput
  itemFixedDiscountCode: OrderCreateFixedDiscountCodeAttributesInput
  freeShippingDiscountCode: OrderCreateFreeShippingDiscountCodeAttributesInput
}
enum OrderCreateFinancialStatus {
  PENDING
  AUTHORIZED
  PARTIALLY_PAID
  PAID
  PARTIALLY_REFUNDED
  REFUNDED
  VOIDED
  EXPIRED
}
input OrderCreateFixedDiscountCodeAttributesInput {
  code: String!
  amountSet: MoneyBagInput
}
input OrderCreateFreeShippingDiscountCodeAttributesInput {
  code: String!
}
input OrderCreateFulfillmentInput {
  locationId: ID!
  originAddress: FulfillmentOriginAddressInput
  notifyCustomer: Boolean
  shipmentStatus: FulfillmentEventStatus
  trackingNumber: String
  trackingCompany: String
}
enum OrderCreateFulfillmentStatus {
  FULFILLED
  PARTIAL
  RESTOCKED
}
enum OrderCreateInputsInventoryBehavior {
  BYPASS
  DECREMENT_IGNORING_POLICY
  DECREMENT_OBEYING_POLICY
}
input OrderCreateLineItemInput {
  fulfillmentService: String
  giftCard: Boolean
  priceSet: MoneyBagInput
  productId: ID
  properties: [OrderCreateLineItemPropertyInput!]
  quantity: Int!
  requiresShipping: Boolean
  sku: String
  taxLines: [OrderCreateTaxLineInput!]
  taxable: Boolean
  title: String
  variantId: ID
  variantTitle: String
  vendor: String
}
input OrderCreateLineItemPropertyInput {
  name: String!
  value: String!
}
type OrderCreateMandatePaymentPayload {
  job: Job
  paymentReferenceId: String
  userErrors: [OrderCreateMandatePaymentUserError!]!
}
type OrderCreateMandatePaymentUserError {
  code: OrderCreateMandatePaymentUserErrorCode
  field: [String!]
  message: String!
}
enum OrderCreateMandatePaymentUserErrorCode {
  ORDER_MANDATE_PAYMENT_ERROR_CODE
}
input OrderCreateOptionsInput {
  inventoryBehaviour: OrderCreateInputsInventoryBehavior
  sendReceipt: Boolean
  sendFulfillmentReceipt: Boolean
}
input OrderCreateOrderInput {
  billingAddress: MailingAddressInput
  buyerAcceptsMarketing: Boolean
  closedAt: DateTime
  companyLocationId: ID
  currency: CurrencyCode
  customAttributes: [OrderCreateCustomAttributeInput!]
  customer: OrderCreateCustomerInput
  discountCode: OrderCreateDiscountCodeInput
  email: String
  financialStatus: OrderCreateFinancialStatus
  fulfillment: OrderCreateFulfillmentInput
  fulfillmentStatus: OrderCreateFulfillmentStatus
  lineItems: [OrderCreateLineItemInput!]
  metafields: [MetafieldInput!]
  name: String
  note: String
  phone: String
  poNumber: String
  presentmentCurrency: CurrencyCode
  processedAt: DateTime
  referringSite: URL
  shippingAddress: MailingAddressInput
  shippingLines: [OrderCreateShippingLineInput!]
  sourceIdentifier: String
  sourceName: String
  sourceUrl: URL
  tags: [String!]
  taxesIncluded: Boolean
  taxLines: [OrderCreateTaxLineInput!]
  test: Boolean
  transactions: [OrderCreateOrderTransactionInput!]
  userId: ID
}
input OrderCreateOrderTransactionInput {
  amountSet: MoneyBagInput!
  authorizationCode: String
  deviceId: ID
  gateway: String
  giftCardId: ID
  kind: OrderTransactionKind
  locationId: ID
  processedAt: DateTime
  receiptJson: JSON
  status: OrderTransactionStatus
  test: Boolean
  userId: ID
}
type OrderCreatePayload {
  order: Order
  userErrors: [OrderCreateUserError!]!
}
input OrderCreatePercentageDiscountCodeAttributesInput {
  code: String!
  percentage: Float
}
input OrderCreateShippingLineInput {
  code: String
  priceSet: MoneyBagInput!
  source: String
  taxLines: [OrderCreateTaxLineInput!]
  title: String!
}
input OrderCreateTaxLineInput {
  channelLiable: Boolean
  priceSet: MoneyBagInput
  rate: Decimal!
  title: String!
}
input OrderCreateUpsertCustomerAttributesInput {
  addresses: [OrderCreateCustomerAddressInput!]
  email: String
  firstName: String
  id: ID
  lastName: String
  multipassIdentifier: String
  note: String
  phone: String
  tags: [String!]
  taxExempt: Boolean
}
type OrderCreateUserError {
  code: OrderCreateUserErrorCode
  field: [String!]
  message: String!
}
enum OrderCreateUserErrorCode {
  INVALID
  FULFILLMENT_SERVICE_INVALID
  INVENTORY_CLAIM_FAILED
  PROCESSED_AT_INVALID
  TAX_LINE_RATE_MISSING
  REDUNDANT_CUSTOMER_FIELDS
  SHOP_DORMANT
}
type OrderDeletePayload {
  deletedId: ID
  userErrors: [OrderDeleteUserError!]!
}
type OrderDeleteUserError {
  code: OrderDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum OrderDeleteUserErrorCode {
  NOT_FOUND
  INVALID
}
enum OrderDisplayFinancialStatus {
  PENDING
  AUTHORIZED
  PARTIALLY_PAID
  PARTIALLY_REFUNDED
  VOIDED
  PAID
  REFUNDED
  EXPIRED
}
enum OrderDisplayFulfillmentStatus {
  UNFULFILLED
  PARTIALLY_FULFILLED
  FULFILLED
  RESTOCKED
  PENDING_FULFILLMENT
  OPEN
  IN_PROGRESS
  ON_HOLD
  SCHEDULED
  REQUEST_DECLINED
}
type OrderDisputeSummary {
  id: ID!
  initiatedAs: DisputeType!
  status: DisputeStatus!
}
type OrderEdge {
  cursor: String!
  node: Order!
}
type OrderEditAddCustomItemPayload {
  calculatedLineItem: CalculatedLineItem
  calculatedOrder: CalculatedOrder
  userErrors: [UserError!]!
}
type OrderEditAddLineItemDiscountPayload {
  addedDiscountStagedChange: OrderStagedChangeAddLineItemDiscount
  calculatedLineItem: CalculatedLineItem
  calculatedOrder: CalculatedOrder
  userErrors: [UserError!]!
}
input OrderEditAddShippingLineInput {
  price: MoneyInput!
  title: String!
}
type OrderEditAddShippingLinePayload {
  calculatedOrder: CalculatedOrder
  calculatedShippingLine: CalculatedShippingLine
  userErrors: [OrderEditAddShippingLineUserError!]!
}
type OrderEditAddShippingLineUserError {
  code: OrderEditAddShippingLineUserErrorCode
  field: [String!]
  message: String!
}
enum OrderEditAddShippingLineUserErrorCode {
  INVALID
}
type OrderEditAddVariantPayload {
  calculatedLineItem: CalculatedLineItem
  calculatedOrder: CalculatedOrder
  userErrors: [UserError!]!
}
type OrderEditAgreement {
  app: App
  happenedAt: DateTime!
  id: ID!
  reason: OrderActionType!
  sales: SaleConnection!
  user: StaffMember
}
input OrderEditAppliedDiscountInput {
  description: String
  fixedValue: MoneyInput
  percentValue: Float
}
type OrderEditBeginPayload {
  calculatedOrder: CalculatedOrder
  userErrors: [UserError!]!
}
type OrderEditCommitPayload {
  order: Order
  userErrors: [UserError!]!
}
type OrderEditRemoveDiscountPayload {
  calculatedOrder: CalculatedOrder
  userErrors: [OrderEditRemoveDiscountUserError!]!
}
type OrderEditRemoveDiscountUserError {
  code: OrderEditRemoveDiscountUserErrorCode
  field: [String!]
  message: String!
}
enum OrderEditRemoveDiscountUserErrorCode {
  INVALID
}
type OrderEditRemoveLineItemDiscountPayload {
  calculatedLineItem: CalculatedLineItem
  calculatedOrder: CalculatedOrder
  userErrors: [UserError!]!
}
type OrderEditRemoveShippingLinePayload {
  calculatedOrder: CalculatedOrder
  userErrors: [OrderEditRemoveShippingLineUserError!]!
}
type OrderEditRemoveShippingLineUserError {
  code: OrderEditRemoveShippingLineUserErrorCode
  field: [String!]
  message: String!
}
enum OrderEditRemoveShippingLineUserErrorCode {
  INVALID
}
type OrderEditSetQuantityPayload {
  calculatedLineItem: CalculatedLineItem
  calculatedOrder: CalculatedOrder
  userErrors: [UserError!]!
}
type OrderEditUpdateDiscountPayload {
  calculatedOrder: CalculatedOrder
  userErrors: [OrderEditUpdateDiscountUserError!]!
}
type OrderEditUpdateDiscountUserError {
  code: OrderEditUpdateDiscountUserErrorCode
  field: [String!]
  message: String!
}
enum OrderEditUpdateDiscountUserErrorCode {
  INVALID
}
input OrderEditUpdateShippingLineInput {
  price: MoneyInput
  title: String
}
type OrderEditUpdateShippingLinePayload {
  calculatedOrder: CalculatedOrder
  userErrors: [OrderEditUpdateShippingLineUserError!]!
}
type OrderEditUpdateShippingLineUserError {
  code: OrderEditUpdateShippingLineUserErrorCode
  field: [String!]
  message: String!
}
enum OrderEditUpdateShippingLineUserErrorCode {
  INVALID
}
input OrderInput {
  id: ID!
  email: String
  note: String
  tags: [String!]
  shippingAddress: MailingAddressInput
  customAttributes: [AttributeInput!]
  metafields: [MetafieldInput!]
  localizedFields: [LocalizedFieldInput!]
  poNumber: String
}
type OrderInvoiceSendPayload {
  order: Order
  userErrors: [OrderInvoiceSendUserError!]!
}
type OrderInvoiceSendUserError {
  code: OrderInvoiceSendUserErrorCode
  field: [String!]
  message: String!
}
enum OrderInvoiceSendUserErrorCode {
  ORDER_INVOICE_SEND_UNSUCCESSFUL
}
input OrderMarkAsPaidInput {
  id: ID!
}
type OrderMarkAsPaidPayload {
  order: Order
  userErrors: [UserError!]!
}
input OrderOpenInput {
  id: ID!
}
type OrderOpenPayload {
  order: Order
  userErrors: [UserError!]!
}
type OrderPaymentCollectionDetails {
  additionalPaymentCollectionUrl: URL
  vaultedPaymentMethods: [PaymentMandate!]
}
type OrderPaymentStatus {
  errorMessage: String
  paymentReferenceId: String!
  status: OrderPaymentStatusResult!
  transactions: [OrderTransaction!]!
  translatedErrorMessage: String
}
enum OrderPaymentStatusResult {
  SUCCESS
  AUTHORIZED
  VOIDED
  REFUNDED
  CAPTURED
  PURCHASED
  ERROR
  PROCESSING
  REDIRECT_REQUIRED
  RETRYABLE
  UNKNOWN
  INITIATED
  PENDING
}
enum OrderReturnStatus {
  IN_PROGRESS
  INSPECTION_COMPLETE
  NO_RETURN
  RETURNED
  RETURN_FAILED
  RETURN_REQUESTED
}
type OrderRisk {
  display: Boolean!
  level: OrderRiskLevel
  message: String
}
type OrderRiskAssessment {
  facts: [RiskFact!]!
  provider: App
  riskLevel: RiskAssessmentResult!
}
input OrderRiskAssessmentCreateInput {
  orderId: ID!
  riskLevel: RiskAssessmentResult!
  facts: [OrderRiskAssessmentFactInput!]!
}
type OrderRiskAssessmentCreatePayload {
  orderRiskAssessment: OrderRiskAssessment
  userErrors: [OrderRiskAssessmentCreateUserError!]!
}
type OrderRiskAssessmentCreateUserError {
  code: OrderRiskAssessmentCreateUserErrorCode
  field: [String!]
  message: String!
}
enum OrderRiskAssessmentCreateUserErrorCode {
  TOO_MANY_FACTS
  ORDER_ALREADY_FULFILLED
  INVALID
  NOT_FOUND
}
input OrderRiskAssessmentFactInput {
  sentiment: RiskFactSentiment!
  description: String!
}
enum OrderRiskLevel {
  LOW
  MEDIUM
  HIGH
}
enum OrderRiskRecommendationResult {
  CANCEL
  INVESTIGATE
  ACCEPT
  NONE
}
type OrderRiskSummary {
  assessments: [OrderRiskAssessment!]!
  recommendation: OrderRiskRecommendationResult!
}
enum OrderSortKeys {
  CREATED_AT
  CUSTOMER_NAME
  DESTINATION
  FINANCIAL_STATUS
  FULFILLMENT_STATUS
  ID
  ORDER_NUMBER
  PO_NUMBER
  PROCESSED_AT
  RELEVANCE
  TOTAL_ITEMS_QUANTITY
  TOTAL_PRICE
  UPDATED_AT
}
union OrderStagedChange = OrderStagedChangeAddCustomItem | OrderStagedChangeAddLineItemDiscount | OrderStagedChangeAddShippingLine | OrderStagedChangeAddVariant | OrderStagedChangeDecrementItem | OrderStagedChangeIncrementItem | OrderStagedChangeRemoveShippingLine
type OrderStagedChangeAddCustomItem {
  originalUnitPrice: MoneyV2!
  quantity: Int!
  title: String!
}
type OrderStagedChangeAddLineItemDiscount {
  description: String!
  id: ID!
  value: PricingValue!
}
type OrderStagedChangeAddShippingLine {
  phone: String
  presentmentTitle: String
  price: MoneyV2!
  title: String
}
type OrderStagedChangeAddVariant {
  quantity: Int!
  variant: ProductVariant!
}
type OrderStagedChangeConnection {
  edges: [OrderStagedChangeEdge!]!
  nodes: [OrderStagedChange!]!
  pageInfo: PageInfo!
}
type OrderStagedChangeDecrementItem {
  delta: Int!
  lineItem: LineItem!
  restock: Boolean!
}
type OrderStagedChangeEdge {
  cursor: String!
  node: OrderStagedChange!
}
type OrderStagedChangeIncrementItem {
  delta: Int!
  lineItem: LineItem!
}
type OrderStagedChangeRemoveShippingLine {
  shippingLine: ShippingLine!
}
type OrderTransaction {
  accountNumber: String
  amount: Money!
  amountRoundingSet: MoneyBag
  amountSet: MoneyBag!
  amountV2: MoneyV2!
  authorizationCode: String
  authorizationExpiresAt: DateTime
  createdAt: DateTime!
  errorCode: OrderTransactionErrorCode
  fees: [TransactionFee!]!
  formattedGateway: String
  gateway: String
  id: ID!
  kind: OrderTransactionKind!
  manualPaymentGateway: Boolean!
  manuallyCapturable: Boolean!
  maximumRefundable: Money
  maximumRefundableV2: MoneyV2
  multiCapturable: Boolean!
  order: Order
  parentTransaction: OrderTransaction
  paymentDetails: PaymentDetails
  paymentIcon: Image
  paymentId: String
  paymentMethod: PaymentMethods
  processedAt: DateTime
  receiptJson: JSON
  settlementCurrency: CurrencyCode
  settlementCurrencyRate: Decimal
  shopifyPaymentsSet: ShopifyPaymentsTransactionSet
  status: OrderTransactionStatus!
  test: Boolean!
  totalUnsettled: Money
  totalUnsettledSet: MoneyBag
  totalUnsettledV2: MoneyV2
  user: StaffMember
}
type OrderTransactionConnection {
  edges: [OrderTransactionEdge!]!
  nodes: [OrderTransaction!]!
  pageInfo: PageInfo!
}
type OrderTransactionEdge {
  cursor: String!
  node: OrderTransaction!
}
enum OrderTransactionErrorCode {
  INCORRECT_NUMBER
  INVALID_NUMBER
  INVALID_EXPIRY_DATE
  INVALID_CVC
  EXPIRED_CARD
  INCORRECT_CVC
  INCORRECT_ZIP
  INCORRECT_ADDRESS
  INCORRECT_PIN
  CARD_DECLINED
  PROCESSING_ERROR
  CALL_ISSUER
  PICK_UP_CARD
  CONFIG_ERROR
  TEST_MODE_LIVE_CARD
  UNSUPPORTED_FEATURE
  GENERIC_ERROR
  INVALID_COUNTRY
  INVALID_AMOUNT
  PAYMENT_METHOD_UNAVAILABLE
  AMAZON_PAYMENTS_INVALID_PAYMENT_METHOD
  AMAZON_PAYMENTS_MAX_AMOUNT_CHARGED
  AMAZON_PAYMENTS_MAX_AMOUNT_REFUNDED
  AMAZON_PAYMENTS_MAX_AUTHORIZATIONS_CAPTURED
  AMAZON_PAYMENTS_MAX_REFUNDS_PROCESSED
  AMAZON_PAYMENTS_ORDER_REFERENCE_CANCELED
  AMAZON_PAYMENTS_STALE
}
input OrderTransactionInput {
  amount: Money!
  gateway: String!
  kind: OrderTransactionKind!
  orderId: ID!
  parentId: ID
}
enum OrderTransactionKind {
  SALE
  CAPTURE
  AUTHORIZATION
  VOID
  REFUND
  CHANGE
  EMV_AUTHORIZATION
  SUGGESTED_REFUND
}
enum OrderTransactionStatus {
  SUCCESS
  FAILURE
  PENDING
  ERROR
  AWAITING_RESPONSE
  UNKNOWN
}
type OrderUpdatePayload {
  order: Order
  userErrors: [UserError!]!
}
type Page {
  body: HTML!
  bodySummary: String!
  createdAt: DateTime!
  defaultCursor: String!
  events: EventConnection!
  handle: String!
  id: ID!
  isPublished: Boolean!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  publishedAt: DateTime
  templateSuffix: String
  title: String!
  translations: [Translation!]!
  updatedAt: DateTime!
}
type PageConnection {
  edges: [PageEdge!]!
  nodes: [Page!]!
  pageInfo: PageInfo!
}
input PageCreateInput {
  handle: String
  body: String
  isPublished: Boolean
  publishDate: DateTime
  templateSuffix: String
  metafields: [MetafieldInput!]
  title: String!
}
type PageCreatePayload {
  page: Page
  userErrors: [PageCreateUserError!]!
}
type PageCreateUserError {
  code: PageCreateUserErrorCode
  field: [String!]
  message: String!
}
enum PageCreateUserErrorCode {
  INVALID_PUBLISH_DATE
  BLANK
  TOO_LONG
  TAKEN
  INVALID_VALUE
  INVALID_TYPE
}
type PageDeletePayload {
  deletedPageId: ID
  userErrors: [PageDeleteUserError!]!
}
type PageDeleteUserError {
  code: PageDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum PageDeleteUserErrorCode {
  NOT_FOUND
}
type PageEdge {
  cursor: String!
  node: Page!
}
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}
input PageUpdateInput {
  handle: String
  body: String
  isPublished: Boolean
  publishDate: DateTime
  templateSuffix: String
  metafields: [MetafieldInput!]
  title: String
  redirectNewHandle: Boolean
}
type PageUpdatePayload {
  page: Page
  userErrors: [PageUpdateUserError!]!
}
type PageUpdateUserError {
  code: PageUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum PageUpdateUserErrorCode {
  INVALID_PUBLISH_DATE
  NOT_FOUND
  BLANK
  TOO_LONG
  TAKEN
}
type PaymentCustomization {
  enabled: Boolean!
  errorHistory: FunctionsErrorHistory
  functionId: String!
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  shopifyFunction: ShopifyFunction!
  title: String!
}
type PaymentCustomizationActivationPayload {
  ids: [String!]
  userErrors: [PaymentCustomizationError!]!
}
type PaymentCustomizationConnection {
  edges: [PaymentCustomizationEdge!]!
  nodes: [PaymentCustomization!]!
  pageInfo: PageInfo!
}
type PaymentCustomizationCreatePayload {
  paymentCustomization: PaymentCustomization
  userErrors: [PaymentCustomizationError!]!
}
type PaymentCustomizationDeletePayload {
  deletedId: ID
  userErrors: [PaymentCustomizationError!]!
}
type PaymentCustomizationEdge {
  cursor: String!
  node: PaymentCustomization!
}
type PaymentCustomizationError {
  code: PaymentCustomizationErrorCode
  field: [String!]
  message: String!
}
enum PaymentCustomizationErrorCode {
  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE
  FUNCTION_DOES_NOT_IMPLEMENT
  FUNCTION_NOT_FOUND
  FUNCTION_PENDING_DELETION
  INVALID
  PAYMENT_CUSTOMIZATION_NOT_FOUND
  PAYMENT_CUSTOMIZATION_FUNCTION_NOT_ELIGIBLE
  MAXIMUM_ACTIVE_PAYMENT_CUSTOMIZATIONS
  REQUIRED_INPUT_FIELD
  INVALID_METAFIELDS
  FUNCTION_ID_CANNOT_BE_CHANGED
}
input PaymentCustomizationInput {
  functionId: String
  title: String
  enabled: Boolean
  metafields: [MetafieldInput!]
}
type PaymentCustomizationUpdatePayload {
  paymentCustomization: PaymentCustomization
  userErrors: [PaymentCustomizationError!]!
}
union PaymentDetails = CardPaymentDetails | LocalPaymentMethodsPaymentDetails | ShopPayInstallmentsPaymentDetails
union PaymentInstrument = VaultCreditCard | VaultPaypalBillingAgreement
type PaymentMandate {
  id: ID!
  paymentInstrument: PaymentInstrument!
}
enum PaymentMethods {
  VISA
  MASTERCARD
  DISCOVER
  AMERICAN_EXPRESS
  DINERS_CLUB
  JCB
  UNIONPAY
  ELO
  DANKORT
  MAESTRO
  FORBRUGSFORENINGEN
  PAYPAL
  BOGUS
  BITCOIN
  LITECOIN
  DOGECOIN
  INTERAC
  EFTPOS
}
type PaymentReminderSendPayload {
  success: Boolean
  userErrors: [PaymentReminderSendUserError!]!
}
type PaymentReminderSendUserError {
  code: PaymentReminderSendUserErrorCode
  field: [String!]
  message: String!
}
enum PaymentReminderSendUserErrorCode {
  PAYMENT_REMINDER_SEND_UNSUCCESSFUL
}
type PaymentSchedule {
  amount: MoneyV2!
  completedAt: DateTime
  dueAt: DateTime
  id: ID!
  issuedAt: DateTime
  paymentTerms: PaymentTerms!
}
type PaymentScheduleConnection {
  edges: [PaymentScheduleEdge!]!
  nodes: [PaymentSchedule!]!
  pageInfo: PageInfo!
}
type PaymentScheduleEdge {
  cursor: String!
  node: PaymentSchedule!
}
input PaymentScheduleInput {
  issuedAt: DateTime
  dueAt: DateTime
}
type PaymentSettings {
  supportedDigitalWallets: [DigitalWallet!]!
}
type PaymentTerms {
  draftOrder: DraftOrder
  dueInDays: Int
  id: ID!
  order: Order
  overdue: Boolean!
  paymentSchedules: PaymentScheduleConnection!
  paymentTermsName: String!
  paymentTermsType: PaymentTermsType!
  translatedName: String!
}
input PaymentTermsCreateInput {
  paymentTermsTemplateId: ID!
  paymentSchedules: [PaymentScheduleInput!]
}
type PaymentTermsCreatePayload {
  paymentTerms: PaymentTerms
  userErrors: [PaymentTermsCreateUserError!]!
}
type PaymentTermsCreateUserError {
  code: PaymentTermsCreateUserErrorCode
  field: [String!]
  message: String!
}
enum PaymentTermsCreateUserErrorCode {
  PAYMENT_TERMS_CREATION_UNSUCCESSFUL
}
input PaymentTermsDeleteInput {
  paymentTermsId: ID!
}
type PaymentTermsDeletePayload {
  deletedId: ID
  userErrors: [PaymentTermsDeleteUserError!]!
}
type PaymentTermsDeleteUserError {
  code: PaymentTermsDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum PaymentTermsDeleteUserErrorCode {
  PAYMENT_TERMS_DELETE_UNSUCCESSFUL
}
input PaymentTermsInput {
  paymentTermsTemplateId: ID
  paymentSchedules: [PaymentScheduleInput!]
}
type PaymentTermsTemplate {
  description: String!
  dueInDays: Int
  id: ID!
  name: String!
  paymentTermsType: PaymentTermsType!
  translatedName: String!
}
enum PaymentTermsType {
  RECEIPT
  NET
  FIXED
  FULFILLMENT
  UNKNOWN
}
input PaymentTermsUpdateInput {
  paymentTermsId: ID!
  paymentTermsAttributes: PaymentTermsInput!
}
type PaymentTermsUpdatePayload {
  paymentTerms: PaymentTerms
  userErrors: [PaymentTermsUpdateUserError!]!
}
type PaymentTermsUpdateUserError {
  code: PaymentTermsUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum PaymentTermsUpdateUserErrorCode {
  PAYMENT_TERMS_UPDATE_UNSUCCESSFUL
}
enum PayoutSortKeys {
  ADJUSTMENT_GROSS
  ADVANCE_GROSS
  AMOUNT
  CHARGE_GROSS
  DUTIES_GROSS
  FEE_AMOUNT
  ID
  ISSUED_AT
  REFUND_GROSS
  RELEVANCE
  SHIPPING_LABEL_GROSS
  STATUS
}
enum PaypalExpressSubscriptionsGatewayStatus {
  ENABLED
  DISABLED
  PENDING
}
input PreparedFulfillmentOrderLineItemsInput {
  fulfillmentOrderId: ID!
}
enum PriceCalculationType {
  COMPONENTS_SUM
  FIXED
  NONE
}
input PriceInput {
  calculation: PriceCalculationType
  price: Money
}
type PriceList {
  catalog: Catalog
  currency: CurrencyCode!
  fixedPricesCount: Int!
  id: ID!
  name: String!
  parent: PriceListParent
  prices: PriceListPriceConnection!
  quantityRules: QuantityRuleConnection!
}
type PriceListAdjustment {
  type: PriceListAdjustmentType!
  value: Float!
}
input PriceListAdjustmentInput {
  value: Float!
  type: PriceListAdjustmentType!
}
type PriceListAdjustmentSettings {
  compareAtMode: PriceListCompareAtMode!
}
input PriceListAdjustmentSettingsInput {
  compareAtMode: PriceListCompareAtMode!
}
enum PriceListAdjustmentType {
  PERCENTAGE_DECREASE
  PERCENTAGE_INCREASE
}
enum PriceListCompareAtMode {
  ADJUSTED
  NULLIFY
}
type PriceListConnection {
  edges: [PriceListEdge!]!
  nodes: [PriceList!]!
  pageInfo: PageInfo!
}
input PriceListCreateInput {
  name: String!
  currency: CurrencyCode!
  parent: PriceListParentCreateInput!
  catalogId: ID
}
type PriceListCreatePayload {
  priceList: PriceList
  userErrors: [PriceListUserError!]!
}
type PriceListDeletePayload {
  deletedId: ID
  userErrors: [PriceListUserError!]!
}
type PriceListEdge {
  cursor: String!
  node: PriceList!
}
type PriceListFixedPricesAddPayload {
  prices: [PriceListPrice!]
  userErrors: [PriceListPriceUserError!]!
}
type PriceListFixedPricesByProductBulkUpdateUserError {
  code: PriceListFixedPricesByProductBulkUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum PriceListFixedPricesByProductBulkUpdateUserErrorCode {
  NO_UPDATE_OPERATIONS_SPECIFIED
  PRICES_TO_ADD_CURRENCY_MISMATCH
  PRICE_LIST_DOES_NOT_EXIST
  DUPLICATE_ID_IN_INPUT
  ID_MUST_BE_MUTUALLY_EXCLUSIVE
  PRODUCT_DOES_NOT_EXIST
  PRICE_LIMIT_EXCEEDED
}
type PriceListFixedPricesByProductUpdatePayload {
  priceList: PriceList
  pricesToAddProducts: [Product!]
  pricesToDeleteProducts: [Product!]
  userErrors: [PriceListFixedPricesByProductBulkUpdateUserError!]!
}
type PriceListFixedPricesDeletePayload {
  deletedFixedPriceVariantIds: [ID!]
  userErrors: [PriceListPriceUserError!]!
}
type PriceListFixedPricesUpdatePayload {
  deletedFixedPriceVariantIds: [ID!]
  priceList: PriceList
  pricesAdded: [PriceListPrice!]
  userErrors: [PriceListPriceUserError!]!
}
type PriceListParent {
  adjustment: PriceListAdjustment!
  settings: PriceListAdjustmentSettings!
}
input PriceListParentCreateInput {
  adjustment: PriceListAdjustmentInput!
  settings: PriceListAdjustmentSettingsInput
}
input PriceListParentUpdateInput {
  adjustment: PriceListAdjustmentInput!
  settings: PriceListAdjustmentSettingsInput
}
type PriceListPrice {
  compareAtPrice: MoneyV2
  originType: PriceListPriceOriginType!
  price: MoneyV2!
  quantityPriceBreaks: QuantityPriceBreakConnection!
  variant: ProductVariant!
}
type PriceListPriceConnection {
  edges: [PriceListPriceEdge!]!
  nodes: [PriceListPrice!]!
  pageInfo: PageInfo!
}
type PriceListPriceEdge {
  cursor: String!
  node: PriceListPrice!
}
input PriceListPriceInput {
  variantId: ID!
  price: MoneyInput!
  compareAtPrice: MoneyInput
}
enum PriceListPriceOriginType {
  FIXED
  RELATIVE
}
type PriceListPriceUserError {
  code: PriceListPriceUserErrorCode
  field: [String!]
  message: String!
}
enum PriceListPriceUserErrorCode {
  BLANK
  PRICE_LIST_NOT_FOUND
  PRICE_LIST_CURRENCY_MISMATCH
  VARIANT_NOT_FOUND
  PRICE_NOT_FIXED
}
input PriceListProductPriceInput {
  productId: ID!
  price: MoneyInput!
}
enum PriceListSortKeys {
  ID
  NAME
  RELEVANCE
}
input PriceListUpdateInput {
  name: String
  currency: CurrencyCode
  parent: PriceListParentUpdateInput
  catalogId: ID
}
type PriceListUpdatePayload {
  priceList: PriceList
  userErrors: [PriceListUserError!]!
}
type PriceListUserError {
  code: PriceListUserErrorCode
  field: [String!]
  message: String!
}
enum PriceListUserErrorCode {
  TAKEN
  BLANK
  INCLUSION
  TOO_LONG
  PRICE_LIST_NOT_FOUND
  PRICE_LIST_LOCKED
  CURRENCY_MARKET_MISMATCH
  INVALID_ADJUSTMENT_VALUE
  INVALID_ADJUSTMENT_MIN_VALUE
  INVALID_ADJUSTMENT_MAX_VALUE
  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES
  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_PRICE_BREAKS
  CONTEXT_RULE_LIMIT_ONE_OPTION
  CURRENCY_NOT_SUPPORTED
  PRICE_LIST_NOT_ALLOWED_FOR_PRIMARY_MARKET
  CATALOG_ASSIGNMENT_NOT_ALLOWED
  CATALOG_DOES_NOT_EXIST
  CATALOG_CANNOT_CHANGE_CONTEXT_TYPE
  CATALOG_MARKET_AND_PRICE_LIST_CURRENCY_MISMATCH
  CATALOG_TAKEN
  COUNTRY_PRICE_LIST_ASSIGNMENT
  APP_CATALOG_PRICE_LIST_ASSIGNMENT
  GENERIC_ERROR
}
type PriceRule {
  allocationLimit: Int
  allocationMethod: PriceRuleAllocationMethod!
  app: App
  combinesWith: DiscountCombinesWith!
  createdAt: DateTime!
  customerSelection: PriceRuleCustomerSelection!
  discountClass: DiscountClass!
  discountCodes: PriceRuleDiscountCodeConnection!
  discountCodesCount: Count
  endsAt: DateTime
  entitlementToPrerequisiteQuantityRatio: PriceRuleEntitlementToPrerequisiteQuantityRatio
  events: EventConnection!
  features: [PriceRuleFeature!]!
  hasTimelineComment: Boolean!
  id: ID!
  itemEntitlements: PriceRuleItemEntitlements!
  itemPrerequisites: PriceRuleLineItemPrerequisites!
  legacyResourceId: UnsignedInt64!
  oncePerCustomer: Boolean!
  prerequisiteQuantityRange: PriceRuleQuantityRange
  prerequisiteShippingPriceRange: PriceRuleMoneyRange
  prerequisiteSubtotalRange: PriceRuleMoneyRange
  prerequisiteToEntitlementQuantityRatio: PriceRulePrerequisiteToEntitlementQuantityRatio
  shareableUrls: [PriceRuleShareableUrl!]!
  shippingEntitlements: PriceRuleShippingLineEntitlements!
  startsAt: DateTime!
  status: PriceRuleStatus!
  summary: String
  target: PriceRuleTarget!
  title: String!
  totalSales: MoneyV2
  traits: [PriceRuleTrait!]!
  usageCount: Int!
  usageLimit: Int
  validityPeriod: PriceRuleValidityPeriod!
  value: PriceRuleValue!
  valueV2: PricingValue!
}
enum PriceRuleAllocationMethod {
  EACH
  ACROSS
}
type PriceRuleCustomerSelection {
  customers: CustomerConnection!
  forAllCustomers: Boolean!
  segments: [Segment!]!
}
type PriceRuleDiscountCode {
  app: App
  code: String!
  id: ID!
  usageCount: Int!
}
type PriceRuleDiscountCodeConnection {
  edges: [PriceRuleDiscountCodeEdge!]!
  nodes: [PriceRuleDiscountCode!]!
  pageInfo: PageInfo!
}
type PriceRuleDiscountCodeEdge {
  cursor: String!
  node: PriceRuleDiscountCode!
}
type PriceRuleEntitlementToPrerequisiteQuantityRatio {
  entitlementQuantity: Int!
  prerequisiteQuantity: Int!
}
enum PriceRuleFeature {
  BUY_ONE_GET_ONE
  BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT
  BULK
  SPECIFIC_CUSTOMERS
  QUANTITY_DISCOUNTS
}
type PriceRuleFixedAmountValue {
  amount: Money!
}
type PriceRuleItemEntitlements {
  collections: CollectionConnection!
  productVariants: ProductVariantConnection!
  products: ProductConnection!
  targetAllLineItems: Boolean!
}
type PriceRuleLineItemPrerequisites {
  collections: CollectionConnection!
  productVariants: ProductVariantConnection!
  products: ProductConnection!
}
type PriceRuleMoneyRange {
  greaterThan: Money
  greaterThanOrEqualTo: Money
  lessThan: Money
  lessThanOrEqualTo: Money
}
type PriceRulePercentValue {
  percentage: Float!
}
type PriceRulePrerequisiteToEntitlementQuantityRatio {
  entitlementQuantity: Int!
  prerequisiteQuantity: Int!
}
type PriceRuleQuantityRange {
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
}
type PriceRuleShareableUrl {
  targetItemImage: Image
  targetType: PriceRuleShareableUrlTargetType!
  title: String!
  url: URL!
}
enum PriceRuleShareableUrlTargetType {
  HOME
  PRODUCT
  COLLECTION
}
type PriceRuleShippingLineEntitlements {
  countryCodes: [CountryCode!]!
  includeRestOfWorld: Boolean!
  targetAllShippingLines: Boolean!
}
enum PriceRuleStatus {
  ACTIVE
  EXPIRED
  SCHEDULED
}
enum PriceRuleTarget {
  LINE_ITEM
  SHIPPING_LINE
}
enum PriceRuleTrait {
  BUY_ONE_GET_ONE
  BUY_ONE_GET_ONE_WITH_ALLOCATION_LIMIT
  BULK
  SPECIFIC_CUSTOMERS
  QUANTITY_DISCOUNTS
}
type PriceRuleValidityPeriod {
  end: DateTime
  start: DateTime!
}
union PriceRuleValue = PriceRuleFixedAmountValue | PriceRulePercentValue
type PricingPercentageValue {
  percentage: Float!
}
union PricingValue = MoneyV2 | PricingPercentageValue
type Product {
  availablePublicationsCount: Count
  bodyHtml: String
  bundleComponents: ProductBundleComponentConnection!
  category: TaxonomyCategory
  collections: CollectionConnection!
  combinedListing: CombinedListing
  combinedListingRole: CombinedListingsRole
  compareAtPriceRange: ProductCompareAtPriceRange
  contextualPricing: ProductContextualPricing!
  createdAt: DateTime!
  customProductType: String
  defaultCursor: String!
  description: String!
  descriptionHtml: HTML!
  descriptionPlainSummary: String!
  events: EventConnection!
  featuredImage: Image
  featuredMedia: Media
  feedback: ResourceFeedback
  giftCardTemplateSuffix: String
  handle: String!
  hasOnlyDefaultVariant: Boolean!
  hasOutOfStockVariants: Boolean!
  hasVariantsThatRequiresComponents: Boolean!
  id: ID!
  images: ImageConnection!
  inCollection: Boolean!
  isGiftCard: Boolean!
  legacyResourceId: UnsignedInt64!
  media: MediaConnection!
  mediaCount: Count
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  onlineStorePreviewUrl: URL
  onlineStoreUrl: URL
  options: [ProductOption!]!
  priceRange: ProductPriceRange!
  priceRangeV2: ProductPriceRangeV2!
  productCategory: ProductCategory
  productPublications: ProductPublicationConnection!
  productType: String!
  publicationCount: Int!
  publications: ProductPublicationConnection!
  publishedAt: DateTime
  publishedInContext: Boolean!
  publishedOnChannel: Boolean!
  publishedOnCurrentChannel: Boolean!
  publishedOnCurrentPublication: Boolean!
  publishedOnPublication: Boolean!
  requiresSellingPlan: Boolean!
  resourcePublicationOnCurrentPublication: ResourcePublicationV2
  resourcePublications: ResourcePublicationConnection!
  resourcePublicationsCount: Count
  resourcePublicationsV2: ResourcePublicationV2Connection!
  restrictedForResource: RestrictedForResource
  sellingPlanGroupCount: Int!
  sellingPlanGroups: SellingPlanGroupConnection!
  sellingPlanGroupsCount: Count
  seo: SEO!
  standardizedProductType: StandardizedProductType
  status: ProductStatus!
  storefrontId: StorefrontID!
  tags: [String!]!
  templateSuffix: String
  title: String!
  totalInventory: Int!
  totalVariants: Int!
  tracksInventory: Boolean!
  translations: [Translation!]!
  unpublishedChannels: ChannelConnection!
  unpublishedPublications: PublicationConnection!
  updatedAt: DateTime!
  variants: ProductVariantConnection!
  variantsCount: Count
  vendor: String!
}
type ProductBundleComponent {
  componentProduct: Product!
  componentVariants: ProductVariantConnection!
  componentVariantsCount: Count
  optionSelections: [ProductBundleComponentOptionSelection!]!
  quantity: Int
  quantityOption: ProductBundleComponentQuantityOption
}
type ProductBundleComponentConnection {
  edges: [ProductBundleComponentEdge!]!
  nodes: [ProductBundleComponent!]!
  pageInfo: PageInfo!
}
type ProductBundleComponentEdge {
  cursor: String!
  node: ProductBundleComponent!
}
input ProductBundleComponentInput {
  quantity: Int
  productId: ID!
  optionSelections: [ProductBundleComponentOptionSelectionInput!]!
  quantityOption: ProductBundleComponentQuantityOptionInput
}
type ProductBundleComponentOptionSelection {
  componentOption: ProductOption!
  parentOption: ProductOption
  values: [ProductBundleComponentOptionSelectionValue!]!
}
input ProductBundleComponentOptionSelectionInput {
  componentOptionId: ID!
  name: String!
  values: [String!]!
}
enum ProductBundleComponentOptionSelectionStatus {
  SELECTED
  DESELECTED
  NEW
  UNAVAILABLE
}
type ProductBundleComponentOptionSelectionValue {
  selectionStatus: ProductBundleComponentOptionSelectionStatus!
  value: String!
}
type ProductBundleComponentQuantityOption {
  name: String!
  parentOption: ProductOption
  values: [ProductBundleComponentQuantityOptionValue!]!
}
input ProductBundleComponentQuantityOptionInput {
  name: String!
  values: [ProductBundleComponentQuantityOptionValueInput!]!
}
type ProductBundleComponentQuantityOptionValue {
  name: String!
  quantity: Int!
}
input ProductBundleComponentQuantityOptionValueInput {
  name: String!
  quantity: Int!
}
input ProductBundleCreateInput {
  title: String!
  components: [ProductBundleComponentInput!]!
}
type ProductBundleCreatePayload {
  productBundleOperation: ProductBundleOperation
  userErrors: [UserError!]!
}
type ProductBundleMutationUserError {
  code: ProductBundleMutationUserErrorCode
  field: [String!]
  message: String!
}
enum ProductBundleMutationUserErrorCode {
  GENERIC_ERROR
  PRODUCT_DOES_NOT_EXIST
  INVALID_INPUT
  JOB_ERROR
}
type ProductBundleOperation {
  id: ID!
  product: Product
  status: ProductOperationStatus!
  userErrors: [ProductBundleMutationUserError!]!
}
input ProductBundleUpdateInput {
  productId: ID!
  title: String
  components: [ProductBundleComponentInput!]
}
type ProductBundleUpdatePayload {
  productBundleOperation: ProductBundleOperation
  userErrors: [UserError!]!
}
type ProductCategory {
  productTaxonomyNode: ProductTaxonomyNode
}
type ProductChangeStatusPayload {
  product: Product
  userErrors: [ProductChangeStatusUserError!]!
}
type ProductChangeStatusUserError {
  code: ProductChangeStatusUserErrorCode
  field: [String!]
  message: String!
}
enum ProductChangeStatusUserErrorCode {
  PRODUCT_NOT_FOUND
  COMBINED_LISTINGS_NOT_COMPATIBLE_WITH_SHOP
}
input ProductClaimOwnershipInput {
  bundles: Boolean
}
enum ProductCollectionSortKeys {
  BEST_SELLING
  COLLECTION_DEFAULT
  CREATED
  ID
  MANUAL
  PRICE
  RELEVANCE
  TITLE
}
type ProductCompareAtPriceRange {
  maxVariantCompareAtPrice: MoneyV2!
  minVariantCompareAtPrice: MoneyV2!
}
type ProductConnection {
  edges: [ProductEdge!]!
  nodes: [Product!]!
  pageInfo: PageInfo!
}
type ProductContextualPricing {
  fixedQuantityRulesCount: Int!
  maxVariantPricing: ProductVariantContextualPricing
  minVariantPricing: ProductVariantContextualPricing
  priceRange: ProductPriceRangeV2!
}
input ProductCreateInput {
  descriptionHtml: String
  handle: String
  seo: SEOInput
  productType: String
  category: ID
  tags: [String!]
  templateSuffix: String
  giftCardTemplateSuffix: String
  title: String
  vendor: String
  giftCard: Boolean
  collectionsToJoin: [ID!]
  combinedListingRole: CombinedListingsRole
  metafields: [MetafieldInput!]
  productOptions: [OptionCreateInput!]
  status: ProductStatus
  requiresSellingPlan: Boolean
  claimOwnership: ProductClaimOwnershipInput
}
type ProductCreateMediaPayload {
  media: [Media!]
  mediaUserErrors: [MediaUserError!]!
  product: Product
  userErrors: [UserError!]!
}
type ProductCreatePayload {
  product: Product
  shop: Shop!
  userErrors: [UserError!]!
}
input ProductDeleteInput {
  id: ID!
}
type ProductDeleteMediaPayload {
  deletedMediaIds: [ID!]
  deletedProductImageIds: [ID!]
  mediaUserErrors: [MediaUserError!]!
  product: Product
  userErrors: [UserError!]!
}
type ProductDeleteOperation {
  deletedProductId: ID
  id: ID!
  product: Product
  status: ProductOperationStatus!
  userErrors: [UserError!]!
}
type ProductDeletePayload {
  deletedProductId: ID
  productDeleteOperation: ProductDeleteOperation
  shop: Shop!
  userErrors: [UserError!]!
}
type ProductDuplicateJob {
  done: Boolean!
  id: ID!
}
type ProductDuplicateOperation {
  id: ID!
  newProduct: Product
  product: Product
  status: ProductOperationStatus!
  userErrors: [UserError!]!
}
type ProductDuplicatePayload {
  imageJob: Job
  newProduct: Product
  productDuplicateOperation: ProductDuplicateOperation
  shop: Shop!
  userErrors: [UserError!]!
}
type ProductEdge {
  cursor: String!
  node: Product!
}
type ProductFeed {
  country: CountryCode
  id: ID!
  language: LanguageCode
  status: ProductFeedStatus!
}
type ProductFeedConnection {
  edges: [ProductFeedEdge!]!
  nodes: [ProductFeed!]!
  pageInfo: PageInfo!
}
type ProductFeedCreatePayload {
  productFeed: ProductFeed
  userErrors: [ProductFeedCreateUserError!]!
}
type ProductFeedCreateUserError {
  code: ProductFeedCreateUserErrorCode
  field: [String!]
  message: String!
}
enum ProductFeedCreateUserErrorCode {
  INVALID
  TAKEN
}
type ProductFeedDeletePayload {
  deletedId: ID
  userErrors: [ProductFeedDeleteUserError!]!
}
type ProductFeedDeleteUserError {
  code: ProductFeedDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum ProductFeedDeleteUserErrorCode {
  INVALID
}
type ProductFeedEdge {
  cursor: String!
  node: ProductFeed!
}
input ProductFeedInput {
  language: LanguageCode!
  country: CountryCode!
}
enum ProductFeedStatus {
  ACTIVE
  INACTIVE
}
type ProductFullSyncPayload {
  userErrors: [ProductFullSyncUserError!]!
}
type ProductFullSyncUserError {
  code: ProductFullSyncUserErrorCode
  field: [String!]
  message: String!
}
enum ProductFullSyncUserErrorCode {
  INVALID
}
input ProductIdentifierInput {
  id: ID
  customId: UniqueMetafieldValueInput
  handle: String
}
enum ProductImageSortKeys {
  CREATED_AT
  ID
  POSITION
  RELEVANCE
}
input ProductInput {
  descriptionHtml: String
  handle: String
  seo: SEOInput
  productType: String
  category: ID
  tags: [String!]
  templateSuffix: String
  giftCardTemplateSuffix: String
  title: String
  vendor: String
  giftCard: Boolean
  redirectNewHandle: Boolean
  collectionsToJoin: [ID!]
  collectionsToLeave: [ID!]
  combinedListingRole: CombinedListingsRole
  id: ID
  metafields: [MetafieldInput!]
  productOptions: [OptionCreateInput!]
  status: ProductStatus
  requiresSellingPlan: Boolean
  claimOwnership: ProductClaimOwnershipInput
}
type ProductJoinSellingPlanGroupsPayload {
  product: Product
  userErrors: [SellingPlanGroupUserError!]!
}
type ProductLeaveSellingPlanGroupsPayload {
  product: Product
  userErrors: [SellingPlanGroupUserError!]!
}
enum ProductMediaSortKeys {
  ID
  POSITION
  RELEVANCE
}
interface ProductOperation {
  product: Product
  status: ProductOperationStatus!
}
enum ProductOperationStatus {
  CREATED
  ACTIVE
  COMPLETE
}
type ProductOption {
  id: ID!
  linkedMetafield: LinkedMetafield
  name: String!
  optionValues: [ProductOptionValue!]!
  position: Int!
  translations: [Translation!]!
  values: [String!]!
}
enum ProductOptionCreateVariantStrategy {
  LEAVE_AS_IS
  CREATE
}
enum ProductOptionDeleteStrategy {
  DEFAULT
  POSITION
  NON_DESTRUCTIVE
}
type ProductOptionUpdatePayload {
  product: Product
  userErrors: [ProductOptionUpdateUserError!]!
}
type ProductOptionUpdateUserError {
  code: ProductOptionUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum ProductOptionUpdateUserErrorCode {
  PRODUCT_DOES_NOT_EXIST
  PRODUCT_SUSPENDED
  OPTION_DOES_NOT_EXIST
  OPTION_ALREADY_EXISTS
  INVALID_POSITION
  INVALID_NAME
  OPTION_VALUES_OVER_LIMIT
  OPTION_VALUE_DOES_NOT_EXIST
  OPTION_VALUE_ALREADY_EXISTS
  OPTION_VALUE_HAS_VARIANTS
  CANNOT_DELETE_ALL_OPTION_VALUES_IN_OPTION
  CANNOT_LEAVE_OPTIONS_WITHOUT_VARIANTS
  NO_KEY_ON_CREATE
  KEY_MISSING_IN_INPUT
  DUPLICATED_OPTION_VALUE
  OPTION_NAME_TOO_LONG
  OPTION_VALUE_NAME_TOO_LONG
  OPTION_VALUE_CONFLICTING_OPERATION
  CANNOT_CREATE_VARIANTS_ABOVE_LIMIT
  CANNOT_COMBINE_LINKED_AND_NONLINKED_OPTION_VALUES
  INVALID_METAFIELD_VALUE_FOR_LINKED_OPTION
  DUPLICATE_LINKED_OPTION
  OPTION_LINKED_METAFIELD_ALREADY_TAKEN
  LINKED_OPTION_UPDATE_MISSING_VALUES
  LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP
  LINKED_METAFIELD_DEFINITION_NOT_FOUND
  CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU
  UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION
  CANNOT_DELETE_VARIANT_WITHOUT_PERMISSION
  TOO_MANY_VARIANTS_CREATED
}
enum ProductOptionUpdateVariantStrategy {
  LEAVE_AS_IS
  MANAGE
}
type ProductOptionValue {
  hasVariants: Boolean!
  id: ID!
  linkedMetafieldValue: String
  name: String!
  swatch: ProductOptionValueSwatch
  translations: [Translation!]!
}
type ProductOptionValueSwatch {
  color: Color
  image: MediaImage
}
type ProductOptionsCreatePayload {
  product: Product
  userErrors: [ProductOptionsCreateUserError!]!
}
type ProductOptionsCreateUserError {
  code: ProductOptionsCreateUserErrorCode
  field: [String!]
  message: String!
}
enum ProductOptionsCreateUserErrorCode {
  OPTION_ALREADY_EXISTS
  OPTIONS_OVER_LIMIT
  OPTION_VALUES_OVER_LIMIT
  INVALID_NAME
  PRODUCT_SUSPENDED
  NEW_OPTION_WITHOUT_VALUE_FOR_EXISTING_VARIANTS
  DUPLICATED_OPTION_NAME
  DUPLICATED_OPTION_VALUE
  OPTION_NAME_MISSING
  OPTION_VALUES_MISSING
  POSITION_OUT_OF_BOUNDS
  OPTION_POSITION_MISSING
  PRODUCT_DOES_NOT_EXIST
  LINKED_METAFIELD_DEFINITION_NOT_FOUND
  INVALID_METAFIELD_VALUE_FOR_LINKED_OPTION
  MISSING_METAFIELD_VALUES_FOR_LINKED_OPTION
  CANNOT_COMBINE_LINKED_METAFIELD_AND_OPTION_VALUES
  DUPLICATE_LINKED_OPTION
  OPTION_LINKED_METAFIELD_ALREADY_TAKEN
  LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP
  CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU
  UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION
  LINKED_METAFIELD_VALUE_WITHOUT_LINKED_OPTION
  TOO_MANY_VARIANTS_CREATED
}
type ProductOptionsDeletePayload {
  deletedOptionsIds: [ID!]
  product: Product
  userErrors: [ProductOptionsDeleteUserError!]!
}
type ProductOptionsDeleteUserError {
  code: ProductOptionsDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum ProductOptionsDeleteUserErrorCode {
  PRODUCT_DOES_NOT_EXIST
  PRODUCT_SUSPENDED
  OPTION_DOES_NOT_EXIST
  OPTIONS_DO_NOT_BELONG_TO_THE_SAME_PRODUCT
  CANNOT_DELETE_OPTION_WITH_MULTIPLE_VALUES
  CANNOT_USE_NON_DESTRUCTIVE_STRATEGY
  CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU
  UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION
  CANNOT_DELETE_VARIANT_WITHOUT_PERMISSION
}
type ProductOptionsReorderPayload {
  product: Product
  userErrors: [ProductOptionsReorderUserError!]!
}
type ProductOptionsReorderUserError {
  code: ProductOptionsReorderUserErrorCode
  field: [String!]
  message: String!
}
enum ProductOptionsReorderUserErrorCode {
  OPTION_NAME_DOES_NOT_EXIST
  OPTION_VALUE_DOES_NOT_EXIST
  OPTION_ID_DOES_NOT_EXIST
  OPTION_VALUE_ID_DOES_NOT_EXIST
  DUPLICATED_OPTION_NAME
  DUPLICATED_OPTION_VALUE
  MISSING_OPTION_NAME
  MISSING_OPTION_VALUE
  PRODUCT_DOES_NOT_EXIST
  NO_KEY_ON_REORDER
  MIXING_ID_AND_NAME_KEYS_IS_NOT_ALLOWED
  CANNOT_MAKE_CHANGES_IF_VARIANT_IS_MISSING_REQUIRED_SKU
}
type ProductPriceRange {
  maxVariantPrice: MoneyV2!
  minVariantPrice: MoneyV2!
}
type ProductPriceRangeV2 {
  maxVariantPrice: MoneyV2!
  minVariantPrice: MoneyV2!
}
type ProductPublication {
  channel: Channel!
  isPublished: Boolean!
  product: Product!
  publishDate: DateTime
}
type ProductPublicationConnection {
  edges: [ProductPublicationEdge!]!
  nodes: [ProductPublication!]!
  pageInfo: PageInfo!
}
type ProductPublicationEdge {
  cursor: String!
  node: ProductPublication!
}
input ProductPublicationInput {
  publicationId: ID
  publishDate: DateTime
}
input ProductPublishInput {
  id: ID!
  productPublications: [ProductPublicationInput!]!
}
type ProductPublishPayload {
  product: Product
  productPublications: [ProductPublication!]
  shop: Shop!
  userErrors: [UserError!]!
}
type ProductReorderMediaPayload {
  job: Job
  mediaUserErrors: [MediaUserError!]!
  userErrors: [UserError!]!
}
type ProductResourceFeedback {
  feedbackGeneratedAt: DateTime!
  messages: [String!]!
  productId: ID!
  productUpdatedAt: DateTime!
  state: ResourceFeedbackState!
}
input ProductResourceFeedbackInput {
  productId: ID!
  state: ResourceFeedbackState!
  feedbackGeneratedAt: DateTime!
  productUpdatedAt: DateTime!
  messages: [String!]
}
type ProductSale {
  actionType: SaleActionType!
  id: ID!
  lineItem: LineItem!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
input ProductSetInput {
  descriptionHtml: String
  handle: String
  seo: SEOInput
  productType: String
  category: ID
  tags: [String!]
  templateSuffix: String
  giftCardTemplateSuffix: String
  title: String
  vendor: String
  giftCard: Boolean
  redirectNewHandle: Boolean
  collections: [ID!]
  metafields: [MetafieldInput!]
  variants: [ProductVariantSetInput!]
  files: [FileSetInput!]
  status: ProductStatus
  requiresSellingPlan: Boolean
  productOptions: [OptionSetInput!]
  claimOwnership: ProductClaimOwnershipInput
  combinedListingRole: CombinedListingsRole
}
input ProductSetInventoryInput {
  locationId: ID!
  name: String!
  quantity: Int!
}
type ProductSetOperation {
  id: ID!
  product: Product
  status: ProductOperationStatus!
  userErrors: [ProductSetUserError!]!
}
type ProductSetPayload {
  product: Product
  productSetOperation: ProductSetOperation
  userErrors: [ProductSetUserError!]!
}
type ProductSetUserError {
  code: ProductSetUserErrorCode
  field: [String!]
  message: String!
}
enum ProductSetUserErrorCode {
  GENERIC_ERROR
  INVALID_METAFIELD
  INVALID_VARIANT
  PRODUCT_DOES_NOT_EXIST
  PRODUCT_VARIANT_DOES_NOT_EXIST
  OPTION_DOES_NOT_EXIST
  OPTION_VALUE_DOES_NOT_EXIST
  OPTIONS_OVER_LIMIT
  OPTION_VALUES_OVER_LIMIT
  OPTION_VALUES_MISSING
  DUPLICATED_OPTION_NAME
  DUPLICATED_OPTION_VALUE
  VARIANTS_OVER_LIMIT
  PRODUCT_OPTIONS_INPUT_MISSING
  VARIANTS_INPUT_MISSING
  GIFT_CARDS_NOT_ACTIVATED
  GIFT_CARD_ATTRIBUTE_CANNOT_BE_CHANGED
  INVALID_PRODUCT
  INVALID_INPUT
  JOB_ERROR
  CAPABILITY_VIOLATION
  CANNOT_COMBINE_LINKED_AND_NONLINKED_OPTION_VALUES
  INVALID_METAFIELD_VALUE_FOR_LINKED_OPTION
  DUPLICATE_LINKED_OPTION
  LINKED_OPTIONS_NOT_SUPPORTED_FOR_SHOP
  LINKED_METAFIELD_DEFINITION_NOT_FOUND
  DUPLICATED_VALUE
  HANDLE_NOT_UNIQUE
}
enum ProductSortKeys {
  CREATED_AT
  ID
  INVENTORY_TOTAL
  PRODUCT_TYPE
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
  VENDOR
}
enum ProductStatus {
  ACTIVE
  ARCHIVED
  DRAFT
}
type ProductTaxonomyNode {
  fullName: String!
  id: ID!
  isLeaf: Boolean!
  isRoot: Boolean!
  name: String!
}
input ProductUnpublishInput {
  id: ID!
  productPublications: [ProductPublicationInput!]!
}
type ProductUnpublishPayload {
  product: Product
  shop: Shop!
  userErrors: [UserError!]!
}
input ProductUpdateInput {
  descriptionHtml: String
  handle: String
  seo: SEOInput
  productType: String
  category: ID
  tags: [String!]
  templateSuffix: String
  giftCardTemplateSuffix: String
  title: String
  vendor: String
  redirectNewHandle: Boolean
  id: ID
  collectionsToJoin: [ID!]
  collectionsToLeave: [ID!]
  deleteConflictingConstrainedMetafields: Boolean
  metafields: [MetafieldInput!]
  status: ProductStatus
  requiresSellingPlan: Boolean
}
type ProductUpdateMediaPayload {
  media: [Media!]
  mediaUserErrors: [MediaUserError!]!
  product: Product
  userErrors: [UserError!]!
}
type ProductUpdatePayload {
  product: Product
  userErrors: [UserError!]!
}
type ProductVariant {
  availableForSale: Boolean!
  barcode: String
  compareAtPrice: Money
  contextualPricing: ProductVariantContextualPricing!
  createdAt: DateTime!
  defaultCursor: String!
  deliveryProfile: DeliveryProfile
  displayName: String!
  events: EventConnection!
  id: ID!
  image: Image
  inventoryItem: InventoryItem!
  inventoryPolicy: ProductVariantInventoryPolicy!
  inventoryQuantity: Int
  legacyResourceId: UnsignedInt64!
  media: MediaConnection!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  position: Int!
  presentmentPrices: ProductVariantPricePairConnection!
  price: Money!
  product: Product!
  productVariantComponents: ProductVariantComponentConnection!
  requiresComponents: Boolean!
  selectedOptions: [SelectedOption!]!
  sellableOnlineQuantity: Int!
  sellingPlanGroupCount: Int!
  sellingPlanGroups: SellingPlanGroupConnection!
  sellingPlanGroupsCount: Count
  sku: String
  storefrontId: StorefrontID!
  taxCode: String
  taxable: Boolean!
  title: String!
  translations: [Translation!]!
  unitPriceMeasurement: UnitPriceMeasurement
  updatedAt: DateTime!
}
input ProductVariantAppendMediaInput {
  variantId: ID!
  mediaIds: [ID!]!
}
type ProductVariantAppendMediaPayload {
  product: Product
  productVariants: [ProductVariant!]
  userErrors: [MediaUserError!]!
}
type ProductVariantComponent {
  id: ID!
  productVariant: ProductVariant!
  quantity: Int!
}
type ProductVariantComponentConnection {
  edges: [ProductVariantComponentEdge!]!
  nodes: [ProductVariantComponent!]!
  pageInfo: PageInfo!
}
type ProductVariantComponentEdge {
  cursor: String!
  node: ProductVariantComponent!
}
type ProductVariantConnection {
  edges: [ProductVariantEdge!]!
  nodes: [ProductVariant!]!
  pageInfo: PageInfo!
}
type ProductVariantContextualPricing {
  compareAtPrice: MoneyV2
  price: MoneyV2!
  quantityPriceBreaks: QuantityPriceBreakConnection!
  quantityRule: QuantityRule!
}
input ProductVariantDetachMediaInput {
  variantId: ID!
  mediaIds: [ID!]!
}
type ProductVariantDetachMediaPayload {
  product: Product
  productVariants: [ProductVariant!]
  userErrors: [MediaUserError!]!
}
type ProductVariantEdge {
  cursor: String!
  node: ProductVariant!
}
input ProductVariantGroupRelationshipInput {
  id: ID!
  quantity: Int!
}
enum ProductVariantInventoryPolicy {
  DENY
  CONTINUE
}
type ProductVariantJoinSellingPlanGroupsPayload {
  productVariant: ProductVariant
  userErrors: [SellingPlanGroupUserError!]!
}
type ProductVariantLeaveSellingPlanGroupsPayload {
  productVariant: ProductVariant
  userErrors: [SellingPlanGroupUserError!]!
}
input ProductVariantPositionInput {
  id: ID!
  position: Int!
}
type ProductVariantPricePair {
  compareAtPrice: MoneyV2
  price: MoneyV2!
}
type ProductVariantPricePairConnection {
  edges: [ProductVariantPricePairEdge!]!
  nodes: [ProductVariantPricePair!]!
  pageInfo: PageInfo!
}
type ProductVariantPricePairEdge {
  cursor: String!
  node: ProductVariantPricePair!
}
type ProductVariantRelationshipBulkUpdatePayload {
  parentProductVariants: [ProductVariant!]
  userErrors: [ProductVariantRelationshipBulkUpdateUserError!]!
}
type ProductVariantRelationshipBulkUpdateUserError {
  code: ProductVariantRelationshipBulkUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum ProductVariantRelationshipBulkUpdateUserErrorCode {
  PARENT_REQUIRED
  FAILED_TO_CREATE
  PRODUCT_VARIANTS_NOT_FOUND
  CIRCULAR_REFERENCE
  NESTED_PARENT_PRODUCT_VARIANT
  INVALID_QUANTITY
  DUPLICATE_PRODUCT_VARIANT_RELATIONSHIP
  EXCEEDED_PRODUCT_VARIANT_RELATIONSHIP_LIMIT
  PRODUCT_VARIANT_RELATIONSHIP_TYPE_CONFLICT
  UNEXPECTED_ERROR
  FAILED_TO_REMOVE
  MUST_SPECIFY_COMPONENTS
  FAILED_TO_UPDATE
  FAILED_TO_UPDATE_PARENT_PRODUCT_VARIANT_PRICE
  UPDATE_PARENT_VARIANT_PRICE_REQUIRED
  PRODUCT_VARIANTS_NOT_COMPONENTS
  PRODUCT_EXPANDER_APP_OWNERSHIP_ALREADY_EXISTS
  UNSUPPORTED_MULTIPACK_RELATIONSHIP
  PARENT_PRODUCT_VARIANT_CANNOT_BE_GIFT_CARD
  PARENT_PRODUCT_VARIANT_CANNOT_REQUIRE_SELLING_PLAN
  PARENT_PRODUCT_VARIANT_CANNOT_BE_COMBINED_LISTING
  CHILD_PRODUCT_VARIANT_CANNOT_BE_COMBINED_LISTING
}
input ProductVariantRelationshipUpdateInput {
  parentProductVariantId: ID
  parentProductId: ID
  productVariantRelationshipsToCreate: [ProductVariantGroupRelationshipInput!]
  productVariantRelationshipsToUpdate: [ProductVariantGroupRelationshipInput!]
  productVariantRelationshipsToRemove: [ID!]
  removeAllProductVariantRelationships: Boolean
  priceInput: PriceInput
}
input ProductVariantSetInput {
  requiresComponents: Boolean
  barcode: String
  compareAtPrice: Money
  id: ID
  file: FileSetInput
  inventoryPolicy: ProductVariantInventoryPolicy
  inventoryQuantities: [ProductSetInventoryInput!]
  inventoryItem: InventoryItemInput
  metafields: [MetafieldInput!]
  optionValues: [VariantOptionValueInput!]!
  position: Int
  price: Money
  sku: String
  taxable: Boolean
  taxCode: String
}
enum ProductVariantSortKeys {
  FULL_TITLE
  ID
  INVENTORY_LEVELS_AVAILABLE
  INVENTORY_MANAGEMENT
  INVENTORY_POLICY
  INVENTORY_QUANTITY
  NAME
  POPULAR
  POSITION
  RELEVANCE
  SKU
  TITLE
}
type ProductVariantsBulkCreatePayload {
  product: Product
  productVariants: [ProductVariant!]
  userErrors: [ProductVariantsBulkCreateUserError!]!
}
enum ProductVariantsBulkCreateStrategy {
  DEFAULT
  REMOVE_STANDALONE_VARIANT
}
type ProductVariantsBulkCreateUserError {
  code: ProductVariantsBulkCreateUserErrorCode
  field: [String!]
  message: String!
}
enum ProductVariantsBulkCreateUserErrorCode {
  INVALID_INPUT
  PRODUCT_DOES_NOT_EXIST
  NO_KEY_ON_CREATE
  VARIANT_ALREADY_EXISTS
  PRODUCT_SUSPENDED
  GREATER_THAN_OR_EQUAL_TO
  NEED_TO_ADD_OPTION_VALUES
  OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS
  TOO_MANY_INVENTORY_LOCATIONS
  SUBSCRIPTION_VIOLATION
  VARIANT_ALREADY_EXISTS_CHANGE_OPTION_VALUE
  TRACKED_VARIANT_LOCATION_NOT_FOUND
  MUST_BE_FOR_THIS_PRODUCT
  NOT_DEFINED_FOR_SHOP
  INVALID
  NEGATIVE_PRICE_VALUE
  UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION
  CANNOT_SET_NAME_FOR_LINKED_OPTION_VALUE
}
type ProductVariantsBulkDeletePayload {
  product: Product
  userErrors: [ProductVariantsBulkDeleteUserError!]!
}
type ProductVariantsBulkDeleteUserError {
  code: ProductVariantsBulkDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum ProductVariantsBulkDeleteUserErrorCode {
  PRODUCT_DOES_NOT_EXIST
  CANNOT_DELETE_LAST_VARIANT
  AT_LEAST_ONE_VARIANT_DOES_NOT_BELONG_TO_THE_PRODUCT
  UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION
}
input ProductVariantsBulkInput {
  barcode: String
  compareAtPrice: Money
  id: ID
  mediaSrc: [String!]
  inventoryPolicy: ProductVariantInventoryPolicy
  inventoryQuantities: [InventoryLevelInput!]
  inventoryItem: InventoryItemInput
  mediaId: ID
  metafields: [MetafieldInput!]
  optionValues: [VariantOptionValueInput!]
  price: Money
  taxable: Boolean
  taxCode: String
  requiresComponents: Boolean
}
type ProductVariantsBulkReorderPayload {
  product: Product
  userErrors: [ProductVariantsBulkReorderUserError!]!
}
type ProductVariantsBulkReorderUserError {
  code: ProductVariantsBulkReorderUserErrorCode
  field: [String!]
  message: String!
}
enum ProductVariantsBulkReorderUserErrorCode {
  PRODUCT_DOES_NOT_EXIST
  MISSING_VARIANT
  INVALID_POSITION
  DUPLICATED_VARIANT_ID
  GENERIC_ERROR
}
type ProductVariantsBulkUpdatePayload {
  product: Product
  productVariants: [ProductVariant!]
  userErrors: [ProductVariantsBulkUpdateUserError!]!
}
type ProductVariantsBulkUpdateUserError {
  code: ProductVariantsBulkUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum ProductVariantsBulkUpdateUserErrorCode {
  INVALID_INPUT
  CANNOT_SPECIFY_BOTH
  MUST_SPECIFY_ONE_OF_PAIR
  PRODUCT_DOES_NOT_EXIST
  PRODUCT_VARIANT_ID_MISSING
  PRODUCT_VARIANT_DOES_NOT_EXIST
  OPTION_DOES_NOT_EXIST
  OPTION_VALUE_DOES_NOT_EXIST
  MUST_BE_FOR_THIS_PRODUCT
  NOT_DEFINED_FOR_SHOP
  PRODUCT_SUSPENDED
  NO_INVENTORY_QUANTITIES_ON_VARIANTS_UPDATE
  VARIANT_ALREADY_EXISTS
  GREATER_THAN_OR_EQUAL_TO
  NEED_TO_ADD_OPTION_VALUES
  OPTION_VALUES_FOR_NUMBER_OF_UNKNOWN_OPTIONS
  SUBSCRIPTION_VIOLATION
  NO_INVENTORY_QUANTITES_DURING_UPDATE
  NEGATIVE_PRICE_VALUE
  CANNOT_SET_NAME_FOR_LINKED_OPTION_VALUE
  UNSUPPORTED_COMBINED_LISTING_PARENT_OPERATION
}
enum ProfileItemSortKeys {
  CREATED_AT
  ID
  INVENTORY_TOTAL
  PRODUCT_TYPE
  PUBLISHED_AT
  RELEVANCE
  TITLE
  UPDATED_AT
  VENDOR
}
type PubSubServerPixelUpdatePayload {
  serverPixel: ServerPixel
  userErrors: [ErrorsServerPixelUserError!]!
}
type PubSubWebhookSubscriptionCreatePayload {
  userErrors: [PubSubWebhookSubscriptionCreateUserError!]!
  webhookSubscription: WebhookSubscription
}
type PubSubWebhookSubscriptionCreateUserError {
  code: PubSubWebhookSubscriptionCreateUserErrorCode
  field: [String!]
  message: String!
}
enum PubSubWebhookSubscriptionCreateUserErrorCode {
  INVALID_PARAMETERS
  TAKEN
}
input PubSubWebhookSubscriptionInput {
  pubSubProject: String!
  pubSubTopic: String!
  format: WebhookSubscriptionFormat
  includeFields: [String!]
  filter: String
  metafieldNamespaces: [String!]
}
type PubSubWebhookSubscriptionUpdatePayload {
  userErrors: [PubSubWebhookSubscriptionUpdateUserError!]!
  webhookSubscription: WebhookSubscription
}
type PubSubWebhookSubscriptionUpdateUserError {
  code: PubSubWebhookSubscriptionUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum PubSubWebhookSubscriptionUpdateUserErrorCode {
  INVALID_PARAMETERS
}
type Publication {
  app: App!
  autoPublish: Boolean!
  catalog: Catalog
  collectionPublicationsV3: ResourcePublicationConnection!
  collections: CollectionConnection!
  hasCollection: Boolean!
  id: ID!
  name: String!
  operation: PublicationOperation
  productPublicationsV3: ResourcePublicationConnection!
  products: ProductConnection!
  supportsFuturePublishing: Boolean!
}
type PublicationConnection {
  edges: [PublicationEdge!]!
  nodes: [Publication!]!
  pageInfo: PageInfo!
}
input PublicationCreateInput {
  catalogId: ID
  defaultState: PublicationCreateInputPublicationDefaultState
  autoPublish: Boolean
}
enum PublicationCreateInputPublicationDefaultState {
  EMPTY
  ALL_PRODUCTS
}
type PublicationCreatePayload {
  publication: Publication
  userErrors: [PublicationUserError!]!
}
type PublicationDeletePayload {
  deletedId: ID
  userErrors: [PublicationUserError!]!
}
type PublicationEdge {
  cursor: String!
  node: Publication!
}
input PublicationInput {
  publicationId: ID
  publishDate: DateTime
}
union PublicationOperation = AddAllProductsOperation | CatalogCsvOperation | PublicationResourceOperation
type PublicationResourceOperation {
  id: ID!
  processedRowCount: Int
  rowCount: RowCount
  status: ResourceOperationStatus!
}
input PublicationUpdateInput {
  publishablesToAdd: [ID!]
  publishablesToRemove: [ID!]
  autoPublish: Boolean
}
type PublicationUpdatePayload {
  publication: Publication
  userErrors: [PublicationUserError!]!
}
type PublicationUserError {
  code: PublicationUserErrorCode
  field: [String!]
  message: String!
}
enum PublicationUserErrorCode {
  UNSUPPORTED_PUBLICATION_ACTION
  PUBLICATION_NOT_FOUND
  PUBLICATION_LOCKED
  UNSUPPORTED_PUBLISHABLE_TYPE
  INVALID_PUBLISHABLE_ID
  MARKET_NOT_FOUND
  CATALOG_NOT_FOUND
  CANNOT_MODIFY_APP_CATALOG_PUBLICATION
  CANNOT_MODIFY_MARKET_CATALOG_PUBLICATION
  CANNOT_MODIFY_APP_CATALOG
  CANNOT_MODIFY_MARKET_CATALOG
  INVALID
  TAKEN
  TOO_LONG
  TOO_SHORT
  BLANK
  PRODUCT_TYPE_INCOMPATIBLE_WITH_CATALOG_TYPE
  PUBLICATION_UPDATE_LIMIT_EXCEEDED
}
interface Publishable {
  availablePublicationsCount: Count
  publicationCount: Int!
  publishedOnChannel: Boolean!
  publishedOnCurrentChannel: Boolean!
  publishedOnCurrentPublication: Boolean!
  publishedOnPublication: Boolean!
  resourcePublications: ResourcePublicationConnection!
  resourcePublicationsCount: Count
  resourcePublicationsV2: ResourcePublicationV2Connection!
  unpublishedChannels: ChannelConnection!
  unpublishedPublications: PublicationConnection!
}
type PublishablePublishPayload {
  publishable: Publishable
  shop: Shop!
  userErrors: [UserError!]!
}
type PublishablePublishToCurrentChannelPayload {
  publishable: Publishable
  shop: Shop!
  userErrors: [UserError!]!
}
type PublishableUnpublishPayload {
  publishable: Publishable
  shop: Shop!
  userErrors: [UserError!]!
}
type PublishableUnpublishToCurrentChannelPayload {
  publishable: Publishable
  shop: Shop!
  userErrors: [UserError!]!
}
type PurchasingCompany {
  company: Company!
  contact: CompanyContact
  location: CompanyLocation!
}
input PurchasingCompanyInput {
  companyId: ID!
  companyContactId: ID!
  companyLocationId: ID!
}
union PurchasingEntity = Customer | PurchasingCompany
input PurchasingEntityInput {
  customerId: ID
  purchasingCompany: PurchasingCompanyInput
}
type QuantityPriceBreak {
  id: ID!
  minimumQuantity: Int!
  price: MoneyV2!
  priceList: PriceList!
  variant: ProductVariant!
}
type QuantityPriceBreakConnection {
  edges: [QuantityPriceBreakEdge!]!
  nodes: [QuantityPriceBreak!]!
  pageInfo: PageInfo!
}
type QuantityPriceBreakEdge {
  cursor: String!
  node: QuantityPriceBreak!
}
input QuantityPriceBreakInput {
  variantId: ID!
  price: MoneyInput!
  minimumQuantity: Int!
}
enum QuantityPriceBreakSortKeys {
  ID
  MINIMUM_QUANTITY
  RELEVANCE
}
input QuantityPricingByVariantUpdateInput {
  quantityPriceBreaksToAdd: [QuantityPriceBreakInput!]!
  quantityPriceBreaksToDelete: [ID!]!
  quantityRulesToAdd: [QuantityRuleInput!]!
  quantityRulesToDeleteByVariantId: [ID!]!
  pricesToAdd: [PriceListPriceInput!]!
  pricesToDeleteByVariantId: [ID!]!
}
type QuantityPricingByVariantUpdatePayload {
  productVariants: [ProductVariant!]
  userErrors: [QuantityPricingByVariantUserError!]!
}
type QuantityPricingByVariantUserError {
  code: QuantityPricingByVariantUserErrorCode
  field: [String!]
  message: String!
}
enum QuantityPricingByVariantUserErrorCode {
  BLANK
  PRICE_LIST_NOT_FOUND
  GENERIC_ERROR
  QUANTITY_PRICE_BREAK_ADD_INVALID
  QUANTITY_PRICE_BREAK_ADD_PRICE_LIST_PRICE_NOT_FOUND
  QUANTITY_PRICE_BREAK_ADD_LIMIT_EXCEEDED
  QUANTITY_PRICE_BREAK_ADD_CURRENCY_MISMATCH
  QUANTITY_PRICE_BREAK_ADD_FAILED_TO_SAVE
  QUANTITY_PRICE_BREAK_ADD_MIN_LOWER_THAN_QUANTITY_RULES_MIN
  QUANTITY_PRICE_BREAK_ADD_MIN_HIGHER_THAN_QUANTITY_RULES_MAX
  QUANTITY_PRICE_BREAK_ADD_MIN_NOT_A_MULTIPLE_OF_QUANTITY_RULES_INCREMENT
  QUANTITY_PRICE_BREAK_ADD_VARIANT_NOT_FOUND
  QUANTITY_PRICE_BREAK_ADD_DUPLICATE_INPUT_FOR_VARIANT_AND_MIN
  QUANTITY_PRICE_BREAK_DELETE_NOT_FOUND
  QUANTITY_PRICE_BREAK_DELETE_FAILED
  QUANTITY_RULE_ADD_VARIANT_NOT_FOUND
  QUANTITY_RULE_ADD_MIN_HIGHER_THAN_QUANTITY_PRICE_BREAK_MIN
  QUANTITY_RULE_ADD_MAX_LOWER_THAN_QUANTITY_PRICE_BREAK_MIN
  QUANTITY_RULE_ADD_INCREMENT_NOT_A_MULTIPLE_OF_QUANTITY_PRICE_BREAK_MIN
  QUANTITY_RULE_ADD_CATALOG_CONTEXT_NOT_SUPPORTED
  QUANTITY_RULE_ADD_INCREMENT_IS_GREATER_THAN_MINIMUM
  QUANTITY_RULE_ADD_MINIMUM_NOT_A_MULTIPLE_OF_INCREMENT
  QUANTITY_RULE_ADD_MAXIMUM_NOT_A_MULTIPLE_OF_INCREMENT
  QUANTITY_RULE_ADD_MINIMUM_GREATER_THAN_MAXIMUM
  QUANTITY_RULE_ADD_INCREMENT_IS_LESS_THAN_ONE
  QUANTITY_RULE_ADD_MINIMUM_IS_LESS_THAN_ONE
  QUANTITY_RULE_ADD_MAXIMUM_IS_LESS_THAN_ONE
  QUANTITY_RULE_ADD_DUPLICATE_INPUT_FOR_VARIANT
  QUANTITY_RULE_DELETE_RULE_NOT_FOUND
  QUANTITY_RULE_DELETE_VARIANT_NOT_FOUND
  PRICE_ADD_CURRENCY_MISMATCH
  PRICE_ADD_VARIANT_NOT_FOUND
  PRICE_ADD_DUPLICATE_INPUT_FOR_VARIANT
  PRICE_DELETE_PRICE_NOT_FIXED
  PRICE_DELETE_VARIANT_NOT_FOUND
}
type QuantityRule {
  increment: Int!
  isDefault: Boolean!
  maximum: Int
  minimum: Int!
  originType: QuantityRuleOriginType!
  productVariant: ProductVariant!
}
type QuantityRuleConnection {
  edges: [QuantityRuleEdge!]!
  nodes: [QuantityRule!]!
  pageInfo: PageInfo!
}
type QuantityRuleEdge {
  cursor: String!
  node: QuantityRule!
}
input QuantityRuleInput {
  increment: Int!
  maximum: Int
  minimum: Int!
  variantId: ID!
}
enum QuantityRuleOriginType {
  FIXED
  RELATIVE
}
type QuantityRuleUserError {
  code: QuantityRuleUserErrorCode
  field: [String!]
  message: String!
}
enum QuantityRuleUserErrorCode {
  BLANK
  PRODUCT_VARIANT_DOES_NOT_EXIST
  PRICE_LIST_DOES_NOT_EXIST
  VARIANT_QUANTITY_RULE_DOES_NOT_EXIST
  MINIMUM_IS_GREATER_THAN_MAXIMUM
  MINIMUM_IS_HIGHER_THAN_QUANTITY_PRICE_BREAK_MINIMUM
  MAXIMUM_IS_LOWER_THAN_QUANTITY_PRICE_BREAK_MINIMUM
  INCREMENT_NOT_A_MULTIPLE_OF_QUANTITY_PRICE_BREAK_MINIMUM
  INCREMENT_IS_GREATER_THAN_MINIMUM
  GREATER_THAN_OR_EQUAL_TO
  MAXIMUM_NOT_MULTIPLE_OF_INCREMENT
  MINIMUM_NOT_MULTIPLE_OF_INCREMENT
  CATALOG_CONTEXT_DOES_NOT_SUPPORT_QUANTITY_RULES
  DUPLICATE_INPUT_FOR_VARIANT
  GENERIC_ERROR
}
type QuantityRulesAddPayload {
  quantityRules: [QuantityRule!]
  userErrors: [QuantityRuleUserError!]!
}
type QuantityRulesDeletePayload {
  deletedQuantityRulesVariantIds: [ID!]
  userErrors: [QuantityRuleUserError!]!
}
type QueryRoot {
  abandonedCheckouts: AbandonedCheckoutConnection!
  abandonedCheckoutsCount: Count
  abandonment: Abandonment
  abandonmentByAbandonedCheckoutId: Abandonment
  app: App
  appByHandle: App
  appByKey: App
  appDiscountType: AppDiscountType
  appDiscountTypes: [AppDiscountType!]!
  appInstallation: AppInstallation
  appInstallations: AppInstallationConnection!
  article: Article
  articleTags: [String!]!
  articles: ArticleConnection!
  assignedFulfillmentOrders: FulfillmentOrderConnection!
  automaticDiscount: DiscountAutomatic
  automaticDiscountNode: DiscountAutomaticNode
  automaticDiscountNodes: DiscountAutomaticNodeConnection!
  automaticDiscountSavedSearches: SavedSearchConnection!
  automaticDiscounts: DiscountAutomaticConnection!
  availableCarrierServices: [DeliveryCarrierServiceAndLocations!]!
  availableLocales: [Locale!]!
  blog: Blog
  blogs: BlogConnection!
  blogsCount: Count
  businessEntities: [BusinessEntity!]!
  businessEntity: BusinessEntity
  carrierService: DeliveryCarrierService
  carrierServices: DeliveryCarrierServiceConnection!
  cartTransforms: CartTransformConnection!
  cashTrackingSession: CashTrackingSession
  cashTrackingSessions: CashTrackingSessionConnection!
  catalog: Catalog
  catalogOperations: [ResourceOperation!]!
  catalogs: CatalogConnection!
  catalogsCount: Count
  channel: Channel
  channels: ChannelConnection!
  checkoutBranding: CheckoutBranding
  checkoutProfile: CheckoutProfile
  checkoutProfiles: CheckoutProfileConnection!
  codeDiscountNode: DiscountCodeNode
  codeDiscountNodeByCode: DiscountCodeNode
  codeDiscountNodes: DiscountCodeNodeConnection!
  codeDiscountSavedSearches: SavedSearchConnection!
  collection: Collection
  collectionByHandle: Collection
  collectionRulesConditions: [CollectionRuleConditions!]!
  collectionSavedSearches: SavedSearchConnection!
  collections: CollectionConnection!
  collectionsCount: Count
  comment: Comment
  comments: CommentConnection!
  companies: CompanyConnection!
  companiesCount: Count
  company: Company
  companyContact: CompanyContact
  companyContactRole: CompanyContactRole
  companyLocation: CompanyLocation
  companyLocations: CompanyLocationConnection!
  currentAppInstallation: AppInstallation!
  currentBulkOperation: BulkOperation
  currentStaffMember: StaffMember
  customer: Customer
  customerAccountPage: CustomerAccountPage
  customerAccountPages: CustomerAccountPageConnection
  customerByIdentifier: Customer
  customerMergeJobStatus: CustomerMergeRequest
  customerMergePreview: CustomerMergePreview!
  customerPaymentMethod: CustomerPaymentMethod
  customerSavedSearches: SavedSearchConnection!
  customerSegmentMembers: CustomerSegmentMemberConnection!
  customerSegmentMembersQuery: CustomerSegmentMembersQuery
  customerSegmentMembership: SegmentMembershipResponse!
  customers: CustomerConnection!
  customersCount: Count
  deletionEvents: DeletionEventConnection!
  deliveryCustomization: DeliveryCustomization
  deliveryCustomizations: DeliveryCustomizationConnection!
  deliveryProfile: DeliveryProfile
  deliveryProfiles: DeliveryProfileConnection!
  deliveryPromiseParticipants: DeliveryPromiseParticipantConnection
  deliveryPromiseProvider: DeliveryPromiseProvider
  deliveryPromiseSettings: DeliveryPromiseSetting!
  deliverySettings: DeliverySetting
  discountCodesCount: Count
  discountNode: DiscountNode
  discountNodes: DiscountNodeConnection!
  discountNodesCount: Count
  discountRedeemCodeBulkCreation: DiscountRedeemCodeBulkCreation
  discountRedeemCodeSavedSearches: SavedSearchConnection!
  dispute: ShopifyPaymentsDispute
  disputeEvidence: ShopifyPaymentsDisputeEvidence
  disputes: ShopifyPaymentsDisputeConnection!
  domain: Domain
  draftOrder: DraftOrder
  draftOrderSavedSearches: SavedSearchConnection!
  draftOrderTag: DraftOrderTag
  draftOrders: DraftOrderConnection!
  event: Event
  events: EventConnection
  eventsCount: Count
  fileSavedSearches: SavedSearchConnection!
  files: FileConnection!
  fulfillment: Fulfillment
  fulfillmentConstraintRules: [FulfillmentConstraintRule!]!
  fulfillmentOrder: FulfillmentOrder
  fulfillmentOrders: FulfillmentOrderConnection!
  fulfillmentService: FulfillmentService
  giftCard: GiftCard
  giftCards: GiftCardConnection!
  giftCardsCount: Count
  inventoryItem: InventoryItem
  inventoryItems: InventoryItemConnection!
  inventoryLevel: InventoryLevel
  inventoryProperties: InventoryProperties!
  job: Job
  location: Location
  locations: LocationConnection!
  locationsAvailableForDeliveryProfiles: [Location!]
  locationsAvailableForDeliveryProfilesConnection: LocationConnection!
  locationsCount: Count
  manualHoldsFulfillmentOrders: FulfillmentOrderConnection!
  market: Market
  marketByGeography: Market
  marketLocalizableResource: MarketLocalizableResource
  marketLocalizableResources: MarketLocalizableResourceConnection!
  marketLocalizableResourcesByIds: MarketLocalizableResourceConnection!
  marketingActivities: MarketingActivityConnection!
  marketingActivity: MarketingActivity
  marketingEvent: MarketingEvent
  marketingEvents: MarketingEventConnection!
  markets: MarketConnection!
  menu: Menu
  menus: MenuConnection!
  metafieldDefinition: MetafieldDefinition
  metafieldDefinitionTypes: [MetafieldDefinitionType!]!
  metafieldDefinitions: MetafieldDefinitionConnection!
  metaobject: Metaobject
  metaobjectByHandle: Metaobject
  metaobjectDefinition: MetaobjectDefinition
  metaobjectDefinitionByType: MetaobjectDefinition
  metaobjectDefinitions: MetaobjectDefinitionConnection!
  metaobjects: MetaobjectConnection!
  mobilePlatformApplication: MobilePlatformApplication
  mobilePlatformApplications: MobilePlatformApplicationConnection!
  node: Node
  nodes: [Node]!
  onlineStore: OnlineStore!
  order: Order
  orderPaymentStatus: OrderPaymentStatus
  orderSavedSearches: SavedSearchConnection!
  orders: OrderConnection!
  ordersCount: Count
  page: Page
  pages: PageConnection!
  pagesCount: Count
  paymentCustomization: PaymentCustomization
  paymentCustomizations: PaymentCustomizationConnection!
  paymentTermsTemplates: [PaymentTermsTemplate!]!
  pendingOrdersCount: Count
  priceList: PriceList
  priceLists: PriceListConnection!
  primaryMarket: Market!
  product: Product
  productByHandle: Product
  productByIdentifier: Product
  productDuplicateJob: ProductDuplicateJob!
  productFeed: ProductFeed
  productFeeds: ProductFeedConnection!
  productOperation: ProductOperation
  productResourceFeedback: ProductResourceFeedback
  productSavedSearches: SavedSearchConnection!
  productTags: StringConnection
  productTypes: StringConnection
  productVariant: ProductVariant
  productVariants: ProductVariantConnection!
  productVariantsCount: Count
  productVendors: StringConnection
  products: ProductConnection!
  productsCount: Count
  publicApiVersions: [ApiVersion!]!
  publication: Publication
  publications: PublicationConnection!
  publicationsCount: Count
  publishedProductsCount: Count
  refund: Refund
  return: Return
  returnCalculate: CalculatedReturn
  returnableFulfillment: ReturnableFulfillment
  returnableFulfillments: ReturnableFulfillmentConnection!
  reverseDelivery: ReverseDelivery
  reverseFulfillmentOrder: ReverseFulfillmentOrder
  scriptTag: ScriptTag
  scriptTags: ScriptTagConnection!
  segment: Segment
  segmentFilterSuggestions: SegmentFilterConnection!
  segmentFilters: SegmentFilterConnection!
  segmentMigrations: SegmentMigrationConnection!
  segmentValueSuggestions: SegmentValueConnection!
  segments: SegmentConnection!
  segmentsCount: Count
  sellingPlanGroup: SellingPlanGroup
  sellingPlanGroups: SellingPlanGroupConnection!
  serverPixel: ServerPixel
  shop: Shop!
  shopBillingPreferences: ShopBillingPreferences!
  shopLocales: [ShopLocale!]!
  shopifyFunction: ShopifyFunction
  shopifyFunctions: ShopifyFunctionConnection!
  shopifyPaymentsAccount: ShopifyPaymentsAccount
  staffMember: StaffMember
  staffMembers: StaffMemberConnection
  standardMetafieldDefinitionTemplates: StandardMetafieldDefinitionTemplateConnection!
  storeCreditAccount: StoreCreditAccount
  subscriptionBillingAttempt: SubscriptionBillingAttempt
  subscriptionBillingAttempts: SubscriptionBillingAttemptConnection!
  subscriptionBillingCycle: SubscriptionBillingCycle
  subscriptionBillingCycleBulkResults: SubscriptionBillingCycleConnection!
  subscriptionBillingCycles: SubscriptionBillingCycleConnection!
  subscriptionContract: SubscriptionContract
  subscriptionContracts: SubscriptionContractConnection!
  subscriptionDraft: SubscriptionDraft
  taxonomy: Taxonomy
  tenderTransactions: TenderTransactionConnection!
  theme: OnlineStoreTheme
  themes: OnlineStoreThemeConnection
  translatableResource: TranslatableResource
  translatableResources: TranslatableResourceConnection!
  translatableResourcesByIds: TranslatableResourceConnection!
  urlRedirect: UrlRedirect
  urlRedirectImport: UrlRedirectImport
  urlRedirectSavedSearches: SavedSearchConnection!
  urlRedirects: UrlRedirectConnection!
  urlRedirectsCount: Count
  validation: Validation
  validations: ValidationConnection!
  webPixel: WebPixel
  webhookSubscription: WebhookSubscription
  webhookSubscriptions: WebhookSubscriptionConnection!
  webhookSubscriptionsCount: Count
}
type Refund {
  createdAt: DateTime
  duties: [RefundDuty!]
  id: ID!
  legacyResourceId: UnsignedInt64!
  note: String
  order: Order!
  orderAdjustments: OrderAdjustmentConnection!
  refundLineItems: RefundLineItemConnection!
  refundShippingLines: RefundShippingLineConnection!
  return: Return
  staffMember: StaffMember
  totalRefunded: MoneyV2!
  totalRefundedSet: MoneyBag!
  transactions: OrderTransactionConnection!
  updatedAt: DateTime!
}
type RefundAgreement {
  app: App
  happenedAt: DateTime!
  id: ID!
  reason: OrderActionType!
  refund: Refund!
  sales: SaleConnection!
  user: StaffMember
}
type RefundConnection {
  edges: [RefundEdge!]!
  nodes: [Refund!]!
  pageInfo: PageInfo!
}
type RefundCreatePayload {
  order: Order
  refund: Refund
  userErrors: [UserError!]!
}
type RefundDuty {
  amountSet: MoneyBag!
  originalDuty: Duty
}
input RefundDutyInput {
  dutyId: ID!
  refundType: RefundDutyRefundType
}
enum RefundDutyRefundType {
  PROPORTIONAL
  FULL
}
type RefundEdge {
  cursor: String!
  node: Refund!
}
input RefundInput {
  currency: CurrencyCode
  orderId: ID!
  note: String
  notify: Boolean
  shipping: ShippingRefundInput
  refundLineItems: [RefundLineItemInput!]
  refundDuties: [RefundDutyInput!]
  transactions: [OrderTransactionInput!]
  discrepancyReason: OrderAdjustmentInputDiscrepancyReason
}
type RefundLineItem {
  id: ID
  lineItem: LineItem!
  location: Location
  price: Money!
  priceSet: MoneyBag!
  quantity: Int!
  restockType: RefundLineItemRestockType!
  restocked: Boolean!
  subtotal: Money!
  subtotalSet: MoneyBag!
  totalTax: Money!
  totalTaxSet: MoneyBag!
}
type RefundLineItemConnection {
  edges: [RefundLineItemEdge!]!
  nodes: [RefundLineItem!]!
  pageInfo: PageInfo!
}
type RefundLineItemEdge {
  cursor: String!
  node: RefundLineItem!
}
input RefundLineItemInput {
  lineItemId: ID!
  quantity: Int!
  restockType: RefundLineItemRestockType
  locationId: ID
}
enum RefundLineItemRestockType {
  RETURN
  CANCEL
  LEGACY_RESTOCK
  NO_RESTOCK
}
input RefundShippingInput {
  shippingRefundAmount: MoneyInput
  fullRefund: Boolean
}
type RefundShippingLine {
  id: ID!
  shippingLine: ShippingLine!
  subtotalAmountSet: MoneyBag!
  taxAmountSet: MoneyBag!
}
type RefundShippingLineConnection {
  edges: [RefundShippingLineEdge!]!
  nodes: [RefundShippingLine!]!
  pageInfo: PageInfo!
}
type RefundShippingLineEdge {
  cursor: String!
  node: RefundShippingLine!
}
input RemoteAuthorizeNetCustomerPaymentProfileInput {
  customerProfileId: String!
  customerPaymentProfileId: String
}
input RemoteBraintreePaymentMethodInput {
  customerId: String!
  paymentMethodToken: String
}
input RemoteStripePaymentMethodInput {
  customerId: String!
  paymentMethodId: String
}
type ResourceAlert {
  actions: [ResourceAlertAction!]!
  content: HTML!
  dismissibleHandle: String
  icon: ResourceAlertIcon
  severity: ResourceAlertSeverity!
  title: String!
}
type ResourceAlertAction {
  primary: Boolean!
  show: String
  title: String!
  url: URL!
}
enum ResourceAlertIcon {
  CHECKMARK_CIRCLE
  INFORMATION_CIRCLE
}
enum ResourceAlertSeverity {
  DEFAULT
  INFO
  WARNING
  SUCCESS
  CRITICAL
  ERROR
}
type ResourceFeedback {
  appFeedback: [AppFeedback!]!
  details: [AppFeedback!]!
  summary: String!
}
input ResourceFeedbackCreateInput {
  feedbackGeneratedAt: DateTime!
  messages: [String!]
  state: ResourceFeedbackState!
}
enum ResourceFeedbackState {
  ACCEPTED
  REQUIRES_ACTION
}
interface ResourceOperation {
  id: ID!
  processedRowCount: Int
  rowCount: RowCount
  status: ResourceOperationStatus!
}
enum ResourceOperationStatus {
  CREATED
  ACTIVE
  COMPLETE
}
type ResourcePublication {
  channel: Channel!
  isPublished: Boolean!
  publication: Publication!
  publishDate: DateTime!
  publishable: Publishable!
}
type ResourcePublicationConnection {
  edges: [ResourcePublicationEdge!]!
  nodes: [ResourcePublication!]!
  pageInfo: PageInfo!
}
type ResourcePublicationEdge {
  cursor: String!
  node: ResourcePublication!
}
type ResourcePublicationV2 {
  isPublished: Boolean!
  publication: Publication!
  publishDate: DateTime
  publishable: Publishable!
}
type ResourcePublicationV2Connection {
  edges: [ResourcePublicationV2Edge!]!
  nodes: [ResourcePublicationV2!]!
  pageInfo: PageInfo!
}
type ResourcePublicationV2Edge {
  cursor: String!
  node: ResourcePublicationV2!
}
type RestockingFee {
  amountSet: MoneyBag!
  id: ID!
  percentage: Float!
}
input RestockingFeeInput {
  percentage: Float!
}
type RestrictedForResource {
  restricted: Boolean!
  restrictedReason: String!
}
type Return {
  decline: ReturnDecline
  exchangeLineItems: ExchangeLineItemConnection!
  id: ID!
  name: String!
  order: Order!
  refunds: RefundConnection!
  returnLineItems: ReturnLineItemTypeConnection!
  returnShippingFees: [ReturnShippingFee!]!
  reverseFulfillmentOrders: ReverseFulfillmentOrderConnection!
  status: ReturnStatus!
  suggestedRefund: SuggestedReturnRefund
  totalQuantity: Int!
}
type ReturnAgreement {
  app: App
  happenedAt: DateTime!
  id: ID!
  reason: OrderActionType!
  return: Return!
  sales: SaleConnection!
  user: StaffMember
}
input ReturnApproveRequestInput {
  id: ID!
  notifyCustomer: Boolean
}
type ReturnApproveRequestPayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
type ReturnCancelPayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
type ReturnClosePayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
type ReturnConnection {
  edges: [ReturnEdge!]!
  nodes: [Return!]!
  pageInfo: PageInfo!
}
type ReturnCreatePayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
type ReturnDecline {
  note: String
  reason: ReturnDeclineReason!
}
enum ReturnDeclineReason {
  RETURN_PERIOD_ENDED
  FINAL_SALE
  OTHER
}
input ReturnDeclineRequestInput {
  id: ID!
  declineReason: ReturnDeclineReason!
  notifyCustomer: Boolean
  declineNote: String
}
type ReturnDeclineRequestPayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
type ReturnEdge {
  cursor: String!
  node: Return!
}
enum ReturnErrorCode {
  INTERNAL_ERROR
  TOO_MANY_ARGUMENTS
  BLANK
  EQUAL_TO
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  INCLUSION
  INVALID
  LESS_THAN
  LESS_THAN_OR_EQUAL_TO
  NOT_A_NUMBER
  PRESENT
  TAKEN
  TOO_BIG
  TOO_LONG
  TOO_SHORT
  WRONG_LENGTH
  ALREADY_EXISTS
  CREATION_FAILED
  FEATURE_NOT_ENABLED
  INVALID_STATE
  NOTIFICATION_FAILED
  NOT_EDITABLE
  NOT_FOUND
}
input ReturnInput {
  exchangeLineItems: [ExchangeLineItemInput!]
  requestedAt: DateTime
  orderId: ID!
  returnLineItems: [ReturnLineItemInput!]!
  returnShippingFee: ReturnShippingFeeInput
}
type ReturnLineItem {
  customerNote: String
  fulfillmentLineItem: FulfillmentLineItem!
  id: ID!
  quantity: Int!
  refundableQuantity: Int!
  refundedQuantity: Int!
  restockingFee: RestockingFee
  returnReason: ReturnReason!
  returnReasonNote: String!
  totalWeight: Weight
  withCodeDiscountedTotalPriceSet: MoneyBag!
}
input ReturnLineItemInput {
  quantity: Int!
  returnReason: ReturnReason!
  returnReasonNote: String
  fulfillmentLineItemId: ID!
  restockingFee: RestockingFeeInput
}
input ReturnLineItemRemoveFromReturnInput {
  returnLineItemId: ID!
  quantity: Int!
}
type ReturnLineItemRemoveFromReturnPayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
interface ReturnLineItemType {
  customerNote: String
  id: ID!
  quantity: Int!
  refundableQuantity: Int!
  refundedQuantity: Int!
  returnReason: ReturnReason!
  returnReasonNote: String!
}
type ReturnLineItemTypeConnection {
  edges: [ReturnLineItemTypeEdge!]!
  nodes: [ReturnLineItemType!]!
  pageInfo: PageInfo!
}
type ReturnLineItemTypeEdge {
  cursor: String!
  node: ReturnLineItemType!
}
enum ReturnReason {
  SIZE_TOO_SMALL
  SIZE_TOO_LARGE
  UNWANTED
  NOT_AS_DESCRIBED
  WRONG_ITEM
  DEFECTIVE
  STYLE
  COLOR
  OTHER
  UNKNOWN
}
input ReturnRefundInput {
  returnId: ID!
  returnRefundLineItems: [ReturnRefundLineItemInput!]!
  refundShipping: RefundShippingInput
  refundDuties: [RefundDutyInput!]
  orderTransactions: [ReturnRefundOrderTransactionInput!]
  notifyCustomer: Boolean
}
input ReturnRefundLineItemInput {
  returnLineItemId: ID!
  quantity: Int!
}
input ReturnRefundOrderTransactionInput {
  transactionAmount: MoneyInput!
  parentId: ID!
}
type ReturnRefundPayload {
  refund: Refund
  userErrors: [ReturnUserError!]!
}
type ReturnReopenPayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
input ReturnRequestInput {
  orderId: ID!
  returnLineItems: [ReturnRequestLineItemInput!]!
  returnShippingFee: ReturnShippingFeeInput
}
input ReturnRequestLineItemInput {
  fulfillmentLineItemId: ID!
  quantity: Int!
  restockingFee: RestockingFeeInput
  returnReason: ReturnReason!
  customerNote: String
}
type ReturnRequestPayload {
  return: Return
  userErrors: [ReturnUserError!]!
}
type ReturnShippingFee {
  amountSet: MoneyBag!
  id: ID!
}
input ReturnShippingFeeInput {
  amount: MoneyInput!
}
enum ReturnStatus {
  CANCELED
  CLOSED
  OPEN
  REQUESTED
  DECLINED
}
type ReturnUserError {
  code: ReturnErrorCode
  field: [String!]
  message: String!
}
type ReturnableFulfillment {
  fulfillment: Fulfillment!
  id: ID!
  returnableFulfillmentLineItems: ReturnableFulfillmentLineItemConnection!
}
type ReturnableFulfillmentConnection {
  edges: [ReturnableFulfillmentEdge!]!
  nodes: [ReturnableFulfillment!]!
  pageInfo: PageInfo!
}
type ReturnableFulfillmentEdge {
  cursor: String!
  node: ReturnableFulfillment!
}
type ReturnableFulfillmentLineItem {
  fulfillmentLineItem: FulfillmentLineItem!
  quantity: Int!
}
type ReturnableFulfillmentLineItemConnection {
  edges: [ReturnableFulfillmentLineItemEdge!]!
  nodes: [ReturnableFulfillmentLineItem!]!
  pageInfo: PageInfo!
}
type ReturnableFulfillmentLineItemEdge {
  cursor: String!
  node: ReturnableFulfillmentLineItem!
}
type ReverseDelivery {
  deliverable: ReverseDeliveryDeliverable
  id: ID!
  reverseDeliveryLineItems: ReverseDeliveryLineItemConnection!
  reverseFulfillmentOrder: ReverseFulfillmentOrder!
}
type ReverseDeliveryConnection {
  edges: [ReverseDeliveryEdge!]!
  nodes: [ReverseDelivery!]!
  pageInfo: PageInfo!
}
type ReverseDeliveryCreateWithShippingPayload {
  reverseDelivery: ReverseDelivery
  userErrors: [ReturnUserError!]!
}
union ReverseDeliveryDeliverable = ReverseDeliveryShippingDeliverable
type ReverseDeliveryEdge {
  cursor: String!
  node: ReverseDelivery!
}
input ReverseDeliveryLabelInput {
  fileUrl: URL!
}
type ReverseDeliveryLabelV2 {
  createdAt: DateTime!
  publicFileUrl: URL
  updatedAt: DateTime!
}
type ReverseDeliveryLineItem {
  dispositions: [ReverseFulfillmentOrderDisposition!]!
  id: ID!
  quantity: Int!
  reverseFulfillmentOrderLineItem: ReverseFulfillmentOrderLineItem!
}
type ReverseDeliveryLineItemConnection {
  edges: [ReverseDeliveryLineItemEdge!]!
  nodes: [ReverseDeliveryLineItem!]!
  pageInfo: PageInfo!
}
type ReverseDeliveryLineItemEdge {
  cursor: String!
  node: ReverseDeliveryLineItem!
}
input ReverseDeliveryLineItemInput {
  reverseFulfillmentOrderLineItemId: ID!
  quantity: Int!
}
type ReverseDeliveryShippingDeliverable {
  label: ReverseDeliveryLabelV2
  tracking: ReverseDeliveryTrackingV2
}
type ReverseDeliveryShippingUpdatePayload {
  reverseDelivery: ReverseDelivery
  userErrors: [ReturnUserError!]!
}
input ReverseDeliveryTrackingInput {
  number: String
  url: URL
}
type ReverseDeliveryTrackingV2 {
  carrierName: String
  number: String
  url: URL
}
type ReverseFulfillmentOrder {
  id: ID!
  lineItems: ReverseFulfillmentOrderLineItemConnection!
  order: Order
  reverseDeliveries: ReverseDeliveryConnection!
  status: ReverseFulfillmentOrderStatus!
  thirdPartyConfirmation: ReverseFulfillmentOrderThirdPartyConfirmation
}
type ReverseFulfillmentOrderConnection {
  edges: [ReverseFulfillmentOrderEdge!]!
  nodes: [ReverseFulfillmentOrder!]!
  pageInfo: PageInfo!
}
input ReverseFulfillmentOrderDisposeInput {
  reverseFulfillmentOrderLineItemId: ID!
  quantity: Int!
  locationId: ID
  dispositionType: ReverseFulfillmentOrderDispositionType!
}
type ReverseFulfillmentOrderDisposePayload {
  reverseFulfillmentOrderLineItems: [ReverseFulfillmentOrderLineItem!]
  userErrors: [ReturnUserError!]!
}
type ReverseFulfillmentOrderDisposition {
  id: ID!
  location: Location
  quantity: Int!
  type: ReverseFulfillmentOrderDispositionType!
}
enum ReverseFulfillmentOrderDispositionType {
  RESTOCKED
  PROCESSING_REQUIRED
  NOT_RESTOCKED
  MISSING
}
type ReverseFulfillmentOrderEdge {
  cursor: String!
  node: ReverseFulfillmentOrder!
}
type ReverseFulfillmentOrderLineItem {
  dispositions: [ReverseFulfillmentOrderDisposition!]!
  fulfillmentLineItem: FulfillmentLineItem
  id: ID!
  totalQuantity: Int!
}
type ReverseFulfillmentOrderLineItemConnection {
  edges: [ReverseFulfillmentOrderLineItemEdge!]!
  nodes: [ReverseFulfillmentOrderLineItem!]!
  pageInfo: PageInfo!
}
type ReverseFulfillmentOrderLineItemEdge {
  cursor: String!
  node: ReverseFulfillmentOrderLineItem!
}
enum ReverseFulfillmentOrderStatus {
  CANCELED
  CLOSED
  OPEN
}
type ReverseFulfillmentOrderThirdPartyConfirmation {
  status: ReverseFulfillmentOrderThirdPartyConfirmationStatus!
}
enum ReverseFulfillmentOrderThirdPartyConfirmationStatus {
  ACCEPTED
  CANCEL_ACCEPTED
  CANCEL_REJECTED
  PENDING_ACCEPTANCE
  PENDING_CANCELATION
  REJECTED
}
enum RiskAssessmentResult {
  HIGH
  MEDIUM
  LOW
  NONE
  PENDING
}
type RiskFact {
  description: String!
  sentiment: RiskFactSentiment!
}
enum RiskFactSentiment {
  POSITIVE
  NEUTRAL
  NEGATIVE
}
type RowCount {
  count: Int!
  exceedsMax: Boolean!
}
type SEO {
  description: String
  title: String
}
input SEOInput {
  title: String
  description: String
}
interface Sale {
  actionType: SaleActionType!
  id: ID!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
enum SaleActionType {
  ORDER
  RETURN
  UPDATE
  UNKNOWN
}
type SaleAdditionalFee {
  id: ID!
  name: String!
  price: MoneyBag!
  taxLines: [TaxLine!]!
}
type SaleConnection {
  edges: [SaleEdge!]!
  nodes: [Sale!]!
  pageInfo: PageInfo!
}
type SaleEdge {
  cursor: String!
  node: Sale!
}
enum SaleLineType {
  PRODUCT
  TIP
  GIFT_CARD
  SHIPPING
  DUTY
  ADDITIONAL_FEE
  FEE
  UNKNOWN
  ADJUSTMENT
}
type SaleTax {
  amount: MoneyBag!
  id: ID!
  taxLine: TaxLine!
}
interface SalesAgreement {
  app: App
  happenedAt: DateTime!
  id: ID!
  reason: OrderActionType!
  sales: SaleConnection!
  user: StaffMember
}
type SalesAgreementConnection {
  edges: [SalesAgreementEdge!]!
  nodes: [SalesAgreement!]!
  pageInfo: PageInfo!
}
type SalesAgreementEdge {
  cursor: String!
  node: SalesAgreement!
}
type SavedSearch {
  filters: [SearchFilter!]!
  id: ID!
  legacyResourceId: UnsignedInt64!
  name: String!
  query: String!
  resourceType: SearchResultType!
  searchTerms: String!
}
type SavedSearchConnection {
  edges: [SavedSearchEdge!]!
  nodes: [SavedSearch!]!
  pageInfo: PageInfo!
}
input SavedSearchCreateInput {
  resourceType: SearchResultType!
  name: String!
  query: String!
}
type SavedSearchCreatePayload {
  savedSearch: SavedSearch
  userErrors: [UserError!]!
}
input SavedSearchDeleteInput {
  id: ID!
}
type SavedSearchDeletePayload {
  deletedSavedSearchId: ID
  shop: Shop!
  userErrors: [UserError!]!
}
type SavedSearchEdge {
  cursor: String!
  node: SavedSearch!
}
input SavedSearchUpdateInput {
  id: ID!
  name: String
  query: String
}
type SavedSearchUpdatePayload {
  savedSearch: SavedSearch
  userErrors: [UserError!]!
}
enum ScheduledChangeSortKeys {
  EXPECTED_AT
  ID
  RELEVANCE
}
type ScriptDiscountApplication {
  allocationMethod: DiscountApplicationAllocationMethod!
  description: String!
  index: Int!
  targetSelection: DiscountApplicationTargetSelection!
  targetType: DiscountApplicationTargetType!
  title: String!
  value: PricingValue!
}
type ScriptTag {
  cache: Boolean!
  createdAt: DateTime!
  displayScope: ScriptTagDisplayScope!
  id: ID!
  legacyResourceId: UnsignedInt64!
  src: URL!
  updatedAt: DateTime!
}
type ScriptTagConnection {
  edges: [ScriptTagEdge!]!
  nodes: [ScriptTag!]!
  pageInfo: PageInfo!
}
type ScriptTagCreatePayload {
  scriptTag: ScriptTag
  userErrors: [UserError!]!
}
type ScriptTagDeletePayload {
  deletedScriptTagId: ID
  userErrors: [UserError!]!
}
enum ScriptTagDisplayScope {
  ALL
  ORDER_STATUS
  ONLINE_STORE
}
type ScriptTagEdge {
  cursor: String!
  node: ScriptTag!
}
input ScriptTagInput {
  src: URL
  displayScope: ScriptTagDisplayScope
  cache: Boolean
}
type ScriptTagUpdatePayload {
  scriptTag: ScriptTag
  userErrors: [UserError!]!
}
type SearchFilter {
  key: String!
  value: String!
}
type SearchFilterOptions {
  productAvailability: [FilterOption!]!
}
type SearchResult {
  description: String
  image: Image
  reference: Node!
  title: String!
  url: URL!
}
type SearchResultConnection {
  edges: [SearchResultEdge!]!
  pageInfo: PageInfo!
  resultsAfterCount: Int!
}
type SearchResultEdge {
  cursor: String!
  node: SearchResult!
}
enum SearchResultType {
  CUSTOMER
  DRAFT_ORDER
  PRODUCT
  COLLECTION
  FILE
  PAGE
  BLOG
  ARTICLE
  URL_REDIRECT
  PRICE_RULE
  DISCOUNT_REDEEM_CODE
  ORDER
  BALANCE_TRANSACTION
}
type Segment {
  creationDate: DateTime!
  id: ID!
  lastEditDate: DateTime!
  name: String!
  query: String!
}
type SegmentAssociationFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentAttributeStatistics {
  average: Float!
  sum: Float!
}
type SegmentBooleanFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentConnection {
  edges: [SegmentEdge!]!
  nodes: [Segment!]!
  pageInfo: PageInfo!
}
type SegmentCreatePayload {
  segment: Segment
  userErrors: [UserError!]!
}
type SegmentDateFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentDeletePayload {
  deletedSegmentId: ID
  userErrors: [UserError!]!
}
type SegmentEdge {
  cursor: String!
  node: Segment!
}
type SegmentEnumFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentEventFilter {
  localizedName: String!
  multiValue: Boolean!
  parameters: [SegmentEventFilterParameter!]!
  queryName: String!
  returnValueType: String!
}
type SegmentEventFilterParameter {
  acceptsMultipleValues: Boolean!
  localizedDescription: String!
  localizedName: String!
  optional: Boolean!
  parameterType: String!
  queryName: String!
}
interface SegmentFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentFilterConnection {
  edges: [SegmentFilterEdge!]!
  nodes: [SegmentFilter!]!
  pageInfo: PageInfo!
}
type SegmentFilterEdge {
  cursor: String!
  node: SegmentFilter!
}
type SegmentFloatFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentIntegerFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentMembership {
  isMember: Boolean!
  segmentId: ID!
}
type SegmentMembershipResponse {
  memberships: [SegmentMembership!]!
}
type SegmentMigration {
  id: ID!
  savedSearchId: ID!
  segmentId: ID
}
type SegmentMigrationConnection {
  edges: [SegmentMigrationEdge!]!
  nodes: [SegmentMigration!]!
  pageInfo: PageInfo!
}
type SegmentMigrationEdge {
  cursor: String!
  node: SegmentMigration!
}
enum SegmentSortKeys {
  CREATION_DATE
  ID
  LAST_EDIT_DATE
  RELEVANCE
}
type SegmentStatistics {
  attributeStatistics: SegmentAttributeStatistics!
}
type SegmentStringFilter {
  localizedName: String!
  multiValue: Boolean!
  queryName: String!
}
type SegmentUpdatePayload {
  segment: Segment
  userErrors: [UserError!]!
}
type SegmentValue {
  localizedValue: String!
  queryName: String!
}
type SegmentValueConnection {
  edges: [SegmentValueEdge!]!
  nodes: [SegmentValue!]!
  pageInfo: PageInfo!
}
type SegmentValueEdge {
  cursor: String!
  node: SegmentValue!
}
type SelectedOption {
  name: String!
  optionValue: ProductOptionValue!
  value: String!
}
input SelectedVariantOptionInput {
  name: String!
  value: String!
  linkedMetafieldValue: String
}
type SellingPlan {
  billingPolicy: SellingPlanBillingPolicy!
  category: SellingPlanCategory
  createdAt: DateTime!
  deliveryPolicy: SellingPlanDeliveryPolicy!
  description: String
  id: ID!
  inventoryPolicy: SellingPlanInventoryPolicy
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  name: String!
  options: [String!]!
  position: Int
  pricingPolicies: [SellingPlanPricingPolicy!]!
  translations: [Translation!]!
}
type SellingPlanAnchor {
  cutoffDay: Int
  day: Int!
  month: Int
  type: SellingPlanAnchorType!
}
input SellingPlanAnchorInput {
  type: SellingPlanAnchorType
  day: Int
  month: Int
  cutoffDay: Int
}
enum SellingPlanAnchorType {
  WEEKDAY
  MONTHDAY
  YEARDAY
}
union SellingPlanBillingPolicy = SellingPlanFixedBillingPolicy | SellingPlanRecurringBillingPolicy
input SellingPlanBillingPolicyInput {
  fixed: SellingPlanFixedBillingPolicyInput
  recurring: SellingPlanRecurringBillingPolicyInput
}
enum SellingPlanCategory {
  OTHER
  PRE_ORDER
  SUBSCRIPTION
  TRY_BEFORE_YOU_BUY
}
type SellingPlanCheckoutCharge {
  type: SellingPlanCheckoutChargeType!
  value: SellingPlanCheckoutChargeValue!
}
input SellingPlanCheckoutChargeInput {
  type: SellingPlanCheckoutChargeType
  value: SellingPlanCheckoutChargeValueInput
}
type SellingPlanCheckoutChargePercentageValue {
  percentage: Float!
}
enum SellingPlanCheckoutChargeType {
  PERCENTAGE
  PRICE
}
union SellingPlanCheckoutChargeValue = MoneyV2 | SellingPlanCheckoutChargePercentageValue
input SellingPlanCheckoutChargeValueInput {
  percentage: Float
  fixedValue: Decimal
}
type SellingPlanConnection {
  edges: [SellingPlanEdge!]!
  nodes: [SellingPlan!]!
  pageInfo: PageInfo!
}
union SellingPlanDeliveryPolicy = SellingPlanFixedDeliveryPolicy | SellingPlanRecurringDeliveryPolicy
input SellingPlanDeliveryPolicyInput {
  fixed: SellingPlanFixedDeliveryPolicyInput
  recurring: SellingPlanRecurringDeliveryPolicyInput
}
type SellingPlanEdge {
  cursor: String!
  node: SellingPlan!
}
type SellingPlanFixedBillingPolicy {
  checkoutCharge: SellingPlanCheckoutCharge!
  remainingBalanceChargeExactTime: DateTime
  remainingBalanceChargeTimeAfterCheckout: String
  remainingBalanceChargeTrigger: SellingPlanRemainingBalanceChargeTrigger!
}
input SellingPlanFixedBillingPolicyInput {
  remainingBalanceChargeTrigger: SellingPlanRemainingBalanceChargeTrigger
  remainingBalanceChargeExactTime: DateTime
  remainingBalanceChargeTimeAfterCheckout: String
  checkoutCharge: SellingPlanCheckoutChargeInput
}
type SellingPlanFixedDeliveryPolicy {
  anchors: [SellingPlanAnchor!]!
  cutoff: Int
  fulfillmentExactTime: DateTime
  fulfillmentTrigger: SellingPlanFulfillmentTrigger!
  intent: SellingPlanFixedDeliveryPolicyIntent!
  preAnchorBehavior: SellingPlanFixedDeliveryPolicyPreAnchorBehavior!
}
input SellingPlanFixedDeliveryPolicyInput {
  anchors: [SellingPlanAnchorInput!]
  fulfillmentTrigger: SellingPlanFulfillmentTrigger
  fulfillmentExactTime: DateTime
  cutoff: Int
  intent: SellingPlanFixedDeliveryPolicyIntent
  preAnchorBehavior: SellingPlanFixedDeliveryPolicyPreAnchorBehavior
}
enum SellingPlanFixedDeliveryPolicyIntent {
  FULFILLMENT_BEGIN
}
enum SellingPlanFixedDeliveryPolicyPreAnchorBehavior {
  ASAP
  NEXT
}
type SellingPlanFixedPricingPolicy {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType!
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
  createdAt: DateTime!
}
input SellingPlanFixedPricingPolicyInput {
  id: ID
  adjustmentType: SellingPlanPricingPolicyAdjustmentType
  adjustmentValue: SellingPlanPricingPolicyValueInput
}
enum SellingPlanFulfillmentTrigger {
  ANCHOR
  ASAP
  EXACT_TIME
  UNKNOWN
}
type SellingPlanGroup {
  appId: String
  appliesToProduct: Boolean!
  appliesToProductVariant: Boolean!
  appliesToProductVariants: Boolean!
  createdAt: DateTime!
  description: String
  id: ID!
  merchantCode: String!
  name: String!
  options: [String!]!
  position: Int
  productVariants: ProductVariantConnection!
  productVariantsCount: Count
  products: ProductConnection!
  productsCount: Count
  sellingPlans: SellingPlanConnection!
  summary: String
  translations: [Translation!]!
}
type SellingPlanGroupAddProductVariantsPayload {
  sellingPlanGroup: SellingPlanGroup
  userErrors: [SellingPlanGroupUserError!]!
}
type SellingPlanGroupAddProductsPayload {
  sellingPlanGroup: SellingPlanGroup
  userErrors: [SellingPlanGroupUserError!]!
}
type SellingPlanGroupConnection {
  edges: [SellingPlanGroupEdge!]!
  nodes: [SellingPlanGroup!]!
  pageInfo: PageInfo!
}
type SellingPlanGroupCreatePayload {
  sellingPlanGroup: SellingPlanGroup
  userErrors: [SellingPlanGroupUserError!]!
}
type SellingPlanGroupDeletePayload {
  deletedSellingPlanGroupId: ID
  userErrors: [SellingPlanGroupUserError!]!
}
type SellingPlanGroupEdge {
  cursor: String!
  node: SellingPlanGroup!
}
input SellingPlanGroupInput {
  name: String
  appId: String
  merchantCode: String
  description: String
  sellingPlansToCreate: [SellingPlanInput!]
  sellingPlansToUpdate: [SellingPlanInput!]
  sellingPlansToDelete: [ID!]
  options: [String!]
  position: Int
}
type SellingPlanGroupRemoveProductVariantsPayload {
  removedProductVariantIds: [ID!]
  userErrors: [SellingPlanGroupUserError!]!
}
type SellingPlanGroupRemoveProductsPayload {
  removedProductIds: [ID!]
  userErrors: [SellingPlanGroupUserError!]!
}
input SellingPlanGroupResourceInput {
  productVariantIds: [ID!]
  productIds: [ID!]
}
enum SellingPlanGroupSortKeys {
  CREATED_AT
  ID
  NAME
  RELEVANCE
  UPDATED_AT
}
type SellingPlanGroupUpdatePayload {
  deletedSellingPlanIds: [ID!]
  sellingPlanGroup: SellingPlanGroup
  userErrors: [SellingPlanGroupUserError!]!
}
type SellingPlanGroupUserError {
  code: SellingPlanGroupUserErrorCode
  field: [String!]
  message: String!
}
enum SellingPlanGroupUserErrorCode {
  BLANK
  EQUAL_TO
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  INCLUSION
  INVALID
  LESS_THAN
  LESS_THAN_OR_EQUAL_TO
  NOT_A_NUMBER
  NOT_FOUND
  PRESENT
  TAKEN
  TOO_BIG
  TOO_LONG
  TOO_SHORT
  WRONG_LENGTH
  SELLING_PLAN_COUNT_UPPER_BOUND
  SELLING_PLAN_COUNT_LOWER_BOUND
  SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES
  SELLING_PLAN_BILLING_AND_DELIVERY_POLICY_ANCHORS_MUST_BE_EQUAL
  SELLING_PLAN_BILLING_CYCLE_MUST_BE_A_MULTIPLE_OF_DELIVERY_CYCLE
  SELLING_PLAN_PRICING_POLICIES_MUST_CONTAIN_A_FIXED_PRICING_POLICY
  SELLING_PLAN_MISSING_OPTION2_LABEL_ON_PARENT_GROUP
  SELLING_PLAN_MISSING_OPTION3_LABEL_ON_PARENT_GROUP
  SELLING_PLAN_OPTION2_REQUIRED_AS_DEFINED_ON_PARENT_GROUP
  SELLING_PLAN_OPTION3_REQUIRED_AS_DEFINED_ON_PARENT_GROUP
  SELLING_PLAN_PRICING_POLICIES_LIMIT
  RESOURCE_LIST_CONTAINS_INVALID_IDS
  PRODUCT_VARIANT_DOES_NOT_EXIST
  PRODUCT_DOES_NOT_EXIST
  GROUP_DOES_NOT_EXIST
  GROUP_COULD_NOT_BE_DELETED
  ERROR_ADDING_RESOURCE_TO_GROUP
  SELLING_PLAN_DELIVERY_POLICY_MISSING
  SELLING_PLAN_BILLING_POLICY_MISSING
  PLAN_DOES_NOT_EXIST
  PLAN_ID_MUST_BE_SPECIFIED_TO_UPDATE
  ONLY_NEED_ONE_BILLING_POLICY_TYPE
  ONLY_NEED_ONE_DELIVERY_POLICY_TYPE
  ONLY_NEED_ONE_PRICING_POLICY_TYPE
  BILLING_AND_DELIVERY_POLICY_TYPES_MUST_BE_THE_SAME
  ONLY_NEED_ONE_PRICING_POLICY_VALUE
  PRICING_POLICY_ADJUSTMENT_VALUE_AND_TYPE_MUST_MATCH
  SELLING_PLAN_DUPLICATE_NAME
  SELLING_PLAN_DUPLICATE_OPTIONS
  SELLING_PLAN_FIXED_PRICING_POLICIES_LIMIT
  REMAINING_BALANCE_CHARGE_EXACT_TIME_REQUIRED
  CHECKOUT_CHARGE_VALUE_AND_TYPE_MUST_MATCH
  ONLY_NEED_ONE_CHECKOUT_CHARGE_VALUE
  REMAINING_BALANCE_CHARGE_EXACT_TIME_NOT_ALLOWED
  REMAINING_BALANCE_CHARGE_TIME_AFTER_CHECKOUT_MUST_BE_GREATER_THAN_ZERO
  REMAINING_BALANCE_CHARGE_TRIGGER_ON_FULL_CHECKOUT
  REMAINING_BALANCE_CHARGE_TRIGGER_NO_REMAINING_BALANCE_ON_PARTIAL_PERCENTAGE_CHECKOUT_CHARGE
  REMAINING_BALANCE_CHARGE_TRIGGER_NO_REMAINING_BALANCE_ON_PRICE_CHECKOUT_CHARGE
  FULFILLMENT_EXACT_TIME_REQUIRED
  FULFILLMENT_EXACT_TIME_NOT_ALLOWED
  SELLING_PLAN_ANCHORS_NOT_ALLOWED
  SELLING_PLAN_ANCHORS_REQUIRED
  ONLY_ONE_OF_FIXED_OR_RECURRING_BILLING
  ONLY_ONE_OF_FIXED_OR_RECURRING_DELIVERY
  BILLING_POLICY_INTERVAL_TOO_LARGE
  DELIVERY_POLICY_INTERVAL_TOO_LARGE
  INVALID_INPUT
}
input SellingPlanInput {
  id: ID
  name: String
  description: String
  billingPolicy: SellingPlanBillingPolicyInput
  deliveryPolicy: SellingPlanDeliveryPolicyInput
  inventoryPolicy: SellingPlanInventoryPolicyInput
  metafields: [MetafieldInput!]
  pricingPolicies: [SellingPlanPricingPolicyInput!]
  options: [String!]
  position: Int
  category: SellingPlanCategory
}
enum SellingPlanInterval {
  DAY
  WEEK
  MONTH
  YEAR
}
type SellingPlanInventoryPolicy {
  reserve: SellingPlanReserve!
}
input SellingPlanInventoryPolicyInput {
  reserve: SellingPlanReserve
}
union SellingPlanPricingPolicy = SellingPlanFixedPricingPolicy | SellingPlanRecurringPricingPolicy
enum SellingPlanPricingPolicyAdjustmentType {
  PERCENTAGE
  FIXED_AMOUNT
  PRICE
}
union SellingPlanPricingPolicyAdjustmentValue = MoneyV2 | SellingPlanPricingPolicyPercentageValue
interface SellingPlanPricingPolicyBase {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType!
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
}
input SellingPlanPricingPolicyInput {
  recurring: SellingPlanRecurringPricingPolicyInput
  fixed: SellingPlanFixedPricingPolicyInput
}
type SellingPlanPricingPolicyPercentageValue {
  percentage: Float!
}
input SellingPlanPricingPolicyValueInput {
  percentage: Float
  fixedValue: Decimal
}
type SellingPlanRecurringBillingPolicy {
  anchors: [SellingPlanAnchor!]!
  createdAt: DateTime!
  interval: SellingPlanInterval!
  intervalCount: Int!
  maxCycles: Int
  minCycles: Int
}
input SellingPlanRecurringBillingPolicyInput {
  interval: SellingPlanInterval
  intervalCount: Int
  anchors: [SellingPlanAnchorInput!]
  minCycles: Int
  maxCycles: Int
}
type SellingPlanRecurringDeliveryPolicy {
  anchors: [SellingPlanAnchor!]!
  createdAt: DateTime!
  cutoff: Int
  intent: SellingPlanRecurringDeliveryPolicyIntent!
  interval: SellingPlanInterval!
  intervalCount: Int!
  preAnchorBehavior: SellingPlanRecurringDeliveryPolicyPreAnchorBehavior!
}
input SellingPlanRecurringDeliveryPolicyInput {
  interval: SellingPlanInterval
  intervalCount: Int
  anchors: [SellingPlanAnchorInput!]
  cutoff: Int
  intent: SellingPlanRecurringDeliveryPolicyIntent
  preAnchorBehavior: SellingPlanRecurringDeliveryPolicyPreAnchorBehavior
}
enum SellingPlanRecurringDeliveryPolicyIntent {
  FULFILLMENT_BEGIN
}
enum SellingPlanRecurringDeliveryPolicyPreAnchorBehavior {
  ASAP
  NEXT
}
type SellingPlanRecurringPricingPolicy {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType!
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
  afterCycle: Int
  createdAt: DateTime!
}
input SellingPlanRecurringPricingPolicyInput {
  id: ID
  adjustmentType: SellingPlanPricingPolicyAdjustmentType
  adjustmentValue: SellingPlanPricingPolicyValueInput
  afterCycle: Int!
}
enum SellingPlanRemainingBalanceChargeTrigger {
  NO_REMAINING_BALANCE
  EXACT_TIME
  TIME_AFTER_CHECKOUT
}
enum SellingPlanReserve {
  ON_FULFILLMENT
  ON_SALE
}
type ServerPixel {
  id: ID!
  status: ServerPixelStatus
  webhookEndpointAddress: String
}
type ServerPixelCreatePayload {
  serverPixel: ServerPixel
  userErrors: [ErrorsServerPixelUserError!]!
}
type ServerPixelDeletePayload {
  deletedServerPixelId: ID
  userErrors: [ErrorsServerPixelUserError!]!
}
enum ServerPixelStatus {
  CONNECTED
  DISCONNECTED_UNCONFIGURED
  DISCONNECTED_CONFIGURED
}
enum ShippingDiscountClass {
  SHIPPING
}
type ShippingLine {
  carrierIdentifier: String
  code: String
  currentDiscountedPriceSet: MoneyBag!
  custom: Boolean!
  deliveryCategory: String
  discountAllocations: [DiscountAllocation!]!
  discountedPrice: MoneyV2!
  discountedPriceSet: MoneyBag!
  id: ID
  isRemoved: Boolean!
  originalPrice: MoneyV2!
  originalPriceSet: MoneyBag!
  phone: String
  price: Money!
  requestedFulfillmentService: FulfillmentService
  shippingRateHandle: String
  source: String
  taxLines: [TaxLine!]!
  title: String!
}
type ShippingLineConnection {
  edges: [ShippingLineEdge!]!
  nodes: [ShippingLine!]!
  pageInfo: PageInfo!
}
type ShippingLineEdge {
  cursor: String!
  node: ShippingLine!
}
input ShippingLineInput {
  priceWithCurrency: MoneyInput
  shippingRateHandle: String
  title: String
}
type ShippingLineSale {
  actionType: SaleActionType!
  id: ID!
  lineType: SaleLineType!
  quantity: Int
  shippingLine: ShippingLine
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
type ShippingPackageDeletePayload {
  deletedId: ID
  userErrors: [UserError!]!
}
type ShippingPackageMakeDefaultPayload {
  userErrors: [UserError!]!
}
enum ShippingPackageType {
  BOX
  FLAT_RATE
  ENVELOPE
  SOFT_PACK
}
type ShippingPackageUpdatePayload {
  userErrors: [UserError!]!
}
type ShippingRate {
  handle: String!
  price: MoneyV2!
  title: String!
}
type ShippingRefund {
  amount: Money!
  amountSet: MoneyBag!
  maximumRefundable: Money!
  maximumRefundableSet: MoneyBag!
  tax: Money!
  taxSet: MoneyBag!
}
input ShippingRefundInput {
  amount: Money
  fullRefund: Boolean
}
type Shop {
  accountOwner: StaffMember!
  alerts: [ShopAlert!]!
  allProductCategories: [ProductCategory!]!
  allProductCategoriesList: [TaxonomyCategory!]!
  analyticsToken: String!
  assignedFulfillmentOrders: FulfillmentOrderConnection!
  availableChannelApps: AppConnection!
  billingAddress: ShopAddress!
  channelDefinitionsForInstalledChannels: [AvailableChannelDefinitionsByChannel!]!
  channels: ChannelConnection!
  checkoutApiSupported: Boolean!
  collections: CollectionConnection!
  contactEmail: String!
  countriesInShippingZones: CountriesInShippingZones!
  createdAt: DateTime!
  currencyCode: CurrencyCode!
  currencyFormats: CurrencyFormats!
  currencySettings: CurrencySettingConnection!
  customerAccounts: ShopCustomerAccountsSetting!
  customerAccountsV2: CustomerAccountsV2!
  customerTags: StringConnection!
  customers: CustomerConnection!
  description: String
  domains: [Domain!]!
  draftOrderTags: StringConnection!
  draftOrders: DraftOrderConnection!
  email: String!
  enabledPresentmentCurrencies: [CurrencyCode!]!
  features: ShopFeatures!
  fulfillmentOrders: FulfillmentOrderConnection!
  fulfillmentServices: [FulfillmentService!]!
  ianaTimezone: String!
  id: ID!
  inventoryItems: InventoryItemConnection!
  limitedPendingOrderCount: LimitedPendingOrderCount!
  locations: LocationConnection!
  marketingSmsConsentEnabledAtCheckout: Boolean!
  merchantApprovalSignals: MerchantApprovalSignals
  metafield: Metafield
  metafields: MetafieldConnection!
  myshopifyDomain: String!
  name: String!
  navigationSettings: [NavigationItem!]!
  orderNumberFormatPrefix: String!
  orderNumberFormatSuffix: String!
  orderTags: StringConnection!
  orders: OrderConnection!
  paymentSettings: PaymentSettings!
  plan: ShopPlan!
  primaryDomain: Domain!
  productImages: ImageConnection!
  productTags: StringConnection!
  productTypes: StringConnection!
  productVariants: ProductVariantConnection!
  productVendors: StringConnection!
  products: ProductConnection!
  publicationCount: Int!
  resourceLimits: ShopResourceLimits!
  richTextEditorUrl: URL!
  search: SearchResultConnection!
  searchFilters: SearchFilterOptions!
  setupRequired: Boolean!
  shipsToCountries: [CountryCode!]!
  shopOwnerName: String!
  shopPolicies: [ShopPolicy!]!
  staffMembers: StaffMemberConnection!
  storefrontAccessTokens: StorefrontAccessTokenConnection!
  storefrontUrl: URL!
  taxShipping: Boolean!
  taxesIncluded: Boolean!
  timezoneAbbreviation: String!
  timezoneOffset: String!
  timezoneOffsetMinutes: Int!
  transactionalSmsDisabled: Boolean!
  translations: [Translation!]!
  unitSystem: UnitSystem!
  updatedAt: DateTime!
  url: URL!
  weightUnit: WeightUnit!
}
type ShopAddress {
  address1: String
  address2: String
  city: String
  company: String
  coordinatesValidated: Boolean!
  country: String
  countryCode: String
  countryCodeV2: CountryCode
  firstName: String
  formatted: [String!]!
  formattedArea: String
  id: ID!
  lastName: String
  latitude: Float
  longitude: Float
  name: String
  phone: String
  province: String
  provinceCode: String
  zip: String
}
type ShopAlert {
  action: ShopAlertAction!
  description: String!
}
type ShopAlertAction {
  title: String!
  url: URL!
}
type ShopBillingPreferences {
  currency: CurrencyCode!
}
enum ShopBranding {
  SHOPIFY_GOLD
  SHOPIFY_PLUS
  ROGERS
  SHOPIFY
}
enum ShopCustomerAccountsSetting {
  REQUIRED
  OPTIONAL
  DISABLED
}
type ShopFeatures {
  avalaraAvatax: Boolean!
  branding: ShopBranding!
  bundles: BundlesFeature!
  captcha: Boolean!
  captchaExternalDomains: Boolean!
  cartTransform: CartTransformFeature!
  deliveryProfiles: Boolean!
  dynamicRemarketing: Boolean!
  eligibleForSubscriptionMigration: Boolean!
  eligibleForSubscriptions: Boolean!
  giftCards: Boolean!
  harmonizedSystemCode: Boolean!
  internationalDomains: Boolean!
  internationalPriceOverrides: Boolean!
  internationalPriceRules: Boolean!
  legacySubscriptionGatewayEnabled: Boolean!
  liveView: Boolean!
  onboardingVisual: Boolean!
  paypalExpressSubscriptionGatewayStatus: PaypalExpressSubscriptionsGatewayStatus!
  reports: Boolean!
  sellsSubscriptions: Boolean!
  shopifyPlus: Boolean!
  showMetrics: Boolean!
  storefront: Boolean!
  usingShopifyBalance: Boolean!
}
type ShopLocale {
  locale: String!
  marketWebPresences: [MarketWebPresence!]!
  name: String!
  primary: Boolean!
  published: Boolean!
}
type ShopLocaleDisablePayload {
  locale: String
  userErrors: [UserError!]!
}
type ShopLocaleEnablePayload {
  shopLocale: ShopLocale
  userErrors: [UserError!]!
}
input ShopLocaleInput {
  published: Boolean
  marketWebPresenceIds: [ID!]
}
type ShopLocaleUpdatePayload {
  shopLocale: ShopLocale
  userErrors: [UserError!]!
}
type ShopPayInstallmentsPaymentDetails {
  paymentMethodName: String
}
type ShopPlan {
  displayName: String!
  partnerDevelopment: Boolean!
  shopifyPlus: Boolean!
}
type ShopPolicy {
  body: HTML!
  createdAt: Date!
  id: ID!
  title: String!
  translations: [Translation!]!
  type: ShopPolicyType!
  updatedAt: Date!
  url: URL!
}
enum ShopPolicyErrorCode {
  TOO_BIG
}
input ShopPolicyInput {
  type: ShopPolicyType!
  body: String!
}
enum ShopPolicyType {
  REFUND_POLICY
  SHIPPING_POLICY
  PRIVACY_POLICY
  TERMS_OF_SERVICE
  TERMS_OF_SALE
  LEGAL_NOTICE
  SUBSCRIPTION_POLICY
  CONTACT_INFORMATION
}
type ShopPolicyUpdatePayload {
  shopPolicy: ShopPolicy
  userErrors: [ShopPolicyUserError!]!
}
type ShopPolicyUserError {
  code: ShopPolicyErrorCode
  field: [String!]
  message: String!
}
type ShopResourceFeedbackCreatePayload {
  feedback: AppFeedback
  userErrors: [ShopResourceFeedbackCreateUserError!]!
}
type ShopResourceFeedbackCreateUserError {
  code: ShopResourceFeedbackCreateUserErrorCode
  field: [String!]
  message: String!
}
enum ShopResourceFeedbackCreateUserErrorCode {
  OUTDATED_FEEDBACK
  INVALID
  BLANK
  PRESENT
}
type ShopResourceLimits {
  locationLimit: Int!
  maxProductOptions: Int!
  maxProductVariants: Int!
  redirectLimitReached: Boolean!
}
enum ShopTagSort {
  ALPHABETICAL
  POPULAR
}
type ShopifyFunction {
  apiType: String!
  apiVersion: String!
  app: App!
  appBridge: FunctionsAppBridge!
  appKey: String!
  description: String
  id: String!
  inputQuery: String
  title: String!
  useCreationUi: Boolean!
}
type ShopifyFunctionConnection {
  edges: [ShopifyFunctionEdge!]!
  nodes: [ShopifyFunction!]!
  pageInfo: PageInfo!
}
type ShopifyFunctionEdge {
  cursor: String!
  node: ShopifyFunction!
}
type ShopifyPaymentsAccount {
  accountOpenerName: String
  activated: Boolean!
  balance: [MoneyV2!]!
  balanceTransactions: ShopifyPaymentsBalanceTransactionConnection!
  bankAccounts: ShopifyPaymentsBankAccountConnection!
  chargeStatementDescriptor: String
  chargeStatementDescriptors: ShopifyPaymentsChargeStatementDescriptor
  country: String!
  defaultCurrency: CurrencyCode!
  disputes: ShopifyPaymentsDisputeConnection!
  id: ID!
  onboardable: Boolean!
  payoutSchedule: ShopifyPaymentsPayoutSchedule!
  payoutStatementDescriptor: String
  payouts: ShopifyPaymentsPayoutConnection!
}
type ShopifyPaymentsAdjustmentOrder {
  amount: MoneyV2!
  link: URL!
  name: String!
  orderTransactionId: BigInt!
}
type ShopifyPaymentsAssociatedOrder {
  id: ID!
  name: String!
}
type ShopifyPaymentsBalanceTransaction {
  adjustmentReason: String
  adjustmentsOrders: [ShopifyPaymentsAdjustmentOrder!]!
  amount: MoneyV2!
  associatedOrder: ShopifyPaymentsAssociatedOrder
  associatedPayout: ShopifyPaymentsBalanceTransactionAssociatedPayout!
  fee: MoneyV2!
  id: ID!
  net: MoneyV2!
  sourceId: BigInt
  sourceOrderTransactionId: BigInt
  sourceType: ShopifyPaymentsSourceType
  test: Boolean!
  transactionDate: DateTime!
  type: ShopifyPaymentsTransactionType!
}
type ShopifyPaymentsBalanceTransactionAssociatedPayout {
  id: ID
  status: ShopifyPaymentsBalanceTransactionPayoutStatus
}
type ShopifyPaymentsBalanceTransactionConnection {
  edges: [ShopifyPaymentsBalanceTransactionEdge!]!
  nodes: [ShopifyPaymentsBalanceTransaction!]!
  pageInfo: PageInfo!
}
type ShopifyPaymentsBalanceTransactionEdge {
  cursor: String!
  node: ShopifyPaymentsBalanceTransaction!
}
enum ShopifyPaymentsBalanceTransactionPayoutStatus {
  SCHEDULED
  IN_TRANSIT
  PAID
  FAILED
  CANCELED
  PENDING
  ACTION_REQUIRED
}
type ShopifyPaymentsBankAccount {
  accountNumberLastDigits: String!
  bankName: String
  country: CountryCode!
  createdAt: DateTime!
  currency: CurrencyCode!
  id: ID!
  payouts: ShopifyPaymentsPayoutConnection!
  status: ShopifyPaymentsBankAccountStatus!
}
type ShopifyPaymentsBankAccountConnection {
  edges: [ShopifyPaymentsBankAccountEdge!]!
  nodes: [ShopifyPaymentsBankAccount!]!
  pageInfo: PageInfo!
}
type ShopifyPaymentsBankAccountEdge {
  cursor: String!
  node: ShopifyPaymentsBankAccount!
}
enum ShopifyPaymentsBankAccountStatus {
  NEW
  VALIDATED
  VERIFIED
  ERRORED
}
interface ShopifyPaymentsChargeStatementDescriptor {
  default: String
  prefix: String!
}
type ShopifyPaymentsDefaultChargeStatementDescriptor {
  default: String
  prefix: String!
}
type ShopifyPaymentsDispute {
  amount: MoneyV2!
  evidenceDueBy: Date
  evidenceSentOn: Date
  finalizedOn: Date
  id: ID!
  initiatedAt: DateTime!
  legacyResourceId: UnsignedInt64!
  order: Order
  reasonDetails: ShopifyPaymentsDisputeReasonDetails!
  status: DisputeStatus!
  type: DisputeType!
}
type ShopifyPaymentsDisputeConnection {
  edges: [ShopifyPaymentsDisputeEdge!]!
  nodes: [ShopifyPaymentsDispute!]!
  pageInfo: PageInfo!
}
type ShopifyPaymentsDisputeEdge {
  cursor: String!
  node: ShopifyPaymentsDispute!
}
type ShopifyPaymentsDisputeEvidence {
  accessActivityLog: String
  billingAddress: MailingAddress
  cancellationPolicyDisclosure: String
  cancellationPolicyFile: ShopifyPaymentsDisputeFileUpload
  cancellationRebuttal: String
  customerCommunicationFile: ShopifyPaymentsDisputeFileUpload
  customerEmailAddress: String
  customerFirstName: String
  customerLastName: String
  customerPurchaseIp: String
  dispute: ShopifyPaymentsDispute!
  disputeFileUploads: [ShopifyPaymentsDisputeFileUpload!]!
  fulfillments: [ShopifyPaymentsDisputeFulfillment!]!
  id: ID!
  productDescription: String
  refundPolicyDisclosure: String
  refundPolicyFile: ShopifyPaymentsDisputeFileUpload
  refundRefusalExplanation: String
  serviceDocumentationFile: ShopifyPaymentsDisputeFileUpload
  shippingAddress: MailingAddress
  shippingDocumentationFile: ShopifyPaymentsDisputeFileUpload
  submitted: Boolean!
  uncategorizedFile: ShopifyPaymentsDisputeFileUpload
  uncategorizedText: String
}
enum ShopifyPaymentsDisputeEvidenceFileType {
  CUSTOMER_COMMUNICATION_FILE
  REFUND_POLICY_FILE
  CANCELLATION_POLICY_FILE
  UNCATEGORIZED_FILE
  SHIPPING_DOCUMENTATION_FILE
  SERVICE_DOCUMENTATION_FILE
}
input ShopifyPaymentsDisputeEvidenceUpdateInput {
  customerEmailAddress: String
  customerLastName: String
  customerFirstName: String
  shippingAddress: MailingAddressInput
  uncategorizedText: String
  accessActivityLog: String
  cancellationPolicyDisclosure: String
  cancellationRebuttal: String
  refundPolicyDisclosure: String
  refundRefusalExplanation: String
  cancellationPolicyFile: ShopifyPaymentsDisputeFileUploadUpdateInput
  customerCommunicationFile: ShopifyPaymentsDisputeFileUploadUpdateInput
  refundPolicyFile: ShopifyPaymentsDisputeFileUploadUpdateInput
  shippingDocumentationFile: ShopifyPaymentsDisputeFileUploadUpdateInput
  uncategorizedFile: ShopifyPaymentsDisputeFileUploadUpdateInput
  serviceDocumentationFile: ShopifyPaymentsDisputeFileUploadUpdateInput
  submitEvidence: Boolean
}
type ShopifyPaymentsDisputeFileUpload {
  disputeEvidenceType: ShopifyPaymentsDisputeEvidenceFileType
  fileSize: Int!
  fileType: String!
  id: ID!
  originalFileName: String
  url: URL!
}
input ShopifyPaymentsDisputeFileUploadUpdateInput {
  id: ID!
  destroy: Boolean
}
type ShopifyPaymentsDisputeFulfillment {
  id: ID!
  shippingCarrier: String
  shippingDate: Date
  shippingTrackingNumber: String
}
enum ShopifyPaymentsDisputeReason {
  FRAUDULENT
  GENERAL
  UNRECOGNIZED
  DUPLICATE
  SUBSCRIPTION_CANCELLED
  PRODUCT_UNACCEPTABLE
  PRODUCT_NOT_RECEIVED
  CREDIT_NOT_PROCESSED
  INCORRECT_ACCOUNT_DETAILS
  INSUFFICIENT_FUNDS
  BANK_CANNOT_PROCESS
  DEBIT_NOT_AUTHORIZED
  CUSTOMER_INITIATED
}
type ShopifyPaymentsDisputeReasonDetails {
  networkReasonCode: String
  reason: ShopifyPaymentsDisputeReason!
}
type ShopifyPaymentsExtendedAuthorization {
  extendedAuthorizationExpiresAt: DateTime!
  standardAuthorizationExpiresAt: DateTime!
}
type ShopifyPaymentsJpChargeStatementDescriptor {
  default: String
  kana: String
  kanji: String
  prefix: String!
}
type ShopifyPaymentsPayout {
  bankAccount: ShopifyPaymentsBankAccount
  businessEntity: BusinessEntity!
  gross: MoneyV2!
  id: ID!
  issuedAt: DateTime!
  legacyResourceId: UnsignedInt64!
  net: MoneyV2!
  status: ShopifyPaymentsPayoutStatus!
  summary: ShopifyPaymentsPayoutSummary!
  transactionType: ShopifyPaymentsPayoutTransactionType!
}
type ShopifyPaymentsPayoutAlternateCurrencyCreatePayload {
  payout: ShopifyPaymentsToolingProviderPayout
  success: Boolean
  userErrors: [ShopifyPaymentsPayoutAlternateCurrencyCreateUserError!]!
}
type ShopifyPaymentsPayoutAlternateCurrencyCreateUserError {
  code: ShopifyPaymentsPayoutAlternateCurrencyCreateUserErrorCode
  field: [String!]
  message: String!
}
enum ShopifyPaymentsPayoutAlternateCurrencyCreateUserErrorCode {
  MISSING_PROVIDER_ACCOUNT
  ALTERNATE_CURRENCY_PAYOUT_FAILED_STRIPE_ERROR
  UNKNOWN_CORE_ERROR
  ALTERNATE_CURRENCY_PAYOUT_FAILED_NO_ELIGIBLE_BALANCE
}
type ShopifyPaymentsPayoutConnection {
  edges: [ShopifyPaymentsPayoutEdge!]!
  nodes: [ShopifyPaymentsPayout!]!
  pageInfo: PageInfo!
}
type ShopifyPaymentsPayoutEdge {
  cursor: String!
  node: ShopifyPaymentsPayout!
}
enum ShopifyPaymentsPayoutInterval {
  DAILY
  WEEKLY
  MONTHLY
  MANUAL
}
type ShopifyPaymentsPayoutSchedule {
  interval: ShopifyPaymentsPayoutInterval!
  monthlyAnchor: Int
  weeklyAnchor: DayOfTheWeek
}
enum ShopifyPaymentsPayoutStatus {
  SCHEDULED
  IN_TRANSIT
  PAID
  FAILED
  CANCELED
}
type ShopifyPaymentsPayoutSummary {
  adjustmentsFee: MoneyV2!
  adjustmentsGross: MoneyV2!
  advanceFees: MoneyV2!
  advanceGross: MoneyV2!
  chargesFee: MoneyV2!
  chargesGross: MoneyV2!
  refundsFee: MoneyV2!
  refundsFeeGross: MoneyV2!
  reservedFundsFee: MoneyV2!
  reservedFundsGross: MoneyV2!
  retriedPayoutsFee: MoneyV2!
  retriedPayoutsGross: MoneyV2!
}
enum ShopifyPaymentsPayoutTransactionType {
  DEPOSIT
  WITHDRAWAL
}
type ShopifyPaymentsRefundSet {
  acquirerReferenceNumber: String
}
enum ShopifyPaymentsSourceType {
  ADJUSTMENT_REVERSAL
  CHARGE
  REFUND
  SYSTEM_ADJUSTMENT
  DISPUTE
  ADJUSTMENT
  TRANSFER
}
type ShopifyPaymentsToolingProviderPayout {
  amount: MoneyV2!
  arrivalDate: DateTime
  createdAt: DateTime
  currency: String!
  remoteId: String!
}
type ShopifyPaymentsTransactionSet {
  extendedAuthorizationSet: ShopifyPaymentsExtendedAuthorization
  refundSet: ShopifyPaymentsRefundSet
}
enum ShopifyPaymentsTransactionType {
  CHARGEBACK_PROTECTION_CREDIT
  CHARGEBACK_PROTECTION_CREDIT_REVERSAL
  CHARGEBACK_PROTECTION_DEBIT
  CHARGEBACK_PROTECTION_DEBIT_REVERSAL
  COLLECTIONS_CREDIT
  COLLECTIONS_CREDIT_REVERSAL
  PROMOTION_CREDIT
  PROMOTION_CREDIT_REVERSAL
  ANOMALY_CREDIT
  ANOMALY_CREDIT_REVERSAL
  ANOMALY_DEBIT
  ANOMALY_DEBIT_REVERSAL
  VAT_REFUND_CREDIT
  VAT_REFUND_CREDIT_REVERSAL
  CHANNEL_CREDIT
  CHANNEL_CREDIT_REVERSAL
  CHANNEL_TRANSFER_CREDIT
  CHANNEL_TRANSFER_CREDIT_REVERSAL
  CHANNEL_TRANSFER_DEBIT
  CHANNEL_TRANSFER_DEBIT_REVERSAL
  CHANNEL_PROMOTION_CREDIT
  CHANNEL_PROMOTION_CREDIT_REVERSAL
  MARKETPLACE_FEE_CREDIT
  MARKETPLACE_FEE_CREDIT_REVERSAL
  MERCHANT_GOODWILL_CREDIT
  MERCHANT_GOODWILL_CREDIT_REVERSAL
  TAX_ADJUSTMENT_DEBIT
  TAX_ADJUSTMENT_DEBIT_REVERSAL
  TAX_ADJUSTMENT_CREDIT
  TAX_ADJUSTMENT_CREDIT_REVERSAL
  BILLING_DEBIT
  BILLING_DEBIT_REVERSAL
  SHOP_CASH_CREDIT
  SHOP_CASH_CREDIT_REVERSAL
  SHOP_CASH_BILLING_DEBIT
  SHOP_CASH_BILLING_DEBIT_REVERSAL
  SHOP_CASH_REFUND_DEBIT
  SHOP_CASH_REFUND_DEBIT_REVERSAL
  SHOP_CASH_CAMPAIGN_BILLING_DEBIT
  SHOP_CASH_CAMPAIGN_BILLING_DEBIT_REVERSAL
  SHOP_CASH_CAMPAIGN_BILLING_CREDIT
  SHOP_CASH_CAMPAIGN_BILLING_CREDIT_REVERSAL
  SELLER_PROTECTION_CREDIT
  SELLER_PROTECTION_CREDIT_REVERSAL
  SHOPIFY_COLLECTIVE_DEBIT
  SHOPIFY_COLLECTIVE_DEBIT_REVERSAL
  SHOPIFY_COLLECTIVE_CREDIT
  SHOPIFY_COLLECTIVE_CREDIT_REVERSAL
  BALANCE_TRANSFER_INBOUND
  MARKETS_PRO_CREDIT
  CUSTOMS_DUTY_ADJUSTMENT
  IMPORT_TAX_ADJUSTMENT
  SHIPPING_LABEL_ADJUSTMENT
  SHIPPING_LABEL_ADJUSTMENT_BASE
  SHIPPING_LABEL_ADJUSTMENT_SURCHARGE
  SHIPPING_RETURN_TO_ORIGIN_ADJUSTMENT
  SHIPPING_OTHER_CARRIER_CHARGE_ADJUSTMENT
  CHARGE_ADJUSTMENT
  REFUND_ADJUSTMENT
  CHARGEBACK_FEE
  CHARGEBACK_FEE_REFUND
  TRANSFER
  TRANSFER_FAILURE
  TRANSFER_CANCEL
  RESERVED_FUNDS_WITHDRAWAL
  RESERVED_FUNDS_REVERSAL
  RISK_REVERSAL
  RISK_WITHDRAWAL
  MERCHANT_TO_MERCHANT_DEBIT
  MERCHANT_TO_MERCHANT_DEBIT_REVERSAL
  MERCHANT_TO_MERCHANT_CREDIT
  MERCHANT_TO_MERCHANT_CREDIT_REVERSAL
  SHOPIFY_SOURCE_DEBIT
  SHOPIFY_SOURCE_DEBIT_REVERSAL
  SHOPIFY_SOURCE_CREDIT
  SHOPIFY_SOURCE_CREDIT_REVERSAL
  CHARGE
  REFUND
  REFUND_FAILURE
  APPLICATION_FEE_REFUND
  ADJUSTMENT
  DISPUTE_WITHDRAWAL
  DISPUTE_REVERSAL
  SHIPPING_LABEL
  CUSTOMS_DUTY
  IMPORT_TAX
  CHARGEBACK_HOLD
  CHARGEBACK_HOLD_RELEASE
  RESERVED_FUNDS
  STRIPE_FEE
  TRANSFER_REFUND
  ADVANCE
  ADVANCE_FUNDING
}
type ShopifyPaymentsVerification {
  id: ID!
  status: ShopifyPaymentsVerificationStatus!
  subject: ShopifyPaymentsVerificationSubject!
}
enum ShopifyPaymentsVerificationStatus {
  VERIFIED
  UNVERIFIED
  PENDING
}
type ShopifyPaymentsVerificationSubject {
  familyName: String!
  givenName: String!
}
enum ShopifyProtectEligibilityStatus {
  PENDING
  ELIGIBLE
  NOT_ELIGIBLE
}
type ShopifyProtectOrderEligibility {
  status: ShopifyProtectEligibilityStatus!
}
type ShopifyProtectOrderSummary {
  eligibility: ShopifyProtectOrderEligibility!
  status: ShopifyProtectStatus!
}
enum ShopifyProtectStatus {
  PENDING
  ACTIVE
  INACTIVE
  PROTECTED
  NOT_PROTECTED
}
type StaffMember {
  accountType: AccountType
  active: Boolean!
  avatar: Image!
  email: String!
  exists: Boolean!
  firstName: String
  id: ID!
  initials: [String!]
  isShopOwner: Boolean!
  lastName: String
  locale: String!
  name: String!
  phone: String
  privateData: StaffMemberPrivateData!
}
type StaffMemberConnection {
  edges: [StaffMemberEdge!]!
  nodes: [StaffMember!]!
  pageInfo: PageInfo!
}
enum StaffMemberDefaultImage {
  DEFAULT
  TRANSPARENT
  NOT_FOUND
}
type StaffMemberEdge {
  cursor: String!
  node: StaffMember!
}
enum StaffMemberPermission {
  APPLICATIONS
  CHANNELS
  CREATE_AND_EDIT_CUSTOMERS
  CREATE_AND_EDIT_GIFT_CARDS
  CUSTOMERS
  DASHBOARD
  DEACTIVATE_GIFT_CARDS
  DELETE_CUSTOMERS
  DOMAINS
  DRAFT_ORDERS
  EDIT_ORDERS
  ERASE_CUSTOMER_DATA
  EXPORT_CUSTOMERS
  EXPORT_GIFT_CARDS
  FULL
  GIFT_CARDS
  LINKS
  LOCATIONS
  MARKETING
  MARKETING_SECTION
  MERGE_CUSTOMERS
  ORDERS
  OVERVIEWS
  PAGES
  PAY_ORDERS_BY_VAULTED_CARD
  PREFERENCES
  PRODUCTS
  REPORTS
  REQUEST_CUSTOMER_DATA
  THEMES
  TRANSLATIONS
}
type StaffMemberPrivateData {
  accountSettingsUrl: URL!
  createdAt: DateTime!
  permissions: [StaffMemberPermission!]!
}
enum StaffMembersSortKeys {
  EMAIL
  FIRST_NAME
  ID
  LAST_NAME
}
input StageImageInput {
  resource: StagedUploadTargetGenerateUploadResource!
  filename: String!
  mimeType: String!
  httpMethod: StagedUploadHttpMethodType
}
type StagedMediaUploadTarget {
  parameters: [StagedUploadParameter!]!
  resourceUrl: URL
  url: URL
}
enum StagedUploadHttpMethodType {
  POST
  PUT
}
input StagedUploadInput {
  resource: StagedUploadTargetGenerateUploadResource!
  filename: String!
  mimeType: String!
  httpMethod: StagedUploadHttpMethodType
  fileSize: UnsignedInt64
}
type StagedUploadParameter {
  name: String!
  value: String!
}
type StagedUploadTarget {
  parameters: [ImageUploadParameter!]!
  url: String!
}
input StagedUploadTargetGenerateInput {
  resource: StagedUploadTargetGenerateUploadResource!
  filename: String!
  mimeType: String!
  httpMethod: StagedUploadHttpMethodType
  fileSize: UnsignedInt64
}
type StagedUploadTargetGeneratePayload {
  parameters: [MutationsStagedUploadTargetGenerateUploadParameter!]!
  url: String!
  userErrors: [UserError!]!
}
enum StagedUploadTargetGenerateUploadResource {
  COLLECTION_IMAGE
  FILE
  IMAGE
  MODEL_3D
  PRODUCT_IMAGE
  SHOP_IMAGE
  VIDEO
  BULK_MUTATION_VARIABLES
  RETURN_LABEL
  URL_REDIRECT_IMPORT
}
type StagedUploadTargetsGeneratePayload {
  urls: [StagedUploadTarget!]
  userErrors: [UserError!]!
}
type StagedUploadsCreatePayload {
  stagedTargets: [StagedMediaUploadTarget!]
  userErrors: [UserError!]!
}
input StandardMetafieldDefinitionAccessInput {
  admin: MetafieldAdminAccessInput
  storefront: MetafieldStorefrontAccessInput
  customerAccount: MetafieldCustomerAccountAccessInput
}
type StandardMetafieldDefinitionEnablePayload {
  createdDefinition: MetafieldDefinition
  userErrors: [StandardMetafieldDefinitionEnableUserError!]!
}
type StandardMetafieldDefinitionEnableUserError {
  code: StandardMetafieldDefinitionEnableUserErrorCode
  field: [String!]
  message: String!
}
enum StandardMetafieldDefinitionEnableUserErrorCode {
  INVALID
  TAKEN
  TEMPLATE_NOT_FOUND
  LIMIT_EXCEEDED
  UNSTRUCTURED_ALREADY_EXISTS
  TYPE_NOT_ALLOWED_FOR_CONDITIONS
  INVALID_CAPABILITY
  UNSUPPORTED_PINNING
  ADMIN_ACCESS_INPUT_NOT_ALLOWED
  INVALID_INPUT_COMBINATION
}
type StandardMetafieldDefinitionTemplate {
  description: String
  id: ID!
  key: String!
  name: String!
  namespace: String!
  ownerTypes: [MetafieldOwnerType!]!
  type: MetafieldDefinitionType!
  validations: [MetafieldDefinitionValidation!]!
  visibleToStorefrontApi: Boolean!
}
type StandardMetafieldDefinitionTemplateConnection {
  edges: [StandardMetafieldDefinitionTemplateEdge!]!
  nodes: [StandardMetafieldDefinitionTemplate!]!
  pageInfo: PageInfo!
}
type StandardMetafieldDefinitionTemplateEdge {
  cursor: String!
  node: StandardMetafieldDefinitionTemplate!
}
type StandardMetaobjectDefinitionEnablePayload {
  metaobjectDefinition: MetaobjectDefinition
  userErrors: [MetaobjectUserError!]!
}
type StandardizedProductType {
  productTaxonomyNode: ProductTaxonomyNode
}
type StoreCreditAccount {
  balance: MoneyV2!
  id: ID!
  owner: HasStoreCreditAccounts!
  transactions: StoreCreditAccountTransactionConnection!
}
type StoreCreditAccountConnection {
  edges: [StoreCreditAccountEdge!]!
  nodes: [StoreCreditAccount!]!
  pageInfo: PageInfo!
}
input StoreCreditAccountCreditInput {
  creditAmount: MoneyInput!
  expiresAt: DateTime
}
type StoreCreditAccountCreditPayload {
  storeCreditAccountTransaction: StoreCreditAccountCreditTransaction
  userErrors: [StoreCreditAccountCreditUserError!]!
}
type StoreCreditAccountCreditTransaction {
  account: StoreCreditAccount!
  amount: MoneyV2!
  balanceAfterTransaction: MoneyV2!
  createdAt: DateTime!
  event: StoreCreditSystemEvent!
  expiresAt: DateTime
  id: ID!
  origin: StoreCreditAccountTransactionOrigin
  remainingAmount: MoneyV2!
}
type StoreCreditAccountCreditUserError {
  code: StoreCreditAccountCreditUserErrorCode
  field: [String!]
  message: String!
}
enum StoreCreditAccountCreditUserErrorCode {
  ACCOUNT_NOT_FOUND
  OWNER_NOT_FOUND
  NEGATIVE_OR_ZERO_AMOUNT
  MISMATCHING_CURRENCY
  EXPIRES_AT_IN_PAST
  CREDIT_LIMIT_EXCEEDED
  UNSUPPORTED_CURRENCY
}
input StoreCreditAccountDebitInput {
  debitAmount: MoneyInput!
}
type StoreCreditAccountDebitPayload {
  storeCreditAccountTransaction: StoreCreditAccountDebitTransaction
  userErrors: [StoreCreditAccountDebitUserError!]!
}
type StoreCreditAccountDebitRevertTransaction {
  account: StoreCreditAccount!
  amount: MoneyV2!
  balanceAfterTransaction: MoneyV2!
  createdAt: DateTime!
  debitTransaction: StoreCreditAccountDebitTransaction!
  event: StoreCreditSystemEvent!
  id: ID!
  origin: StoreCreditAccountTransactionOrigin
}
type StoreCreditAccountDebitTransaction {
  account: StoreCreditAccount!
  amount: MoneyV2!
  balanceAfterTransaction: MoneyV2!
  createdAt: DateTime!
  event: StoreCreditSystemEvent!
  id: ID!
  origin: StoreCreditAccountTransactionOrigin
}
type StoreCreditAccountDebitUserError {
  code: StoreCreditAccountDebitUserErrorCode
  field: [String!]
  message: String!
}
enum StoreCreditAccountDebitUserErrorCode {
  ACCOUNT_NOT_FOUND
  NEGATIVE_OR_ZERO_AMOUNT
  INSUFFICIENT_FUNDS
  MISMATCHING_CURRENCY
}
type StoreCreditAccountEdge {
  cursor: String!
  node: StoreCreditAccount!
}
type StoreCreditAccountExpirationTransaction {
  account: StoreCreditAccount!
  amount: MoneyV2!
  balanceAfterTransaction: MoneyV2!
  createdAt: DateTime!
  creditTransaction: StoreCreditAccountCreditTransaction!
  event: StoreCreditSystemEvent!
  origin: StoreCreditAccountTransactionOrigin
}
interface StoreCreditAccountTransaction {
  account: StoreCreditAccount!
  amount: MoneyV2!
  balanceAfterTransaction: MoneyV2!
  createdAt: DateTime!
  event: StoreCreditSystemEvent!
  origin: StoreCreditAccountTransactionOrigin
}
type StoreCreditAccountTransactionConnection {
  edges: [StoreCreditAccountTransactionEdge!]!
  nodes: [StoreCreditAccountTransaction!]!
  pageInfo: PageInfo!
}
type StoreCreditAccountTransactionEdge {
  cursor: String!
  node: StoreCreditAccountTransaction!
}
union StoreCreditAccountTransactionOrigin = OrderTransaction
enum StoreCreditSystemEvent {
  ADJUSTMENT
  ORDER_PAYMENT
  ORDER_REFUND
  PAYMENT_FAILURE
  PAYMENT_RETURNED
  ORDER_CANCELLATION
  TAX_FINALIZATION
}
type StorefrontAccessToken {
  accessScopes: [AccessScope!]!
  accessToken: String!
  createdAt: DateTime!
  id: ID!
  title: String!
  updatedAt: DateTime!
}
type StorefrontAccessTokenConnection {
  edges: [StorefrontAccessTokenEdge!]!
  nodes: [StorefrontAccessToken!]!
  pageInfo: PageInfo!
}
type StorefrontAccessTokenCreatePayload {
  shop: Shop!
  storefrontAccessToken: StorefrontAccessToken
  userErrors: [UserError!]!
}
input StorefrontAccessTokenDeleteInput {
  id: ID!
}
type StorefrontAccessTokenDeletePayload {
  deletedStorefrontAccessTokenId: ID
  userErrors: [UserError!]!
}
type StorefrontAccessTokenEdge {
  cursor: String!
  node: StorefrontAccessToken!
}
input StorefrontAccessTokenInput {
  title: String!
}
scalar StorefrontID
scalar String
type StringConnection {
  edges: [StringEdge!]!
  nodes: [String!]!
  pageInfo: PageInfo!
}
type StringEdge {
  cursor: String!
  node: String!
}
type SubscriptionAppliedCodeDiscount {
  id: ID!
  redeemCode: String!
  rejectionReason: SubscriptionDiscountRejectionReason
}
input SubscriptionAtomicLineInput {
  line: SubscriptionLineInput!
  discounts: [SubscriptionAtomicManualDiscountInput!]
}
input SubscriptionAtomicManualDiscountInput {
  title: String
  value: SubscriptionManualDiscountValueInput
  recurringCycleLimit: Int
}
type SubscriptionBillingAttempt {
  completedAt: DateTime
  createdAt: DateTime!
  errorCode: SubscriptionBillingAttemptErrorCode
  errorMessage: String
  id: ID!
  idempotencyKey: String!
  nextActionUrl: URL
  order: Order
  originTime: DateTime
  paymentGroupId: String
  paymentSessionId: String
  processingError: SubscriptionBillingAttemptProcessingError
  ready: Boolean!
  respectInventoryPolicy: Boolean!
  subscriptionContract: SubscriptionContract!
  transactions: OrderTransactionConnection!
}
type SubscriptionBillingAttemptConnection {
  edges: [SubscriptionBillingAttemptEdge!]!
  nodes: [SubscriptionBillingAttempt!]!
  pageInfo: PageInfo!
}
type SubscriptionBillingAttemptCreatePayload {
  subscriptionBillingAttempt: SubscriptionBillingAttempt
  userErrors: [BillingAttemptUserError!]!
}
type SubscriptionBillingAttemptEdge {
  cursor: String!
  node: SubscriptionBillingAttempt!
}
enum SubscriptionBillingAttemptErrorCode {
  PAYMENT_METHOD_NOT_FOUND
  PAYMENT_PROVIDER_IS_NOT_ENABLED
  INVALID_PAYMENT_METHOD
  UNEXPECTED_ERROR
  EXPIRED_PAYMENT_METHOD
  PAYMENT_METHOD_DECLINED
  AUTHENTICATION_ERROR
  TEST_MODE
  BUYER_CANCELED_PAYMENT_METHOD
  CUSTOMER_NOT_FOUND
  CUSTOMER_INVALID
  INVALID_SHIPPING_ADDRESS
  INVALID_CUSTOMER_BILLING_AGREEMENT
  INVOICE_ALREADY_PAID
  PAYMENT_METHOD_INCOMPATIBLE_WITH_GATEWAY_CONFIG
  AMOUNT_TOO_SMALL
  INVENTORY_ALLOCATIONS_NOT_FOUND
  INSUFFICIENT_INVENTORY
  TRANSIENT_ERROR
  INSUFFICIENT_FUNDS
  PURCHASE_TYPE_NOT_SUPPORTED
  PAYPAL_ERROR_GENERAL
  CARD_NUMBER_INCORRECT
  FRAUD_SUSPECTED
}
type SubscriptionBillingAttemptGenericError {
  code: SubscriptionBillingAttemptErrorCode!
  message: String!
}
input SubscriptionBillingAttemptInput {
  idempotencyKey: String!
  originTime: DateTime
  billingCycleSelector: SubscriptionBillingCycleSelector
  inventoryPolicy: SubscriptionBillingAttemptInventoryPolicy
}
type SubscriptionBillingAttemptInsufficientStockProductVariantsError {
  code: SubscriptionBillingAttemptErrorCode!
  insufficientStockProductVariants: ProductVariantConnection!
  message: String!
}
enum SubscriptionBillingAttemptInventoryPolicy {
  PRODUCT_VARIANT_INVENTORY_POLICY
  ALLOW_OVERSELLING
}
type SubscriptionBillingAttemptOutOfStockProductVariantsError {
  code: SubscriptionBillingAttemptErrorCode!
  message: String!
  outOfStockProductVariants: ProductVariantConnection!
}
interface SubscriptionBillingAttemptProcessingError {
  code: SubscriptionBillingAttemptErrorCode!
  message: String!
}
enum SubscriptionBillingAttemptsSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
type SubscriptionBillingCycle {
  billingAttemptExpectedDate: DateTime!
  billingAttempts: SubscriptionBillingAttemptConnection!
  cycleEndAt: DateTime!
  cycleIndex: Int!
  cycleStartAt: DateTime!
  edited: Boolean!
  editedContract: SubscriptionBillingCycleEditedContract
  skipped: Boolean!
  sourceContract: SubscriptionContract!
  status: SubscriptionBillingCycleBillingCycleStatus!
}
enum SubscriptionBillingCycleBillingAttemptStatus {
  HAS_ATTEMPT
  NO_ATTEMPT
  ANY
}
enum SubscriptionBillingCycleBillingCycleStatus {
  BILLED
  UNBILLED
}
type SubscriptionBillingCycleBulkChargePayload {
  job: Job
  userErrors: [SubscriptionBillingCycleBulkUserError!]!
}
input SubscriptionBillingCycleBulkFilters {
  billingCycleStatus: [SubscriptionBillingCycleBillingCycleStatus!]
  contractStatus: [SubscriptionContractSubscriptionStatus!]
  billingAttemptStatus: SubscriptionBillingCycleBillingAttemptStatus
}
type SubscriptionBillingCycleBulkSearchPayload {
  job: Job
  userErrors: [SubscriptionBillingCycleBulkUserError!]!
}
type SubscriptionBillingCycleBulkUserError {
  code: SubscriptionBillingCycleBulkUserErrorCode
  field: [String!]
  message: String!
}
enum SubscriptionBillingCycleBulkUserErrorCode {
  INVALID
  BLANK
  END_DATE_IN_THE_FUTURE
  INVALID_DATE_RANGE
  START_DATE_BEFORE_END_DATE
}
type SubscriptionBillingCycleChargePayload {
  subscriptionBillingAttempt: SubscriptionBillingAttempt
  userErrors: [BillingAttemptUserError!]!
}
type SubscriptionBillingCycleConnection {
  edges: [SubscriptionBillingCycleEdge!]!
  nodes: [SubscriptionBillingCycle!]!
  pageInfo: PageInfo!
}
type SubscriptionBillingCycleContractDraftCommitPayload {
  contract: SubscriptionBillingCycleEditedContract
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionBillingCycleContractDraftConcatenatePayload {
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionBillingCycleContractEditPayload {
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionBillingCycleEdge {
  cursor: String!
  node: SubscriptionBillingCycle!
}
type SubscriptionBillingCycleEditDeletePayload {
  billingCycles: [SubscriptionBillingCycle!]
  userErrors: [SubscriptionBillingCycleUserError!]!
}
type SubscriptionBillingCycleEditedContract {
  app: App
  appAdminUrl: URL
  billingCycles: SubscriptionBillingCycleConnection!
  createdAt: DateTime!
  currencyCode: CurrencyCode!
  customAttributes: [Attribute!]!
  customer: Customer
  customerPaymentMethod: CustomerPaymentMethod
  deliveryMethod: SubscriptionDeliveryMethod
  deliveryPrice: MoneyV2!
  discounts: SubscriptionManualDiscountConnection!
  lineCount: Int!
  lines: SubscriptionLineConnection!
  linesCount: Count
  note: String
  orders: OrderConnection!
  updatedAt: DateTime!
}
type SubscriptionBillingCycleEditsDeletePayload {
  billingCycles: [SubscriptionBillingCycle!]
  userErrors: [SubscriptionBillingCycleUserError!]!
}
enum SubscriptionBillingCycleErrorCode {
  INVALID
  CYCLE_NOT_FOUND
  NO_CYCLE_EDITS
  INVALID_CYCLE_INDEX
  INVALID_DATE
  EMPTY_BILLING_CYCLE_EDIT_SCHEDULE_INPUT
  BILLING_DATE_SET_ON_SKIPPED
  OUT_OF_BOUNDS
  UPCOMING_CYCLE_LIMIT_EXCEEDED
  CYCLE_INDEX_OUT_OF_RANGE
  CYCLE_START_DATE_OUT_OF_RANGE
  INCOMPLETE_BILLING_ATTEMPTS
}
input SubscriptionBillingCycleInput {
  contractId: ID!
  selector: SubscriptionBillingCycleSelector!
}
input SubscriptionBillingCycleScheduleEditInput {
  skip: Boolean
  billingDate: DateTime
  reason: SubscriptionBillingCycleScheduleEditInputScheduleEditReason!
}
enum SubscriptionBillingCycleScheduleEditInputScheduleEditReason {
  BUYER_INITIATED
  MERCHANT_INITIATED
  DEV_INITIATED
}
type SubscriptionBillingCycleScheduleEditPayload {
  billingCycle: SubscriptionBillingCycle
  userErrors: [SubscriptionBillingCycleUserError!]!
}
input SubscriptionBillingCycleSelector {
  index: Int
  date: DateTime
}
type SubscriptionBillingCycleSkipPayload {
  billingCycle: SubscriptionBillingCycle
  userErrors: [SubscriptionBillingCycleSkipUserError!]!
}
type SubscriptionBillingCycleSkipUserError {
  code: SubscriptionBillingCycleSkipUserErrorCode
  field: [String!]
  message: String!
}
enum SubscriptionBillingCycleSkipUserErrorCode {
  INVALID
}
type SubscriptionBillingCycleUnskipPayload {
  billingCycle: SubscriptionBillingCycle
  userErrors: [SubscriptionBillingCycleUnskipUserError!]!
}
type SubscriptionBillingCycleUnskipUserError {
  code: SubscriptionBillingCycleUnskipUserErrorCode
  field: [String!]
  message: String!
}
enum SubscriptionBillingCycleUnskipUserErrorCode {
  INVALID
}
type SubscriptionBillingCycleUserError {
  code: SubscriptionBillingCycleErrorCode
  field: [String!]
  message: String!
}
input SubscriptionBillingCyclesDateRangeSelector {
  startDate: DateTime!
  endDate: DateTime!
}
input SubscriptionBillingCyclesIndexRangeSelector {
  startIndex: Int!
  endIndex: Int!
}
enum SubscriptionBillingCyclesSortKeys {
  CYCLE_INDEX
  ID
  RELEVANCE
}
enum SubscriptionBillingCyclesTargetSelection {
  ALL
}
type SubscriptionBillingPolicy {
  anchors: [SellingPlanAnchor!]!
  interval: SellingPlanInterval!
  intervalCount: Int!
  maxCycles: Int
  minCycles: Int
}
input SubscriptionBillingPolicyInput {
  interval: SellingPlanInterval!
  intervalCount: Int!
  minCycles: Int
  maxCycles: Int
  anchors: [SellingPlanAnchorInput!]
}
type SubscriptionContract {
  app: App
  appAdminUrl: URL
  billingAttempts: SubscriptionBillingAttemptConnection!
  billingPolicy: SubscriptionBillingPolicy!
  createdAt: DateTime!
  currencyCode: CurrencyCode!
  customAttributes: [Attribute!]!
  customer: Customer
  customerPaymentMethod: CustomerPaymentMethod
  deliveryMethod: SubscriptionDeliveryMethod
  deliveryPolicy: SubscriptionDeliveryPolicy!
  deliveryPrice: MoneyV2!
  discounts: SubscriptionManualDiscountConnection!
  id: ID!
  lastBillingAttemptErrorType: SubscriptionContractLastBillingErrorType
  lastPaymentStatus: SubscriptionContractLastPaymentStatus
  lineCount: Int!
  lines: SubscriptionLineConnection!
  linesCount: Count
  nextBillingDate: DateTime
  note: String
  orders: OrderConnection!
  originOrder: Order
  revisionId: UnsignedInt64!
  status: SubscriptionContractSubscriptionStatus!
  updatedAt: DateTime!
}
type SubscriptionContractActivatePayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}
input SubscriptionContractAtomicCreateInput {
  customerId: ID!
  nextBillingDate: DateTime!
  currencyCode: CurrencyCode!
  contract: SubscriptionDraftInput!
  lines: [SubscriptionAtomicLineInput!]!
  discountCodes: [String!]
}
type SubscriptionContractAtomicCreatePayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionDraftUserError!]!
}
interface SubscriptionContractBase {
  app: App
  appAdminUrl: URL
  currencyCode: CurrencyCode!
  customAttributes: [Attribute!]!
  customer: Customer
  customerPaymentMethod: CustomerPaymentMethod
  deliveryMethod: SubscriptionDeliveryMethod
  deliveryPrice: MoneyV2!
  discounts: SubscriptionManualDiscountConnection!
  lineCount: Int!
  lines: SubscriptionLineConnection!
  linesCount: Count
  note: String
  orders: OrderConnection!
  updatedAt: DateTime!
}
type SubscriptionContractCancelPayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}
type SubscriptionContractConnection {
  edges: [SubscriptionContractEdge!]!
  nodes: [SubscriptionContract!]!
  pageInfo: PageInfo!
}
input SubscriptionContractCreateInput {
  customerId: ID!
  nextBillingDate: DateTime!
  currencyCode: CurrencyCode!
  contract: SubscriptionDraftInput!
}
type SubscriptionContractCreatePayload {
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionContractEdge {
  cursor: String!
  node: SubscriptionContract!
}
enum SubscriptionContractErrorCode {
  INVALID
}
type SubscriptionContractExpirePayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}
type SubscriptionContractFailPayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}
enum SubscriptionContractLastBillingErrorType {
  PAYMENT_ERROR
  CUSTOMER_ERROR
  INVENTORY_ERROR
  OTHER
}
enum SubscriptionContractLastPaymentStatus {
  SUCCEEDED
  FAILED
}
type SubscriptionContractPausePayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionContractStatusUpdateUserError!]!
}
input SubscriptionContractProductChangeInput {
  productVariantId: ID
  currentPrice: Decimal
}
type SubscriptionContractProductChangePayload {
  contract: SubscriptionContract
  lineUpdated: SubscriptionLine
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionContractSetNextBillingDatePayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionContractUserError!]!
}
enum SubscriptionContractStatusUpdateErrorCode {
  INVALID
  CONTRACT_TERMINATED
}
type SubscriptionContractStatusUpdateUserError {
  code: SubscriptionContractStatusUpdateErrorCode
  field: [String!]
  message: String!
}
enum SubscriptionContractSubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELLED
  EXPIRED
  FAILED
}
type SubscriptionContractUpdatePayload {
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionContractUserError {
  code: SubscriptionContractErrorCode
  field: [String!]
  message: String!
}
type SubscriptionCyclePriceAdjustment {
  adjustmentType: SellingPlanPricingPolicyAdjustmentType!
  adjustmentValue: SellingPlanPricingPolicyAdjustmentValue!
  afterCycle: Int!
  computedPrice: MoneyV2!
}
union SubscriptionDeliveryMethod = SubscriptionDeliveryMethodLocalDelivery | SubscriptionDeliveryMethodPickup | SubscriptionDeliveryMethodShipping
input SubscriptionDeliveryMethodInput {
  shipping: SubscriptionDeliveryMethodShippingInput
  localDelivery: SubscriptionDeliveryMethodLocalDeliveryInput
  pickup: SubscriptionDeliveryMethodPickupInput
}
type SubscriptionDeliveryMethodLocalDelivery {
  address: SubscriptionMailingAddress!
  localDeliveryOption: SubscriptionDeliveryMethodLocalDeliveryOption!
}
input SubscriptionDeliveryMethodLocalDeliveryInput {
  address: MailingAddressInput
  localDeliveryOption: SubscriptionDeliveryMethodLocalDeliveryOptionInput
}
type SubscriptionDeliveryMethodLocalDeliveryOption {
  code: String
  description: String
  instructions: String
  phone: String!
  presentmentTitle: String
  title: String
}
input SubscriptionDeliveryMethodLocalDeliveryOptionInput {
  title: String
  presentmentTitle: String
  description: String
  code: String
  phone: String!
  instructions: String
}
type SubscriptionDeliveryMethodPickup {
  pickupOption: SubscriptionDeliveryMethodPickupOption!
}
input SubscriptionDeliveryMethodPickupInput {
  pickupOption: SubscriptionDeliveryMethodPickupOptionInput
}
type SubscriptionDeliveryMethodPickupOption {
  code: String
  description: String
  location: Location!
  presentmentTitle: String
  title: String
}
input SubscriptionDeliveryMethodPickupOptionInput {
  title: String
  presentmentTitle: String
  description: String
  code: String
  locationId: ID!
}
type SubscriptionDeliveryMethodShipping {
  address: SubscriptionMailingAddress!
  shippingOption: SubscriptionDeliveryMethodShippingOption!
}
input SubscriptionDeliveryMethodShippingInput {
  address: MailingAddressInput
  shippingOption: SubscriptionDeliveryMethodShippingOptionInput
}
type SubscriptionDeliveryMethodShippingOption {
  carrierService: DeliveryCarrierService
  code: String
  description: String
  presentmentTitle: String
  title: String
}
input SubscriptionDeliveryMethodShippingOptionInput {
  title: String
  presentmentTitle: String
  description: String
  code: String
  carrierServiceId: ID
}
union SubscriptionDeliveryOption = SubscriptionLocalDeliveryOption | SubscriptionPickupOption | SubscriptionShippingOption
union SubscriptionDeliveryOptionResult = SubscriptionDeliveryOptionResultFailure | SubscriptionDeliveryOptionResultSuccess
type SubscriptionDeliveryOptionResultFailure {
  message: String
}
type SubscriptionDeliveryOptionResultSuccess {
  deliveryOptions: [SubscriptionDeliveryOption!]!
}
type SubscriptionDeliveryPolicy {
  anchors: [SellingPlanAnchor!]!
  interval: SellingPlanInterval!
  intervalCount: Int!
}
input SubscriptionDeliveryPolicyInput {
  interval: SellingPlanInterval!
  intervalCount: Int!
  anchors: [SellingPlanAnchorInput!]
}
union SubscriptionDiscount = SubscriptionAppliedCodeDiscount | SubscriptionManualDiscount
type SubscriptionDiscountAllocation {
  amount: MoneyV2!
  discount: SubscriptionDiscount!
}
type SubscriptionDiscountConnection {
  edges: [SubscriptionDiscountEdge!]!
  nodes: [SubscriptionDiscount!]!
  pageInfo: PageInfo!
}
type SubscriptionDiscountEdge {
  cursor: String!
  node: SubscriptionDiscount!
}
type SubscriptionDiscountEntitledLines {
  all: Boolean!
  lines: SubscriptionLineConnection!
}
type SubscriptionDiscountFixedAmountValue {
  amount: MoneyV2!
  appliesOnEachItem: Boolean!
}
type SubscriptionDiscountPercentageValue {
  percentage: Int!
}
enum SubscriptionDiscountRejectionReason {
  NOT_FOUND
  NO_ENTITLED_LINE_ITEMS
  QUANTITY_NOT_IN_RANGE
  PURCHASE_NOT_IN_RANGE
  CUSTOMER_NOT_ELIGIBLE
  USAGE_LIMIT_REACHED
  CUSTOMER_USAGE_LIMIT_REACHED
  CURRENTLY_INACTIVE
  NO_ENTITLED_SHIPPING_LINES
  INCOMPATIBLE_PURCHASE_TYPE
  INTERNAL_ERROR
}
union SubscriptionDiscountValue = SubscriptionDiscountFixedAmountValue | SubscriptionDiscountPercentageValue
type SubscriptionDraft {
  billingCycle: SubscriptionBillingCycle
  billingPolicy: SubscriptionBillingPolicy!
  concatenatedBillingCycles: SubscriptionBillingCycleConnection!
  currencyCode: CurrencyCode!
  customAttributes: [Attribute!]!
  customer: Customer!
  customerPaymentMethod: CustomerPaymentMethod
  deliveryMethod: SubscriptionDeliveryMethod
  deliveryOptions: SubscriptionDeliveryOptionResult
  deliveryPolicy: SubscriptionDeliveryPolicy!
  deliveryPrice: MoneyV2
  discounts: SubscriptionDiscountConnection!
  discountsAdded: SubscriptionDiscountConnection!
  discountsRemoved: SubscriptionDiscountConnection!
  discountsUpdated: SubscriptionDiscountConnection!
  id: ID!
  lines: SubscriptionLineConnection!
  linesAdded: SubscriptionLineConnection!
  linesRemoved: SubscriptionLineConnection!
  nextBillingDate: DateTime
  note: String
  originalContract: SubscriptionContract
  shippingOptions: SubscriptionShippingOptionResult
  status: SubscriptionContractSubscriptionStatus
}
type SubscriptionDraftCommitPayload {
  contract: SubscriptionContract
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftDiscountAddPayload {
  discountAdded: SubscriptionManualDiscount
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftDiscountCodeApplyPayload {
  appliedDiscount: SubscriptionAppliedCodeDiscount
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftDiscountRemovePayload {
  discountRemoved: SubscriptionDiscount
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftDiscountUpdatePayload {
  discountUpdated: SubscriptionManualDiscount
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
enum SubscriptionDraftErrorCode {
  ALREADY_REMOVED
  PRESENCE
  COMMITTED
  NOT_IN_RANGE
  NOT_AN_INTEGER
  SELLING_PLAN_MAX_CYCLES_MUST_BE_GREATER_THAN_MIN_CYCLES
  DELIVERY_MUST_BE_MULTIPLE_OF_BILLING
  INVALID_BILLING_DATE
  INVALID_NOTE_LENGTH
  INVALID_LINES
  NO_ENTITLED_LINES
  CUSTOMER_DOES_NOT_EXIST
  CUSTOMER_MISMATCH
  DELIVERY_METHOD_REQUIRED
  MISSING_LOCAL_DELIVERY_OPTIONS
  CYCLE_DISCOUNTS_UNIQUE_AFTER_CYCLE
  INVALID_ADJUSTMENT_TYPE
  INVALID_ADJUSTMENT_VALUE
  STALE_CONTRACT
  CURRENCY_NOT_ENABLED
  HAS_FUTURE_EDITS
  BILLING_CYCLE_PRESENT
  BILLING_CYCLE_ABSENT
  BILLING_CYCLE_CONTRACT_DRAFT_DELIVERY_POLICY_INVALID
  BILLING_CYCLE_CONTRACT_DRAFT_BILLING_POLICY_INVALID
  CONCATENATION_BILLING_CYCLE_CONTRACT_DRAFT_REQUIRED
  CONCATENATION_UNCOMMITTED_CONTRACT_DRAFT
  DUPLICATE_CONCATENATED_CONTRACTS
  UPCOMING_CYCLE_LIMIT_EXCEEDED
  CYCLE_INDEX_OUT_OF_RANGE
  CYCLE_START_DATE_OUT_OF_RANGE
  CYCLE_SELECTOR_VALIDATE_ONE_OF
  EXCEEDED_MAX_CONCATENATED_CONTRACTS
  CUSTOMER_REDACTED
  MISSING_CUSTOMER_PAYMENT_METHOD
  INVALID
  BLANK
  GREATER_THAN
  GREATER_THAN_OR_EQUAL_TO
  LESS_THAN
  LESS_THAN_OR_EQUAL_TO
  TOO_LONG
  TOO_SHORT
}
type SubscriptionDraftFreeShippingDiscountAddPayload {
  discountAdded: SubscriptionManualDiscount
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftFreeShippingDiscountUpdatePayload {
  discountUpdated: SubscriptionManualDiscount
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
input SubscriptionDraftInput {
  status: SubscriptionContractSubscriptionStatus
  paymentMethodId: ID
  nextBillingDate: DateTime
  billingPolicy: SubscriptionBillingPolicyInput
  deliveryPolicy: SubscriptionDeliveryPolicyInput
  deliveryPrice: Decimal
  deliveryMethod: SubscriptionDeliveryMethodInput
  note: String
  customAttributes: [AttributeInput!]
}
type SubscriptionDraftLineAddPayload {
  draft: SubscriptionDraft
  lineAdded: SubscriptionLine
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftLineRemovePayload {
  discountsUpdated: [SubscriptionManualDiscount!]
  draft: SubscriptionDraft
  lineRemoved: SubscriptionLine
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftLineUpdatePayload {
  draft: SubscriptionDraft
  lineUpdated: SubscriptionLine
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftUpdatePayload {
  draft: SubscriptionDraft
  userErrors: [SubscriptionDraftUserError!]!
}
type SubscriptionDraftUserError {
  code: SubscriptionDraftErrorCode
  field: [String!]
  message: String!
}
input SubscriptionFreeShippingDiscountInput {
  title: String
  recurringCycleLimit: Int
}
type SubscriptionLine {
  concatenatedOriginContract: SubscriptionContract
  currentPrice: MoneyV2!
  customAttributes: [Attribute!]!
  discountAllocations: [SubscriptionDiscountAllocation!]!
  id: ID!
  lineDiscountedPrice: MoneyV2!
  pricingPolicy: SubscriptionPricingPolicy
  productId: ID
  quantity: Int!
  requiresShipping: Boolean!
  sellingPlanId: ID
  sellingPlanName: String
  sku: String
  taxable: Boolean!
  title: String!
  variantId: ID
  variantImage: Image
  variantTitle: String
}
type SubscriptionLineConnection {
  edges: [SubscriptionLineEdge!]!
  nodes: [SubscriptionLine!]!
  pageInfo: PageInfo!
}
type SubscriptionLineEdge {
  cursor: String!
  node: SubscriptionLine!
}
input SubscriptionLineInput {
  productVariantId: ID!
  quantity: Int!
  currentPrice: Decimal!
  customAttributes: [AttributeInput!]
  sellingPlanId: ID
  sellingPlanName: String
  pricingPolicy: SubscriptionPricingPolicyInput
}
input SubscriptionLineUpdateInput {
  productVariantId: ID
  quantity: Int
  sellingPlanId: ID
  sellingPlanName: String
  currentPrice: Decimal
  customAttributes: [AttributeInput!]
  pricingPolicy: SubscriptionPricingPolicyInput
}
type SubscriptionLocalDeliveryOption {
  code: String!
  description: String
  phoneRequired: Boolean!
  presentmentTitle: String
  price: MoneyV2
  title: String!
}
type SubscriptionMailingAddress {
  address1: String
  address2: String
  city: String
  company: String
  country: String
  countryCode: CountryCode
  firstName: String
  lastName: String
  name: String
  phone: String
  province: String
  provinceCode: String
  zip: String
}
type SubscriptionManualDiscount {
  entitledLines: SubscriptionDiscountEntitledLines!
  id: ID!
  recurringCycleLimit: Int
  rejectionReason: SubscriptionDiscountRejectionReason
  targetType: DiscountTargetType!
  title: String
  type: DiscountType!
  usageCount: Int!
  value: SubscriptionDiscountValue!
}
type SubscriptionManualDiscountConnection {
  edges: [SubscriptionManualDiscountEdge!]!
  nodes: [SubscriptionManualDiscount!]!
  pageInfo: PageInfo!
}
type SubscriptionManualDiscountEdge {
  cursor: String!
  node: SubscriptionManualDiscount!
}
input SubscriptionManualDiscountEntitledLinesInput {
  all: Boolean
  lines: SubscriptionManualDiscountLinesInput
}
input SubscriptionManualDiscountFixedAmountInput {
  amount: Float
  appliesOnEachItem: Boolean
}
input SubscriptionManualDiscountInput {
  title: String
  value: SubscriptionManualDiscountValueInput
  recurringCycleLimit: Int
  entitledLines: SubscriptionManualDiscountEntitledLinesInput
}
input SubscriptionManualDiscountLinesInput {
  add: [ID!]
  remove: [ID!]
}
input SubscriptionManualDiscountValueInput {
  percentage: Int
  fixedAmount: SubscriptionManualDiscountFixedAmountInput
}
type SubscriptionPickupOption {
  code: String!
  description: String
  location: Location!
  phoneRequired: Boolean!
  pickupTime: String!
  presentmentTitle: String
  price: MoneyV2
  title: String!
}
type SubscriptionPricingPolicy {
  basePrice: MoneyV2!
  cycleDiscounts: [SubscriptionCyclePriceAdjustment!]!
}
input SubscriptionPricingPolicyCycleDiscountsInput {
  afterCycle: Int!
  adjustmentType: SellingPlanPricingPolicyAdjustmentType!
  adjustmentValue: SellingPlanPricingPolicyValueInput!
  computedPrice: Decimal!
}
input SubscriptionPricingPolicyInput {
  basePrice: Decimal!
  cycleDiscounts: [SubscriptionPricingPolicyCycleDiscountsInput!]!
}
type SubscriptionShippingOption {
  carrierService: DeliveryCarrierService
  code: String!
  description: String
  phoneRequired: Boolean
  presentmentTitle: String
  price: MoneyV2
  title: String!
}
union SubscriptionShippingOptionResult = SubscriptionShippingOptionResultFailure | SubscriptionShippingOptionResultSuccess
type SubscriptionShippingOptionResultFailure {
  message: String
}
type SubscriptionShippingOptionResultSuccess {
  shippingOptions: [SubscriptionShippingOption!]!
}
type SuggestedOrderTransaction {
  accountNumber: String
  amount: Money!
  amountSet: MoneyBag!
  formattedGateway: String
  gateway: String
  kind: SuggestedOrderTransactionKind!
  maximumRefundable: Money
  maximumRefundableSet: MoneyBag
  parentTransaction: OrderTransaction
  paymentDetails: PaymentDetails
}
enum SuggestedOrderTransactionKind {
  SUGGESTED_REFUND
}
type SuggestedRefund {
  amount: Money!
  amountSet: MoneyBag!
  discountedSubtotalSet: MoneyBag!
  maximumRefundable: Money!
  maximumRefundableSet: MoneyBag!
  refundDuties: [RefundDuty!]!
  refundLineItems: [RefundLineItem!]!
  shipping: ShippingRefund!
  subtotal: Money!
  subtotalSet: MoneyBag!
  suggestedTransactions: [SuggestedOrderTransaction!]!
  totalCartDiscountAmountSet: MoneyBag!
  totalDutiesSet: MoneyBag!
  totalTaxSet: MoneyBag!
  totalTaxes: Money!
}
type SuggestedReturnRefund {
  amount: MoneyBag!
  discountedSubtotal: MoneyBag!
  maximumRefundable: MoneyBag!
  refundDuties: [RefundDuty!]!
  shipping: ShippingRefund!
  subtotal: MoneyBag!
  suggestedTransactions: [SuggestedOrderTransaction!]!
  totalCartDiscountAmount: MoneyBag!
  totalDuties: MoneyBag!
  totalTax: MoneyBag!
}
type TagsAddPayload {
  node: Node
  userErrors: [UserError!]!
}
type TagsRemovePayload {
  node: Node
  userErrors: [UserError!]!
}
type TaxAppConfiguration {
  state: TaxPartnerState!
}
type TaxAppConfigurePayload {
  taxAppConfiguration: TaxAppConfiguration
  userErrors: [TaxAppConfigureUserError!]!
}
type TaxAppConfigureUserError {
  code: TaxAppConfigureUserErrorCode
  field: [String!]
  message: String!
}
enum TaxAppConfigureUserErrorCode {
  TAX_PARTNER_NOT_FOUND
  TAX_PARTNER_STATE_UPDATE_FAILED
  TAX_PARTNER_ALREADY_ACTIVE
}
enum TaxExemption {
  CA_STATUS_CARD_EXEMPTION
  CA_BC_RESELLER_EXEMPTION
  CA_MB_RESELLER_EXEMPTION
  CA_SK_RESELLER_EXEMPTION
  CA_DIPLOMAT_EXEMPTION
  CA_BC_COMMERCIAL_FISHERY_EXEMPTION
  CA_MB_COMMERCIAL_FISHERY_EXEMPTION
  CA_NS_COMMERCIAL_FISHERY_EXEMPTION
  CA_PE_COMMERCIAL_FISHERY_EXEMPTION
  CA_SK_COMMERCIAL_FISHERY_EXEMPTION
  CA_BC_PRODUCTION_AND_MACHINERY_EXEMPTION
  CA_SK_PRODUCTION_AND_MACHINERY_EXEMPTION
  CA_BC_SUB_CONTRACTOR_EXEMPTION
  CA_SK_SUB_CONTRACTOR_EXEMPTION
  CA_BC_CONTRACTOR_EXEMPTION
  CA_SK_CONTRACTOR_EXEMPTION
  CA_ON_PURCHASE_EXEMPTION
  CA_MB_FARMER_EXEMPTION
  CA_NS_FARMER_EXEMPTION
  CA_SK_FARMER_EXEMPTION
  EU_REVERSE_CHARGE_EXEMPTION_RULE
  US_AL_RESELLER_EXEMPTION
  US_AK_RESELLER_EXEMPTION
  US_AZ_RESELLER_EXEMPTION
  US_AR_RESELLER_EXEMPTION
  US_CA_RESELLER_EXEMPTION
  US_CO_RESELLER_EXEMPTION
  US_CT_RESELLER_EXEMPTION
  US_DE_RESELLER_EXEMPTION
  US_FL_RESELLER_EXEMPTION
  US_GA_RESELLER_EXEMPTION
  US_HI_RESELLER_EXEMPTION
  US_ID_RESELLER_EXEMPTION
  US_IL_RESELLER_EXEMPTION
  US_IN_RESELLER_EXEMPTION
  US_IA_RESELLER_EXEMPTION
  US_KS_RESELLER_EXEMPTION
  US_KY_RESELLER_EXEMPTION
  US_LA_RESELLER_EXEMPTION
  US_ME_RESELLER_EXEMPTION
  US_MD_RESELLER_EXEMPTION
  US_MA_RESELLER_EXEMPTION
  US_MI_RESELLER_EXEMPTION
  US_MN_RESELLER_EXEMPTION
  US_MS_RESELLER_EXEMPTION
  US_MO_RESELLER_EXEMPTION
  US_MT_RESELLER_EXEMPTION
  US_NE_RESELLER_EXEMPTION
  US_NV_RESELLER_EXEMPTION
  US_NH_RESELLER_EXEMPTION
  US_NJ_RESELLER_EXEMPTION
  US_NM_RESELLER_EXEMPTION
  US_NY_RESELLER_EXEMPTION
  US_NC_RESELLER_EXEMPTION
  US_ND_RESELLER_EXEMPTION
  US_OH_RESELLER_EXEMPTION
  US_OK_RESELLER_EXEMPTION
  US_OR_RESELLER_EXEMPTION
  US_PA_RESELLER_EXEMPTION
  US_RI_RESELLER_EXEMPTION
  US_SC_RESELLER_EXEMPTION
  US_SD_RESELLER_EXEMPTION
  US_TN_RESELLER_EXEMPTION
  US_TX_RESELLER_EXEMPTION
  US_UT_RESELLER_EXEMPTION
  US_VT_RESELLER_EXEMPTION
  US_VA_RESELLER_EXEMPTION
  US_WA_RESELLER_EXEMPTION
  US_WV_RESELLER_EXEMPTION
  US_WI_RESELLER_EXEMPTION
  US_WY_RESELLER_EXEMPTION
  US_DC_RESELLER_EXEMPTION
}
type TaxLine {
  channelLiable: Boolean
  price: Money!
  priceSet: MoneyBag!
  rate: Float
  ratePercentage: Float
  source: String
  title: String!
}
enum TaxPartnerState {
  PENDING
  READY
  ACTIVE
}
type Taxonomy {
  categories: TaxonomyCategoryConnection!
}
type TaxonomyAttribute {
  id: ID!
}
type TaxonomyCategory {
  ancestorIds: [ID!]!
  attributes: TaxonomyCategoryAttributeConnection!
  childrenIds: [ID!]!
  fullName: String!
  id: ID!
  isArchived: Boolean!
  isLeaf: Boolean!
  isRoot: Boolean!
  level: Int!
  name: String!
  parentId: ID
}
union TaxonomyCategoryAttribute = TaxonomyAttribute | TaxonomyChoiceListAttribute | TaxonomyMeasurementAttribute
type TaxonomyCategoryAttributeConnection {
  edges: [TaxonomyCategoryAttributeEdge!]!
  nodes: [TaxonomyCategoryAttribute!]!
  pageInfo: PageInfo!
}
type TaxonomyCategoryAttributeEdge {
  cursor: String!
  node: TaxonomyCategoryAttribute!
}
type TaxonomyCategoryConnection {
  edges: [TaxonomyCategoryEdge!]!
  nodes: [TaxonomyCategory!]!
  pageInfo: PageInfo!
}
type TaxonomyCategoryEdge {
  cursor: String!
  node: TaxonomyCategory!
}
type TaxonomyChoiceListAttribute {
  id: ID!
  name: String!
  values: TaxonomyValueConnection!
}
type TaxonomyMeasurementAttribute {
  id: ID!
  name: String!
  options: [Attribute!]!
}
type TaxonomyValue {
  id: ID!
  name: String!
}
type TaxonomyValueConnection {
  edges: [TaxonomyValueEdge!]!
  nodes: [TaxonomyValue!]!
  pageInfo: PageInfo!
}
type TaxonomyValueEdge {
  cursor: String!
  node: TaxonomyValue!
}
type TenderTransaction {
  amount: MoneyV2!
  id: ID!
  order: Order
  paymentMethod: String
  processedAt: DateTime
  remoteReference: String
  test: Boolean!
  transactionDetails: TenderTransactionDetails
  user: StaffMember
}
type TenderTransactionConnection {
  edges: [TenderTransactionEdge!]!
  nodes: [TenderTransaction!]!
  pageInfo: PageInfo!
}
type TenderTransactionCreditCardDetails {
  creditCardCompany: String
  creditCardNumber: String
}
union TenderTransactionDetails = TenderTransactionCreditCardDetails
type TenderTransactionEdge {
  cursor: String!
  node: TenderTransaction!
}
type ThemeCreatePayload {
  theme: OnlineStoreTheme
  userErrors: [ThemeCreateUserError!]!
}
type ThemeCreateUserError {
  code: ThemeCreateUserErrorCode
  field: [String!]
  message: String!
}
enum ThemeCreateUserErrorCode {
  INVALID_ZIP
  ZIP_IS_EMPTY
  ZIP_TOO_LARGE
  THEME_CREATION_NOT_ALLOWED_FOR_THEME_LIMITED_PLAN
  INVALID_THEME_ROLE_FOR_THEME_CREATION
}
type ThemeDeletePayload {
  deletedThemeId: ID
  userErrors: [ThemeDeleteUserError!]!
}
type ThemeDeleteUserError {
  code: ThemeDeleteUserErrorCode
  field: [String!]
  message: String!
}
enum ThemeDeleteUserErrorCode {
  NOT_FOUND
}
input ThemeFilesCopyFileInput {
  dstFilename: String!
  srcFilename: String!
}
type ThemeFilesCopyPayload {
  copiedThemeFiles: [OnlineStoreThemeFileOperationResult!]
  userErrors: [OnlineStoreThemeFilesUserErrors!]!
}
type ThemeFilesDeletePayload {
  deletedThemeFiles: [OnlineStoreThemeFileOperationResult!]
  userErrors: [OnlineStoreThemeFilesUserErrors!]!
}
type ThemeFilesUpsertPayload {
  job: Job
  upsertedThemeFiles: [OnlineStoreThemeFileOperationResult!]
  userErrors: [OnlineStoreThemeFilesUserErrors!]!
}
type ThemePublishPayload {
  theme: OnlineStoreTheme
  userErrors: [ThemePublishUserError!]!
}
type ThemePublishUserError {
  code: ThemePublishUserErrorCode
  field: [String!]
  message: String!
}
enum ThemePublishUserErrorCode {
  NOT_FOUND
  CANNOT_PUBLISH_THEME_DURING_INSTALL
  THEME_PUBLISH_NOT_AVAILABLE_FOR_THEME_LIMITED_PLAN
}
enum ThemeRole {
  MAIN
  UNPUBLISHED
  DEMO
  DEVELOPMENT
  ARCHIVED
  LOCKED
  MOBILE
}
type ThemeUpdatePayload {
  theme: OnlineStoreTheme
  userErrors: [ThemeUpdateUserError!]!
}
type ThemeUpdateUserError {
  code: ThemeUpdateUserErrorCode
  field: [String!]
  message: String!
}
enum ThemeUpdateUserErrorCode {
  NOT_FOUND
  TOO_LONG
  INVALID
}
type TipSale {
  actionType: SaleActionType!
  id: ID!
  lineItem: LineItem!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
type TransactionFee {
  amount: MoneyV2!
  flatFee: MoneyV2!
  flatFeeName: String
  id: ID!
  rate: Decimal!
  rateName: String
  taxAmount: MoneyV2!
  type: String!
}
enum TransactionSortKeys {
  CREATED_AT
  EXPIRES_AT
}
type TransactionVoidPayload {
  transaction: OrderTransaction
  userErrors: [TransactionVoidUserError!]!
}
type TransactionVoidUserError {
  code: TransactionVoidUserErrorCode
  field: [String!]
  message: String!
}
enum TransactionVoidUserErrorCode {
  TRANSACTION_NOT_FOUND
  AUTH_NOT_SUCCESSFUL
  AUTH_NOT_VOIDABLE
  GENERIC_ERROR
}
type TranslatableContent {
  digest: String
  key: String!
  locale: String!
  type: LocalizableContentType!
  value: String
}
type TranslatableResource {
  nestedTranslatableResources: TranslatableResourceConnection!
  resourceId: ID!
  translatableContent: [TranslatableContent!]!
  translations: [Translation!]!
}
type TranslatableResourceConnection {
  edges: [TranslatableResourceEdge!]!
  nodes: [TranslatableResource!]!
  pageInfo: PageInfo!
}
type TranslatableResourceEdge {
  cursor: String!
  node: TranslatableResource!
}
enum TranslatableResourceType {
  ARTICLE
  BLOG
  COLLECTION
  DELIVERY_METHOD_DEFINITION
  EMAIL_TEMPLATE
  FILTER
  LINK
  MENU
  METAFIELD
  METAOBJECT
  ONLINE_STORE_THEME
  ONLINE_STORE_THEME_APP_EMBED
  ONLINE_STORE_THEME_JSON_TEMPLATE
  ONLINE_STORE_THEME_LOCALE_CONTENT
  ONLINE_STORE_THEME_SECTION_GROUP
  ONLINE_STORE_THEME_SETTINGS_CATEGORY
  ONLINE_STORE_THEME_SETTINGS_DATA_SECTIONS
  PACKING_SLIP_TEMPLATE
  PAGE
  PAYMENT_GATEWAY
  PRODUCT
  PRODUCT_OPTION
  PRODUCT_OPTION_VALUE
  SELLING_PLAN
  SELLING_PLAN_GROUP
  SHOP
  SHOP_POLICY
}
type Translation {
  key: String!
  locale: String!
  market: Market
  outdated: Boolean!
  updatedAt: DateTime
  value: String
}
enum TranslationErrorCode {
  BLANK
  INVALID
  RESOURCE_NOT_FOUND
  RESOURCE_NOT_TRANSLATABLE
  TOO_MANY_KEYS_FOR_RESOURCE
  INVALID_KEY_FOR_MODEL
  FAILS_RESOURCE_VALIDATION
  INVALID_TRANSLATABLE_CONTENT
  INVALID_MARKET_LOCALIZABLE_CONTENT
  INVALID_LOCALE_FOR_SHOP
  INVALID_CODE
  INVALID_FORMAT
  MARKET_CUSTOM_CONTENT_NOT_ALLOWED
  MARKET_DOES_NOT_EXIST
  MARKET_LOCALE_CREATION_FAILED
  RESOURCE_NOT_MARKET_CUSTOMIZABLE
  INVALID_LOCALE_FOR_MARKET
  INVALID_VALUE_FOR_HANDLE_TRANSLATION
}
input TranslationInput {
  locale: String!
  key: String!
  value: String!
  translatableContentDigest: String!
  marketId: ID
}
type TranslationUserError {
  code: TranslationErrorCode
  field: [String!]
  message: String!
}
type TranslationsRegisterPayload {
  translations: [Translation!]
  userErrors: [TranslationUserError!]!
}
type TranslationsRemovePayload {
  translations: [Translation!]
  userErrors: [TranslationUserError!]!
}
type TypedAttribute {
  key: String!
  value: String!
}
scalar URL
input UTMInput {
  campaign: String!
  source: String!
  medium: String!
}
type UTMParameters {
  campaign: String
  content: String
  medium: String
  source: String
  term: String
}
input UniqueMetafieldValueInput {
  namespace: String
  key: String!
  value: String!
}
type UnitPriceMeasurement {
  measuredType: UnitPriceMeasurementMeasuredType
  quantityUnit: UnitPriceMeasurementMeasuredUnit
  quantityValue: Float!
  referenceUnit: UnitPriceMeasurementMeasuredUnit
  referenceValue: Int!
}
enum UnitPriceMeasurementMeasuredType {
  VOLUME
  WEIGHT
  LENGTH
  AREA
}
enum UnitPriceMeasurementMeasuredUnit {
  ML
  CL
  L
  M3
  MG
  G
  KG
  MM
  CM
  M
  M2
}
enum UnitSystem {
  IMPERIAL_SYSTEM
  METRIC_SYSTEM
}
type UnknownSale {
  actionType: SaleActionType!
  id: ID!
  lineType: SaleLineType!
  quantity: Int
  taxes: [SaleTax!]!
  totalAmount: MoneyBag!
  totalDiscountAmountAfterTaxes: MoneyBag!
  totalDiscountAmountBeforeTaxes: MoneyBag!
  totalTaxAmount: MoneyBag!
}
scalar UnsignedInt64
type UnverifiedReturnLineItem {
  customerNote: String
  id: ID!
  quantity: Int!
  refundableQuantity: Int!
  refundedQuantity: Int!
  returnReason: ReturnReason!
  returnReasonNote: String!
  unitPrice: MoneyV2!
}
input UpdateMediaInput {
  id: ID!
  previewImageSource: String
  alt: String
}
type UrlRedirect {
  id: ID!
  path: String!
  target: String!
}
type UrlRedirectBulkDeleteAllPayload {
  job: Job
  userErrors: [UserError!]!
}
type UrlRedirectBulkDeleteByIdsPayload {
  job: Job
  userErrors: [UrlRedirectBulkDeleteByIdsUserError!]!
}
type UrlRedirectBulkDeleteByIdsUserError {
  code: UrlRedirectBulkDeleteByIdsUserErrorCode
  field: [String!]
  message: String!
}
enum UrlRedirectBulkDeleteByIdsUserErrorCode {
  IDS_EMPTY
}
type UrlRedirectBulkDeleteBySavedSearchPayload {
  job: Job
  userErrors: [UrlRedirectBulkDeleteBySavedSearchUserError!]!
}
type UrlRedirectBulkDeleteBySavedSearchUserError {
  code: UrlRedirectBulkDeleteBySavedSearchUserErrorCode
  field: [String!]
  message: String!
}
enum UrlRedirectBulkDeleteBySavedSearchUserErrorCode {
  SAVED_SEARCH_NOT_FOUND
  INVALID_SAVED_SEARCH_QUERY
}
type UrlRedirectBulkDeleteBySearchPayload {
  job: Job
  userErrors: [UrlRedirectBulkDeleteBySearchUserError!]!
}
type UrlRedirectBulkDeleteBySearchUserError {
  code: UrlRedirectBulkDeleteBySearchUserErrorCode
  field: [String!]
  message: String!
}
enum UrlRedirectBulkDeleteBySearchUserErrorCode {
  INVALID_SEARCH_ARGUMENT
}
type UrlRedirectConnection {
  edges: [UrlRedirectEdge!]!
  nodes: [UrlRedirect!]!
  pageInfo: PageInfo!
}
type UrlRedirectCreatePayload {
  urlRedirect: UrlRedirect
  userErrors: [UrlRedirectUserError!]!
}
type UrlRedirectDeletePayload {
  deletedUrlRedirectId: ID
  userErrors: [UrlRedirectUserError!]!
}
type UrlRedirectEdge {
  cursor: String!
  node: UrlRedirect!
}
enum UrlRedirectErrorCode {
  DOES_NOT_EXIST
  CREATE_FAILED
  UPDATE_FAILED
  DELETE_FAILED
}
type UrlRedirectImport {
  count: Int
  createdCount: Int
  failedCount: Int
  finished: Boolean!
  finishedAt: DateTime
  id: ID!
  previewRedirects: [UrlRedirectImportPreview!]!
  updatedCount: Int
}
type UrlRedirectImportCreatePayload {
  urlRedirectImport: UrlRedirectImport
  userErrors: [UrlRedirectImportUserError!]!
}
enum UrlRedirectImportErrorCode {
  FILE_DOES_NOT_EXIST
  NOT_FOUND
  ALREADY_IMPORTED
  IN_PROGRESS
}
type UrlRedirectImportPreview {
  path: String!
  target: String!
}
type UrlRedirectImportSubmitPayload {
  job: Job
  userErrors: [UrlRedirectImportUserError!]!
}
type UrlRedirectImportUserError {
  code: UrlRedirectImportErrorCode
  field: [String!]
  message: String!
}
input UrlRedirectInput {
  path: String
  target: String
}
enum UrlRedirectSortKeys {
  ID
  PATH
  RELEVANCE
}
type UrlRedirectUpdatePayload {
  urlRedirect: UrlRedirect
  userErrors: [UrlRedirectUserError!]!
}
type UrlRedirectUserError {
  code: UrlRedirectErrorCode
  field: [String!]
  message: String!
}
type UserError {
  field: [String!]
  message: String!
}
scalar UtcOffset
type Validation {
  blockOnFailure: Boolean!
  enabled: Boolean!
  errorHistory: FunctionsErrorHistory
  id: ID!
  metafield: Metafield
  metafieldDefinitions: MetafieldDefinitionConnection!
  metafields: MetafieldConnection!
  shopifyFunction: ShopifyFunction!
  title: String!
}
type ValidationConnection {
  edges: [ValidationEdge!]!
  nodes: [Validation!]!
  pageInfo: PageInfo!
}
input ValidationCreateInput {
  functionId: String!
  enable: Boolean
  blockOnFailure: Boolean
  metafields: [MetafieldInput!]
  title: String
}
type ValidationCreatePayload {
  userErrors: [ValidationUserError!]!
  validation: Validation
}
type ValidationDeletePayload {
  deletedId: ID
  userErrors: [ValidationUserError!]!
}
type ValidationEdge {
  cursor: String!
  node: Validation!
}
enum ValidationSortKeys {
  ID
  RELEVANCE
}
input ValidationUpdateInput {
  enable: Boolean
  blockOnFailure: Boolean
  metafields: [MetafieldInput!]
  title: String
}
type ValidationUpdatePayload {
  userErrors: [ValidationUserError!]!
  validation: Validation
}
type ValidationUserError {
  code: ValidationUserErrorCode
  field: [String!]
  message: String!
}
enum ValidationUserErrorCode {
  NOT_FOUND
  FUNCTION_NOT_FOUND
  CUSTOM_APP_FUNCTION_NOT_ELIGIBLE
  FUNCTION_DOES_NOT_IMPLEMENT
  PUBLIC_APP_NOT_ALLOWED
  FUNCTION_PENDING_DELETION
  INVALID_TYPE
  INVALID_VALUE
  APP_NOT_AUTHORIZED
  UNSTRUCTURED_RESERVED_NAMESPACE
  DISALLOWED_OWNER_TYPE
  INCLUSION
  TAKEN
  PRESENT
  BLANK
  TOO_LONG
  TOO_SHORT
  CAPABILITY_VIOLATION
  INTERNAL_ERROR
}
input VariantOptionValueInput {
  id: ID
  name: String
  linkedMetafieldValue: String
  optionId: ID
  optionName: String
}
type VaultCreditCard {
  billingAddress: CustomerCreditCardBillingAddress
  brand: String!
  expired: Boolean!
  expiryMonth: Int!
  expiryYear: Int!
  lastDigits: String!
  name: String!
}
type VaultPaypalBillingAgreement {
  inactive: Boolean!
  name: String!
  paypalAccountEmail: String!
}
type Vector3 {
  x: Float!
  y: Float!
  z: Float!
}
type Video {
  alt: String
  createdAt: DateTime!
  duration: Int
  fileErrors: [FileError!]!
  fileStatus: FileStatus!
  filename: String!
  id: ID!
  mediaContentType: MediaContentType!
  mediaErrors: [MediaError!]!
  mediaWarnings: [MediaWarning!]!
  originalSource: VideoSource
  preview: MediaPreviewImage
  sources: [VideoSource!]!
  status: MediaStatus!
  updatedAt: DateTime!
}
type VideoSource {
  fileSize: Int
  format: String!
  height: Int!
  mimeType: String!
  url: String!
  width: Int!
}
type WebPixel {
  id: ID!
  settings: JSON!
}
type WebPixelCreatePayload {
  userErrors: [ErrorsWebPixelUserError!]!
  webPixel: WebPixel
}
type WebPixelDeletePayload {
  deletedWebPixelId: ID
  userErrors: [ErrorsWebPixelUserError!]!
}
input WebPixelInput {
  settings: JSON!
}
type WebPixelUpdatePayload {
  userErrors: [ErrorsWebPixelUserError!]!
  webPixel: WebPixel
}
type WebhookEventBridgeEndpoint {
  arn: ARN!
}
type WebhookHttpEndpoint {
  callbackUrl: URL!
}
type WebhookPubSubEndpoint {
  pubSubProject: String!
  pubSubTopic: String!
}
type WebhookSubscription {
  apiVersion: ApiVersion!
  callbackUrl: URL!
  createdAt: DateTime!
  endpoint: WebhookSubscriptionEndpoint!
  filter: String
  format: WebhookSubscriptionFormat!
  id: ID!
  includeFields: [String!]!
  legacyResourceId: UnsignedInt64!
  metafieldNamespaces: [String!]!
  topic: WebhookSubscriptionTopic!
  updatedAt: DateTime!
}
type WebhookSubscriptionConnection {
  edges: [WebhookSubscriptionEdge!]!
  nodes: [WebhookSubscription!]!
  pageInfo: PageInfo!
}
type WebhookSubscriptionCreatePayload {
  userErrors: [UserError!]!
  webhookSubscription: WebhookSubscription
}
type WebhookSubscriptionDeletePayload {
  deletedWebhookSubscriptionId: ID
  userErrors: [UserError!]!
}
type WebhookSubscriptionEdge {
  cursor: String!
  node: WebhookSubscription!
}
union WebhookSubscriptionEndpoint = WebhookEventBridgeEndpoint | WebhookHttpEndpoint | WebhookPubSubEndpoint
enum WebhookSubscriptionFormat {
  JSON
  XML
}
input WebhookSubscriptionInput {
  callbackUrl: URL
  format: WebhookSubscriptionFormat
  includeFields: [String!]
  filter: String
  metafieldNamespaces: [String!]
}
enum WebhookSubscriptionSortKeys {
  CREATED_AT
  ID
  RELEVANCE
}
enum WebhookSubscriptionTopic {
  APP_UNINSTALLED
  APP_SCOPES_UPDATE
  CARTS_CREATE
  CARTS_UPDATE
  CHANNELS_DELETE
  CHECKOUTS_CREATE
  CHECKOUTS_DELETE
  CHECKOUTS_UPDATE
  CUSTOMER_PAYMENT_METHODS_CREATE
  CUSTOMER_PAYMENT_METHODS_UPDATE
  CUSTOMER_PAYMENT_METHODS_REVOKE
  COLLECTION_LISTINGS_ADD
  COLLECTION_LISTINGS_REMOVE
  COLLECTION_LISTINGS_UPDATE
  COLLECTION_PUBLICATIONS_CREATE
  COLLECTION_PUBLICATIONS_DELETE
  COLLECTION_PUBLICATIONS_UPDATE
  COLLECTIONS_CREATE
  COLLECTIONS_DELETE
  COLLECTIONS_UPDATE
  CUSTOMER_GROUPS_CREATE
  CUSTOMER_GROUPS_DELETE
  CUSTOMER_GROUPS_UPDATE
  CUSTOMERS_CREATE
  CUSTOMERS_DELETE
  CUSTOMERS_DISABLE
  CUSTOMERS_ENABLE
  CUSTOMERS_UPDATE
  CUSTOMERS_PURCHASING_SUMMARY
  CUSTOMERS_MARKETING_CONSENT_UPDATE
  CUSTOMER_TAGS_ADDED
  CUSTOMER_TAGS_REMOVED
  CUSTOMERS_EMAIL_MARKETING_CONSENT_UPDATE
  DISPUTES_CREATE
  DISPUTES_UPDATE
  DRAFT_ORDERS_CREATE
  DRAFT_ORDERS_DELETE
  DRAFT_ORDERS_UPDATE
  FULFILLMENT_EVENTS_CREATE
  FULFILLMENT_EVENTS_DELETE
  FULFILLMENTS_CREATE
  FULFILLMENTS_UPDATE
  ATTRIBUTED_SESSIONS_FIRST
  ATTRIBUTED_SESSIONS_LAST
  ORDER_TRANSACTIONS_CREATE
  ORDERS_CANCELLED
  ORDERS_CREATE
  ORDERS_DELETE
  ORDERS_EDITED
  ORDERS_FULFILLED
  ORDERS_PAID
  ORDERS_PARTIALLY_FULFILLED
  ORDERS_UPDATED
  FULFILLMENT_ORDERS_MOVED
  FULFILLMENT_ORDERS_HOLD_RELEASED
  FULFILLMENT_ORDERS_SCHEDULED_FULFILLMENT_ORDER_READY
  FULFILLMENT_HOLDS_RELEASED
  FULFILLMENT_ORDERS_ORDER_ROUTING_COMPLETE
  FULFILLMENT_ORDERS_CANCELLED
  FULFILLMENT_ORDERS_FULFILLMENT_SERVICE_FAILED_TO_COMPLETE
  FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_REJECTED
  FULFILLMENT_ORDERS_CANCELLATION_REQUEST_SUBMITTED
  FULFILLMENT_ORDERS_CANCELLATION_REQUEST_ACCEPTED
  FULFILLMENT_ORDERS_CANCELLATION_REQUEST_REJECTED
  FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_SUBMITTED
  FULFILLMENT_ORDERS_FULFILLMENT_REQUEST_ACCEPTED
  FULFILLMENT_HOLDS_ADDED
  FULFILLMENT_ORDERS_LINE_ITEMS_PREPARED_FOR_LOCAL_DELIVERY
  FULFILLMENT_ORDERS_PLACED_ON_HOLD
  FULFILLMENT_ORDERS_MERGED
  FULFILLMENT_ORDERS_SPLIT
  PRODUCT_LISTINGS_ADD
  PRODUCT_LISTINGS_REMOVE
  PRODUCT_LISTINGS_UPDATE
  SCHEDULED_PRODUCT_LISTINGS_ADD
  SCHEDULED_PRODUCT_LISTINGS_UPDATE
  SCHEDULED_PRODUCT_LISTINGS_REMOVE
  PRODUCT_PUBLICATIONS_CREATE
  PRODUCT_PUBLICATIONS_DELETE
  PRODUCT_PUBLICATIONS_UPDATE
  PRODUCTS_CREATE
  PRODUCTS_DELETE
  PRODUCTS_UPDATE
  REFUNDS_CREATE
  SEGMENTS_CREATE
  SEGMENTS_DELETE
  SEGMENTS_UPDATE
  SHIPPING_ADDRESSES_CREATE
  SHIPPING_ADDRESSES_UPDATE
  SHOP_UPDATE
  TAX_PARTNERS_UPDATE
  TAX_SERVICES_CREATE
  TAX_SERVICES_UPDATE
  THEMES_CREATE
  THEMES_DELETE
  THEMES_PUBLISH
  THEMES_UPDATE
  VARIANTS_IN_STOCK
  VARIANTS_OUT_OF_STOCK
  INVENTORY_LEVELS_CONNECT
  INVENTORY_LEVELS_UPDATE
  INVENTORY_LEVELS_DISCONNECT
  INVENTORY_ITEMS_CREATE
  INVENTORY_ITEMS_UPDATE
  INVENTORY_ITEMS_DELETE
  LOCATIONS_ACTIVATE
  LOCATIONS_DEACTIVATE
  LOCATIONS_CREATE
  LOCATIONS_UPDATE
  LOCATIONS_DELETE
  TENDER_TRANSACTIONS_CREATE
  APP_PURCHASES_ONE_TIME_UPDATE
  APP_SUBSCRIPTIONS_APPROACHING_CAPPED_AMOUNT
  APP_SUBSCRIPTIONS_UPDATE
  LOCALES_CREATE
  LOCALES_UPDATE
  DOMAINS_CREATE
  DOMAINS_UPDATE
  DOMAINS_DESTROY
  SUBSCRIPTION_CONTRACTS_CREATE
  SUBSCRIPTION_CONTRACTS_UPDATE
  SUBSCRIPTION_BILLING_CYCLE_EDITS_CREATE
  SUBSCRIPTION_BILLING_CYCLE_EDITS_UPDATE
  SUBSCRIPTION_BILLING_CYCLE_EDITS_DELETE
  PROFILES_CREATE
  PROFILES_UPDATE
  PROFILES_DELETE
  SUBSCRIPTION_BILLING_ATTEMPTS_SUCCESS
  SUBSCRIPTION_BILLING_ATTEMPTS_FAILURE
  SUBSCRIPTION_BILLING_ATTEMPTS_CHALLENGED
  RETURNS_CANCEL
  RETURNS_CLOSE
  RETURNS_REOPEN
  RETURNS_REQUEST
  RETURNS_APPROVE
  RETURNS_UPDATE
  RETURNS_DECLINE
  REVERSE_DELIVERIES_ATTACH_DELIVERABLE
  REVERSE_FULFILLMENT_ORDERS_DISPOSE
  PAYMENT_TERMS_CREATE
  PAYMENT_TERMS_DELETE
  PAYMENT_TERMS_UPDATE
  PAYMENT_SCHEDULES_DUE
  SELLING_PLAN_GROUPS_CREATE
  SELLING_PLAN_GROUPS_UPDATE
  SELLING_PLAN_GROUPS_DELETE
  BULK_OPERATIONS_FINISH
  PRODUCT_FEEDS_CREATE
  PRODUCT_FEEDS_UPDATE
  PRODUCT_FEEDS_INCREMENTAL_SYNC
  PRODUCT_FEEDS_FULL_SYNC
  PRODUCT_FEEDS_FULL_SYNC_FINISH
  MARKETS_CREATE
  MARKETS_UPDATE
  MARKETS_DELETE
  ORDERS_RISK_ASSESSMENT_CHANGED
  ORDERS_SHOPIFY_PROTECT_ELIGIBILITY_CHANGED
  FULFILLMENT_ORDERS_RESCHEDULED
  PUBLICATIONS_DELETE
  AUDIT_EVENTS_ADMIN_API_ACTIVITY
  FULFILLMENT_ORDERS_LINE_ITEMS_PREPARED_FOR_PICKUP
  COMPANIES_CREATE
  COMPANIES_UPDATE
  COMPANIES_DELETE
  COMPANY_LOCATIONS_CREATE
  COMPANY_LOCATIONS_UPDATE
  COMPANY_LOCATIONS_DELETE
  COMPANY_CONTACTS_CREATE
  COMPANY_CONTACTS_UPDATE
  COMPANY_CONTACTS_DELETE
  CUSTOMERS_MERGE
  CUSTOMER_ACCOUNT_SETTINGS_UPDATE
  CUSTOMER_JOINED_SEGMENT
  CUSTOMER_LEFT_SEGMENT
  COMPANY_CONTACT_ROLES_ASSIGN
  COMPANY_CONTACT_ROLES_REVOKE
  SUBSCRIPTION_CONTRACTS_ACTIVATE
  SUBSCRIPTION_CONTRACTS_PAUSE
  SUBSCRIPTION_CONTRACTS_CANCEL
  SUBSCRIPTION_CONTRACTS_FAIL
  SUBSCRIPTION_CONTRACTS_EXPIRE
  SUBSCRIPTION_BILLING_CYCLES_SKIP
  SUBSCRIPTION_BILLING_CYCLES_UNSKIP
  METAOBJECTS_CREATE
  METAOBJECTS_UPDATE
  METAOBJECTS_DELETE
  DISCOUNTS_CREATE
  DISCOUNTS_UPDATE
  DISCOUNTS_DELETE
  DISCOUNTS_REDEEMCODE_ADDED
  DISCOUNTS_REDEEMCODE_REMOVED
  METAFIELD_DEFINITIONS_CREATE
  METAFIELD_DEFINITIONS_UPDATE
  METAFIELD_DEFINITIONS_DELETE
  DELIVERY_PROMISE_SETTINGS_UPDATE
}
type WebhookSubscriptionUpdatePayload {
  userErrors: [UserError!]!
  webhookSubscription: WebhookSubscription
}
type Weight {
  unit: WeightUnit!
  value: Float!
}
input WeightInput {
  value: Float!
  unit: WeightUnit!
}
enum WeightUnit {
  KILOGRAMS
  GRAMS
  POUNDS
  OUNCES
}
type __Directive {
  args: [__InputValue!]!
  description: String
  isRepeatable: Boolean
  locations: [__DirectiveLocation!]!
  name: String!
  onField: Boolean!
  onFragment: Boolean!
  onOperation: Boolean!
}
enum __DirectiveLocation {
  QUERY
  MUTATION
  SUBSCRIPTION
  FIELD
  FRAGMENT_DEFINITION
  FRAGMENT_SPREAD
  INLINE_FRAGMENT
  SCHEMA
  SCALAR
  OBJECT
  FIELD_DEFINITION
  ARGUMENT_DEFINITION
  INTERFACE
  UNION
  ENUM
  ENUM_VALUE
  INPUT_OBJECT
  INPUT_FIELD_DEFINITION
  VARIABLE_DEFINITION
}
type __EnumValue {
  deprecationReason: String
  description: String
  isDeprecated: Boolean!
  isPrivatelyDocumented: Boolean!
  name: String!
}
type __Field {
  accessRestricted: Boolean!
  accessRestrictedReason: String
  args: [__InputValue!]!
  deprecationReason: String
  description: String
  isDeprecated: Boolean!
  isPrivatelyDocumented: Boolean!
  isProtected: Boolean!
  name: String!
  protectedContent: String
  protectedSubject: String
  requiredAccess: String
  type: __Type!
}
type __InputValue {
  defaultValue: String
  deprecationReason: String
  description: String
  gidTypes: [String!]
  isDeprecated: Boolean!
  name: String!
  type: __Type!
}
type __Schema {
  description: String
  directives: [__Directive!]!
  mutationType: __Type
  queryType: __Type!
  subscriptionType: __Type
  types: [__Type!]!
}
type __Type {
  accessRestricted: Boolean!
  accessRestrictedReason: String
  componentName: String
  description: String
  enumValues: [__EnumValue!]
  fields: [__Field!]
  inputFields: [__InputValue!]
  interfaces: [__Type!]
  isOneOf: Boolean!
  isPrivatelyDocumented: Boolean!
  isProtected: Boolean!
  kind: __TypeKind!
  name: String
  ofType: __Type
  possibleTypes: [__Type!]
  protectedSubject: String
  requiredAccess: String
  specifiedByURL: String
}
enum __TypeKind {
  SCALAR
  OBJECT
  INTERFACE
  UNION
  ENUM
  INPUT_OBJECT
  LIST
  NON_NULL
}
